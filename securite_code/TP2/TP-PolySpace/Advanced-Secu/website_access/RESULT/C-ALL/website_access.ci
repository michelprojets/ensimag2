# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c"
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h" 1
/*
 *
 * Copyright 1999-2017 The MathWorks, Inc.
 *
 */

/*
  Polyspace include for varargs.

  stdarg.h

  This include is designed for polyspace compilation pass.
*/


/* Prevent other libs from defining the types and macros about varargs */
# 24 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"

# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"











typedef void *__va_list;



typedef __va_list va_list;
typedef __va_list __gnuc_va_list;

/* Diab <stdio.h> flavors assume existence of non-standard _va_list type. */






# 65 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"



# 87 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"

# 94 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"









# 114 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdarg.h"

# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
/* ------------------------------------------------------------ *
 * file:        sslconnect.c                                    *
 * purpose:     Example code for building a SSL connection and  *
 *              retrieving the server certificate               *
 * author:      06/12/2012 Frank4DD                             *
 *                                                              *
 * gcc -o website_access website_access.c -lssl -lcrypto        *
 * try                                                          *
 * valgrind --leak-check=full website_access https://www.hp.com *
 * ------------------------------------------------------------ */

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 1
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.19 Input/output     <stdio.h>
 */



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__      ISO Standard C.
   _ISOC99_SOURCE       Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE       Extensions to ISO C99 from ISO C11.
   _POSIX_SOURCE        IEEE Std 1003.1.
   _POSIX_C_SOURCE      If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
                        if >=199309L, add IEEE Std 1003.1b-1993;
                        if >=199506L, add IEEE Std 1003.1c-1995;
                        if >=200112L, all of IEEE 1003.1-2004
                        if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE        Includes POSIX and XPG things.  Set to 500 if
                        Single Unix conformance is wanted, to 600 for the
                        sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE    Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE  Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N  Select default filesystem interface.
   _ATFILE_SOURCE       Additional *at interfaces.
   _GNU_SOURCE          All of the above, plus GNU extensions.
   _DEFAULT_SOURCE      The default set of features (taking precedence over
                        __STRICT_ANSI__).
   _REENTRANT           Select additionally reentrant object.
   _THREAD_SAFE         Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE      If set to numeric value > 0 additional security
                        measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC11         Define ISO C11 things.
   __USE_ISOC99         Define ISO C99 things.
   __USE_ISOC95         Define ISO C90 AMD1 (C95) things.
   __USE_POSIX          Define IEEE Std 1003.1 things.
   __USE_POSIX2         Define IEEE Std 1003.2 things.
   __USE_POSIX199309    Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506    Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN          Define XPG things.
   __USE_XOPEN_EXTENDED Define X/Open Unix things.
   __USE_UNIX98         Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE      Define correct standard I/O things.
   __USE_LARGEFILE64    Define LFS things with separate names.
   __USE_FILE_OFFSET64  Define 64bit interface as default.
   __USE_MISC           Define things from 4.3BSD or System V Unix.
   __USE_ATFILE         Define *at interfaces and AT_* constants for them.
   __USE_GNU            Define GNU extensions.
   __USE_REENTRANT      Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL  Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
# 121 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */




/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
# 141 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  */
# 152 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 176 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  */
# 187 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* This is to enable the ISO C11 extension.  */





/* This is to enable the ISO C99 extension.  */





/* This is to enable the ISO C90 Amendment 1:1995 extension.  */





/* This is to enable compatibility for ISO C++11.

   So far g++ does not provide a macro.  Check the temporary macro for
   now, too.  */





/* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  */
# 242 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"



















# 268 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"







# 300 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"





























# 339 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h"

/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdc-predef.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */

# 43 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdc-predef.h"

# 51 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdc-predef.h"

/* wchar_t uses Unicode 9.0.0.  Version 9.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2014, fourth edition, plus
   Amd. 1  and Amd. 2 and 273 characters from forthcoming  10646, fifth edition.
   (Amd. 2 was published 2016-05-01,
   see https://www.iso.org/obp/ui/#iso:std:iso-iec:10646:ed-4:v1:amd:2:v1:en) */


/* We do not support C11 <threads.h>.  */


# 343 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h" 2

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */



/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */






/* This is here only because every header file already includes this one.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h" 1
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */



# 71 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"









/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */



/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */




/* This is not a typedef so `const __ptr_t' does the right thing.  */




/* C++ needs to know that types and declarations are C, not C++.  */
# 104 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"


/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 119 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# 129 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"


/* Fortify support.  */



# 146 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* Support for flexible arrays.  */
# 158 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"
/* Some other non-C99 compiler.  Approximate with [1].  */






/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */

# 199 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* Tell the compiler which arguments to an allocation function
   indicate the size of the allocation.  */
# 224 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* This declaration tells the compiler that the value is constant.  */






/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
# 251 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* gcc allows marking deprecated functions.  */






/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */






/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */
# 281 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */






/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
# 304 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* Forces a function to be always inlined.  */
# 316 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

/* Associate error messages with the source location of the call site rather
   than with the source location inside the function.  */






/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
   or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
   older than 4.3 may define these macros and still not guarantee GNU inlining
   semantics.

   clang++ identifies itself as gcc-4.2, but has support for GNU inlining
   semantics, that can be checked fot by using the __GNUC_STDC_INLINE_ and
   __GNUC_GNU_INLINE__ macro definitions.  */
# 346 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"





/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */





/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
# 383 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"
/* Some other non-C99 compiler.  */





# 396 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

# 406 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

# 414 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 416 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h" 2

# 448 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/cdefs.h"

# 365 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h" 2


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */







/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/gnu/stubs.h" 1
/* This file is automatically generated.
   This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */


# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/gnu/stubs-32.h" 1
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */





# 8 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/gnu/stubs.h" 2
# 389 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/features.h" 2


# 28 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stddef.h" 1
/* Copyright 2012-2013 The MathWorks, Inc. */













typedef unsigned int size_t;


typedef int wchar_t;


typedef int ptrdiff_t;
# 30 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stddef.h"





# 34 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/types.h" 1
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 28 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/types.h" 2

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




 typedef signed long long int __int64_t;
 typedef unsigned long long int __uint64_t;


/* quad_t is also 64 bits.  */




 typedef long long int __quad_t;
 typedef unsigned long long int __u_quad_t;



/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

        16              -- "natural" 16-bit type (always short)
        32              -- "natural" 32-bit type (always int)
        64              -- "natural" 64-bit type (long or long long)
        LONG32          -- 32-bit type, traditionally long
        QUAD            -- 64-bit type, always long long
        WORD            -- natural type of __WORDSIZE bits (int or long)
        LONGWORD        -- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */

# 104 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/types.h"
/* We want __extension__ before typedef's that use nonstandard base types
   such as `long long' in C89 mode.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/typesizes.h" 1
/* bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */








/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

/* X32 kernel interface is 64-bit.  */
# 37 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/typesizes.h"

# 75 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/typesizes.h"

# 85 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/typesizes.h"

/* Number of descriptors that can fit in an `fd_set'.  */



# 122 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/types.h" 2


 typedef __u_quad_t __dev_t;        /* Type of device numbers.  */
 typedef unsigned int __uid_t;        /* Type of user identifications.  */
 typedef unsigned int __gid_t;        /* Type of group identifications.  */
 typedef unsigned long int __ino_t;        /* Type of file serial numbers.  */
 typedef __u_quad_t __ino64_t;    /* Type of file serial numbers (LFS).*/
 typedef unsigned int __mode_t;      /* Type of file attribute bitmasks.  */
 typedef unsigned int __nlink_t;    /* Type of file link counts.  */
 typedef long int __off_t;        /* Type of file sizes and offsets.  */
 typedef __quad_t __off64_t;    /* Type of file sizes and offsets (LFS).  */
 typedef int __pid_t;        /* Type of process identifications.  */
 typedef struct { int __val[2]; } __fsid_t;      /* Type of file system IDs.  */
 typedef long int __clock_t;    /* Type of CPU usage counts.  */
 typedef unsigned long int __rlim_t;      /* Type for resource measurement.  */
 typedef __u_quad_t __rlim64_t;  /* Type for resource measurement (LFS).  */
 typedef unsigned int __id_t;          /* General type for IDs.  */
 typedef long int __time_t;      /* Seconds since the Epoch.  */
 typedef unsigned int __useconds_t; /* Count of microseconds.  */
 typedef long int __suseconds_t; /* Signed count of microseconds.  */

 typedef int __daddr_t;    /* The type of a disk address.  */
 typedef int __key_t;        /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
 typedef int __clockid_t;

/* Timer ID returned by `timer_create'.  */
 typedef void * __timer_t;

/* Type to represent block size.  */
 typedef long int __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
 typedef long int __blkcnt_t;
 typedef __quad_t __blkcnt64_t;

/* Type to count file system blocks.  */
 typedef unsigned long int __fsblkcnt_t;
 typedef __u_quad_t __fsblkcnt64_t;

/* Type to count file system nodes.  */
 typedef unsigned long int __fsfilcnt_t;
 typedef __u_quad_t __fsfilcnt64_t;

/* Type of miscellaneous file system fields.  */
 typedef int __fsword_t;

 typedef int __ssize_t; /* Type of a byte count, or error.  */

/* Signed long type used in system calls.  */
 typedef long int __syscall_slong_t;
/* Unsigned long type used in system calls.  */
 typedef unsigned long int __syscall_ulong_t;

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t;     /* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
 typedef int __intptr_t;

/* Duplicate info from sys/socket.h.  */
 typedef unsigned int __socklen_t;




# 36 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2







/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;


/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;














/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;









# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/_G_config.h" 1
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */




/* Define types for libio in terms of the standard internal type names.  */

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/wchar.h" 1
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *      Extended multibyte and wide character utilities <wchar.h>
 */








# 78 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/wchar.h"



/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    int __wch;



    char __wchb[4];
  } __value;            /* Value so far.  */
} __mbstate_t;




/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
# 897 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/wchar.h"



/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 21 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/_G_config.h" 2
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 43 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/_G_config.h"


/* These library features are always available in the GNU C library.  */







/* This is defined by <bits/stat.h> if `st_blksize' exists.  */




# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h" 2
/* ALL of these should be defined in _G_config.h */
# 46 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

/* This define avoids name pollution if we're using GNU stdarg.h */
# 54 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"







# 76 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

# 85 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */

# 111 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

# 123 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

/* These are "formatting flags" matching the iostream fmtflags enum values. */
# 142 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"


struct _IO_jump_t;  struct _IO_FILE;

/* Handle lock.  */



typedef void _IO_lock_t;



/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
# 173 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"
};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};

# 240 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

struct _IO_FILE {
  int _flags;           /* High-order word is _IO_MAGIC; rest is flags. */


  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;   /* Current read pointer */
  char* _IO_read_end;   /* End of get area. */
  char* _IO_read_base;  /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr;  /* Current put pointer. */
  char* _IO_write_end;  /* End of put area. */
  char* _IO_buf_base;   /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset; /* This used to be _offset but it's too small.  */


  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
# 289 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"
  __off64_t _offset;
# 297 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 327 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"


/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written.  If
   there is an error, return 0 and do not write anything.  If the file
   has been opened for append (__mode.__append set), then set the file
   pointer to the end of the file and then do the write; if not, just
   write at the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
                                 size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);


# 379 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"






extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);












# 411 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

# 425 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"




extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) ;
extern int _IO_ferror (_IO_FILE *__fp) ;

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */



extern void _IO_flockfile (_IO_FILE *) ;
extern void _IO_funlockfile (_IO_FILE *) ;
extern int _IO_ftrylockfile (_IO_FILE *) ;

# 458 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"

extern int _IO_vfscanf (_IO_FILE * , const char * ,
                        __gnuc_va_list, int *);
extern int _IO_vfprintf (_IO_FILE *, const char *,
                         __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) ;

# 515 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/libio.h"









# 75 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2

# 86 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"




typedef __off_t off_t;
# 101 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"



typedef __ssize_t ssize_t;




/* The type of the second argument to `fgetpos' and `fsetpos'.  */


typedef _G_fpos_t fpos_t;








/* The possibilities for the third argument to `setvbuf'.  */





/* Default buffer size.  */





/* End of file character.
   Some things throughout the library rely on this being -1.  */





/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
# 149 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"



/* Default path prefix for `tempnam' and `tmpnam'.  */




/* Get the values:
   L_tmpnam     How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX      The minimum number of unique filenames generated by tmpnam
                (and tempnam when it uses tmpnam's name space),
                or tempnam (the two are separate).
   L_ctermid    How long an array to pass to `ctermid'.
   L_cuserid    How long an array to pass to `cuserid'.
   FOPEN_MAX    Minimum number of files that can be open at once.
   FILENAME_MAX Maximum length of a filename.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/stdio_lim.h" 1
/* Copyright (C) 1994-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */










# 34 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/stdio_lim.h"






# 167 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2


/* Standard streams.  */
extern struct _IO_FILE *stdin;          /* Standard input stream.  */
extern struct _IO_FILE *stdout;         /* Standard output stream.  */
extern struct _IO_FILE *stderr;         /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */





/* Remove file FILENAME.  */
extern int remove (const char *__filename) ;
/* Rename file OLD to NEW.  */
extern int rename (const char *__old, const char *__new) ;



/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, const char *__old, int __newfd,
                     const char *__new) ;



/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern FILE *tmpfile (void) ;
# 205 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"





/* Generate a temporary filename.  */
extern char *tmpnam (char *__s)  ;



/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s)  ;




/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (const char *__dir, const char *__pfx)
       ;




/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);



/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);


# 266 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"




/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (const char * __filename,
                    const char * __modes) ;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (const char * __filename,
                      const char * __modes,
                      FILE * __stream) ;
# 297 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"

# 305 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char *__modes)  ;


# 318 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
   ;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc)  ;




/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE * __stream, char * __buf) ;
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE * __stream, char * __buf,
                    int __modes, size_t __n) ;



/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE * __stream, char * __buf,
                       size_t __size) ;

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) ;




/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE * __stream,
                    const char * __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (const char * __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char * __s,
                    const char * __format, ...) ;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE * __s, const char * __format,
                     __gnuc_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (const char * __format, __gnuc_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char * __s, const char * __format,
                     __gnuc_va_list __arg) ;




/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char * __s, size_t __maxlen,
                     const char * __format, ...)
      ;

extern int vsnprintf (char * __s, size_t __maxlen,
                      const char * __format, __gnuc_va_list __arg)
      ;



# 411 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


/* Write formatted output to a file descriptor.  */
extern int vdprintf (int __fd, const char * __fmt,
                     __gnuc_va_list __arg)
     ;
extern int dprintf (int __fd, const char * __fmt, ...)
     ;




/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE * __stream,
                   const char * __format, ...) ;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (const char * __format, ...) ;
/* Read formatted input from S.  */
extern int sscanf (const char * __s,
                   const char * __format, ...) ;

# 454 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"
extern int __isoc99_fscanf (FILE * __stream,
                            const char * __format, ...) ;
extern int __isoc99_scanf (const char * __format, ...) ;
extern int __isoc99_sscanf (const char * __s,
                            const char * __format, ...) ;










/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE * __s, const char * __format,
                    __gnuc_va_list __arg)
      ;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (const char * __format, __gnuc_va_list __arg)
      ;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (const char * __s,
                    const char * __format, __gnuc_va_list __arg)
      ;

# 510 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"
extern int __isoc99_vfscanf (FILE * __s,
                             const char * __format,
                             __gnuc_va_list __arg) ;
extern int __isoc99_vscanf (const char * __format,
                            __gnuc_va_list __arg) ;
extern int __isoc99_vsscanf (const char * __s,
                             const char * __format,
                             __gnuc_va_list __arg) ;











/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);


/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */



/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);



/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);




/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);


/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */



/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);



/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);





/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);




/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char * __s, int __n, FILE * __stream)
     ;

# 642 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


# 654 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"



/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern __ssize_t __getdelim (char ** __lineptr,
                               size_t * __n, int __delimiter,
                               FILE * __stream) ;
extern __ssize_t getdelim (char ** __lineptr,
                             size_t * __n, int __delimiter,
                             FILE * __stream) ;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern __ssize_t getline (char ** __lineptr,
                            size_t * __n,
                            FILE * __stream) ;




/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputs (const char * __s, FILE * __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int puts (const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fread (void * __ptr, size_t __size,
                     size_t __n, FILE * __stream) ;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fwrite (const void * __ptr, size_t __size,
                      size_t __n, FILE * __s);


# 731 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void * __ptr, size_t __size,
                              size_t __n, FILE * __stream) ;
extern size_t fwrite_unlocked (const void * __ptr, size_t __size,
                               size_t __n, FILE * __stream);




/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) ;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);


/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */



/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream) ;
# 793 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"



/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE * __stream, fpos_t * __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 817 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


# 825 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"


/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) ;
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream)  ;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream)  ;



/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) ;
extern int feof_unlocked (FILE *__stream)  ;
extern int ferror_unlocked (FILE *__stream)  ;




/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (const char *__s);


/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sys_errlist.h" 1
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */


extern int sys_nerr;
extern const char *const sys_errlist[];
# 856 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h" 2



/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream)  ;



/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream)  ;




/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (const char *__command, const char *__modes) ;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);




/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) ;









# 908 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"



/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) ;

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream)  ;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) ;


# 931 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
# 943 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdio.h"





# 13 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.20 General utilities        <stdlib.h>
 */





/* Get size_t, wchar_t and NULL from <stddef.h>.  */
# 33 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"







/* XPG requires a few symbols from <sys/wait.h> being defined.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/waitflags.h" 1
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Bits in the third argument to `waitpid'.  */



/* Bits in the fourth argument to `waitid'.  */










/* The following values are used by the `waitid' function.  */




/* The Linux kernel defines these bare, rather than an enum,
   which causes a conflict if the include order is reversed. */




typedef enum
{
  P_ALL,                /* Wait for any child.  */
  P_PID,                /* Wait for specified process.  */
  P_PGID                /* Wait for members of process group.  */
} idtype_t;
# 42 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/waitstatus.h" 1
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */


/* If WIFSIGNALED(STATUS), the terminating signal.  */


/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */


/* Nonzero if STATUS indicates normal termination.  */


/* Nonzero if STATUS indicates termination by a signal.  */



/* Nonzero if STATUS indicates the child is stopped.  */


/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */




/* Nonzero if STATUS indicates the child dumped core.  */


/* Macros for constructing status values.  */
# 43 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 2

/* Define the macros <sys/wait.h> also would define this way.  */
# 55 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Returned by `div'.  */
typedef struct
  {
    int quot;                   /* Quotient.  */
    int rem;                    /* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */

typedef struct
  {
    long int quot;              /* Quotient.  */
    long int rem;               /* Remainder.  */
  } ldiv_t;






/* Returned by `lldiv'.  */
 typedef struct
  {
    long long int quot;         /* Quotient.  */
    long long int rem;          /* Remainder.  */
  } lldiv_t;





/* The largest number rand will return (same as INT_MAX).  */



/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */




/* Maximum length of a multibyte character in the current locale.  */

#pragma POLYSPACE_METRICS_IGNORE "__ctype_get_mb_cur_max"
extern size_t __ctype_get_mb_cur_max (void)  ;



/* Convert a string to a floating-point number.  */
extern double atof (const char *__nptr)
        ;
/* Convert a string to an integer.  */
extern int atoi (const char *__nptr)
        ;
/* Convert a string to a long integer.  */
extern long int atol (const char *__nptr)
        ;




/* Convert a string to a long long integer.  */
 extern long long int atoll (const char *__nptr)
        ;




/* Convert a string to a floating-point number.  */
extern double strtod (const char * __nptr,
                      char ** __endptr)
      ;




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (const char * __nptr,
                     char ** __endptr)  ;

extern long double strtold (const char * __nptr,
                            char ** __endptr)
      ;




/* Convert a string to a long integer.  */
extern long int strtol (const char * __nptr,
                        char ** __endptr, int __base)
      ;
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (const char * __nptr,
                                  char ** __endptr, int __base)
      ;



/* Convert a string to a quadword integer.  */

extern long long int strtoq (const char * __nptr,
                             char ** __endptr, int __base)
      ;
/* Convert a string to an unsigned quadword integer.  */

extern unsigned long long int strtouq (const char * __nptr,
                                       char ** __endptr, int __base)
      ;




/* Convert a string to a quadword integer.  */

extern long long int strtoll (const char * __nptr,
                              char ** __endptr, int __base)
      ;
/* Convert a string to an unsigned quadword integer.  */

extern unsigned long long int strtoull (const char * __nptr,
                                        char ** __endptr, int __base)
      ;




# 235 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


# 261 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"



/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n)  ;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (const char *__s)
        ;



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      POSIX Standard: 2.6 Primitive System Data Types <sys/types.h>
 */












typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 58 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h"


typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;



# 96 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h"


typedef __pid_t pid_t;





typedef __id_t id_t;










typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.23 Date and time    <time.h>
 */



# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 51 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"







/* Returned by `clock'.  */
typedef __clock_t clock_t;














/* Returned by `time'.  */
typedef __time_t time_t;














/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;










/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;





# 128 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


# 436 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 133 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 2

# 144 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h"





/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


/* These size-specific names are used by some of the inet code.  */



/* These types are defined by the ISO C99 header <inttypes.h>. */


typedef char int8_t;
typedef short int int16_t;
typedef int int32_t;



 typedef long long int int64_t;



/* But these were defined by ISO C without the first `_'.  */
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;



 typedef unsigned long long int u_int64_t;


typedef int register_t;

# 216 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h"



/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/endian.h" 1
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */





/* This file defines `__BYTE_ORDER' for the particular machine.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/endian.h" 1
/* i386/x86_64 are little-endian.  */





# 37 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/endian.h" 2

/* Some machines may need to use a different endianness for floating point
   values.  */




# 52 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/endian.h"









/* Conversion interfaces.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h" 1
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */








# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 29 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h" 2

/* Swap bytes in 16 bit value.  */



/* Get __bswap_16.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap-16.h" 1
/* Macros to swap the order of bytes in 16-bit integer values.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 44 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap-16.h"
static  unsigned short int
__bswap_16 (unsigned short int __bsx)
{
  return ((unsigned short int) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));
}
# 36 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h" 2

/* Swap bytes in 32 bit value.  */




# 87 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h"
static  unsigned int
__bswap_32 (unsigned int __bsx)
{
  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >> 8) | (((__bsx) & 0x0000ff00) << 8) | (((__bsx) & 0x000000ff) << 24));
}



# 147 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h"

static  __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));
}


# 63 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/endian.h" 2

















# 97 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/endian.h"

# 221 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 2

/* It also defines `fd_set' and the FD_* macros for `select'.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/select.h" 1
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*      POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */






/* Get definition of needed basic types.  */


/* Get __FD_* definitions.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/select.h" 1
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 23 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/select.h" 2


# 45 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/select.h"

/* We don't use `memset' because this would require a prototype and
   the array isn't too big.  */
# 55 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/select.h"



# 31 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/select.h" 2

/* Get __sigset_t.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigset.h" 1
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */


typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;




/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */

# 34 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/select.h" 2



typedef __sigset_t sigset_t;


/* Get definition of timer specification structures.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.23 Date and time    <time.h>
 */



# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 51 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 67 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 83 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 95 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 107 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


# 115 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"



/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec;            /* Seconds.  */
    __syscall_slong_t tv_nsec;  /* Nanoseconds.  */
  };





# 436 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 46 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/select.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h" 1
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */






/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec;            /* Seconds.  */
    __suseconds_t tv_usec;      /* Microseconds.  */
  };



# 100 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"

# 48 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/select.h" 2


typedef __suseconds_t suseconds_t;




/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define this macros.  */

/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */




/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */




    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */



/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */




/* Access macros for `fd_set'.  */








/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set * __readfds,
                   fd_set * __writefds,
                   fd_set * __exceptfds,
                   struct timeval * __timeout);


/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set * __readfds,
                    fd_set * __writefds,
                    fd_set * __exceptfds,
                    const struct timespec * __timeout,
                    const __sigset_t * __sigmask);



/* Define some inlines helping to catch common problems.  */






# 224 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 2

/* BSD defines these symbols, so we follow.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/sysmacros.h" 1
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */









extern unsigned int gnu_dev_major (unsigned long long int __dev)
      ;

extern unsigned int gnu_dev_minor (unsigned long long int __dev)
      ;

extern unsigned long long int gnu_dev_makedev (unsigned int __major,
                                               unsigned int __minor)
      ;

# 58 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/sysmacros.h"


/* Access the functions with their traditional names.  */




# 227 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 2





typedef __blksize_t blksize_t;



/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t;     /* Type to count number of disk blocks.  */



typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */



typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
# 264 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h"








/* Now add the thread types.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h" 1
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 22 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h" 2
/* Polyspace: __align is a keyword for tasking dialect */





# 61 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h"


/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




# 86 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;



/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;



    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;
# 116 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h"
    unsigned int __nusers;
     union
    {
      struct
      {
        short __espins;
        short __elision;



      } __elision_data;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
     unsigned long long int __total_seq;
     unsigned long long int __wakeup_seq;
     unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
   long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;



/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{
# 207 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/pthreadtypes.h"
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned char __flags;
    unsigned char __shared;
    signed char __rwelision;

    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;




/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;




/* Extra attributes for the cleanup functions.  */



/* Polyspace */





# 275 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/types.h" 2




# 277 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 2

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) ;

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) ;

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
                        size_t __statelen)  ;

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf)  ;



/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr;              /* Front pointer.  */
    int32_t *rptr;              /* Rear pointer.  */
    int32_t *state;             /* Array of state values.  */
    int rand_type;              /* Type of random number generator.  */
    int rand_deg;               /* Degree of random number generator.  */
    int rand_sep;               /* Distance between front and rear.  */
    int32_t *end_ptr;           /* Pointer behind state table.  */
  };

extern int random_r (struct random_data * __buf,
                     int32_t * __result)  ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
      ;

extern int initstate_r (unsigned int __seed, char * __statebuf,
                        size_t __statelen,
                        struct random_data * __buf)
      ;

extern int setstate_r (char * __statebuf,
                       struct random_data * __buf)
      ;





/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) ;
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) ;



/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) ;




/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3])  ;

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3])
      ;

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3])
      ;

/* Seed random number generator.  */
extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
      ;
extern void lcong48 (unsigned short int __param[7])  ;


/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3];  /* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c;     /* Additive const. in congruential formula.  */
    unsigned short int __init;  /* Flag for initializing.  */
     unsigned long long int __a;   /* Factor in congruential
                                                   formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data * __buffer,
                      double * __result)  ;
extern int erand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      double * __result)  ;

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data * __buffer,
                      long int * __result)
      ;
extern int nrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      long int * __result)
      ;

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data * __buffer,
                      long int * __result)
      ;
extern int jrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      long int * __result)
      ;

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
      ;

extern int seed48_r (unsigned short int __seed16v[3],
                     struct drand48_data *__buffer)  ;

extern int lcong48_r (unsigned short int __param[7],
                      struct drand48_data *__buffer)
      ;








/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size)   ;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
       ;





/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
      ;
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) ;



/* Free a block.  An alias for `free'.  (Sun Unices).  */
extern void cfree (void *__ptr) ;


# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/alloca.h" 1
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */











/* Remove any previous definitions.  */


/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) ;







# 455 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 2




/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size)   ;



/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
       ;



/* ISO C variant of aligned allocation.  */
extern void *aligned_alloc (size_t __alignment, size_t __size)
        ;



/* Abort execution and generate a core-dump.  */
extern void abort (void)  ;


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void))  ;


/* Register a function to be called when `quick_exit' is called.  */




extern int at_quick_exit (void (*__func) (void))  ;





/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
      ;



/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status)  ;


/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
extern void quick_exit (int __status)  ;





/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status)  ;





/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (const char *__name)   ;


# 535 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* The SVID says this is in <stdio.h>, but this seems a better place.   */
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string)  ;



/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (const char *__name, const char *__value, int __replace)
      ;

/* Remove the variable NAME from the environment.  */
extern int unsetenv (const char *__name)  ;



/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) ;





/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Always returns TEMPLATE, it's either a temporary file name or a null
   string if it cannot get a unique file name.  */
extern char *mktemp (char *__template)  ;



/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemp (char *__template)  ;
# 594 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemps (char *__template, int __suffixlen)  ;
# 617 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template)   ;


# 671 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"



/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (const char *__command) ;



# 688 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (const char * __name,
                       char * __resolved)  ;



/* Shorthand for type of comparison functions.  */


typedef int (*__compar_fn_t) (const void *, const void *);

# 712 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (const void *__key, const void *__base,
                      size_t __nmemb, size_t __size, __compar_fn_t __compar)
      ;





/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
                   __compar_fn_t __compar) ;







/* Return the absolute value of X.  */
extern int abs (int __x)   ;
extern long int labs (long int __x)   ;



 extern long long int llabs (long long int __x)
       ;




/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
       ;
extern ldiv_t ldiv (long int __numer, long int __denom)
       ;




 extern lldiv_t lldiv (long long int __numer,
                                    long long int __denom)
       ;






/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int * __decpt,
                   int * __sign)   ;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int * __decpt,
                   int * __sign)   ;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
       ;



/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
                    int * __decpt, int * __sign)
       ;
extern char *qfcvt (long double __value, int __ndigit,
                    int * __decpt, int * __sign)
       ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
       ;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int * __decpt,
                   int * __sign, char * __buf,
                   size_t __len)  ;
extern int fcvt_r (double __value, int __ndigit, int * __decpt,
                   int * __sign, char * __buf,
                   size_t __len)  ;

extern int qecvt_r (long double __value, int __ndigit,
                    int * __decpt, int * __sign,
                    char * __buf, size_t __len)
      ;
extern int qfcvt_r (long double __value, int __ndigit,
                    int * __decpt, int * __sign,
                    char * __buf, size_t __len)
      ;




/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (const char *__s, size_t __n) ;
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t * __pwc,
                   const char * __s, size_t __n) ;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) ;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *  __pwcs,
                        const char * __s, size_t __n) ;
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char * __s,
                        const wchar_t * __pwcs, size_t __n)
     ;




/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (const char *__response)   ;




/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char ** __optionp,
                      char *const * __tokens,
                      char ** __valuep)
       ;









/* X/Open pseudo terminal handling.  */






# 896 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"

# 907 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"


/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
      ;








# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/stdlib-float.h" 1
/* Floating-point inline functions for stdlib.h.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 923 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h" 2

/* Define some macros helping to catch buffer overflows.  */
# 931 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdlib.h"






# 14 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      POSIX Standard: 2.10 Symbolic Constants         <unistd.h>
 */








/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */


/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
# 48 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */



/* The utilities on GNU systems also correspond to this version.  */
# 65 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

/* The utilities on GNU systems also correspond to this version.  */


/* This symbol was required until the 2001 edition of POSIX.  */


/* If defined, the implementation supports the
   C Language Bindings Option.  */


/* If defined, the implementation supports the
   C Language Development Utilities Option.  */


/* If defined, the implementation supports the
   Software Development Utilities Option.  */


/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */


/* X/Open version number to which the library conforms.  It is selectable.  */
# 98 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

/* Commands and utilities from XPG4 are available.  */


/* We are compatible with the old published standards as well.  */




/* The X/Open Unix extensions are available.  */


/* Encryption is present.  */


/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */


/* The legacy interfaces are also available.  */



/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL           Job control is supported.
   _POSIX_SAVED_IDS             Processes have a saved set-user-ID
                                and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS      Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING   Priority scheduling is supported.
   _POSIX_TIMERS                POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO       Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO        Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO       Synchronizing file data is supported.
   _POSIX_FSYNC                 The fsync function is present.
   _POSIX_MAPPED_FILES          Mapping of files to memory is supported.
   _POSIX_MEMLOCK               Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE         Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION     Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING       POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES            POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS POSIX.4 shared memory objects are supported.
   _POSIX_THREADS               POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
                                POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT   Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT   Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED Process-shared synchronization supported.
   _POSIX_PII                   Protocol-independent interfaces are supported.
   _POSIX_PII_XTI               XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET            Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET          Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM   Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM    Connectionless Internet protocol supported.
   _POSIX_PII_OSI               ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS          Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS          Connectionless ISO/OSI service supported.
   _POSIX_POLL                  Implementation supports `poll' function.
   _POSIX_SELECT                Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME              X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS      X/Open realtime thread support is available.
   _XOPEN_SHM                   Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32            Implementation provides environment with 32-bit
                                int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG           Implementation provides environment with 32-bit
                                int, long, and pointer and off_t with at least
                                64 bits.
   _XBS5_LP64_OFF64             Implementation provides environment with 32-bit
                                int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG           Implementation provides environment with at
                                least 32 bits int and long, pointer, and off_t
                                with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED      Only the super user can use `chown' to change
                                the owner of a file.  `chown' can only be used
                                to change the group ID of a file to a group of
                                which the calling process is a member.
   _POSIX_NO_TRUNC              Pathname components longer than
                                NAME_MAX generate an error.
   _POSIX_VDISABLE              If defined, if the value of an element of the
                                `c_cc' member of `struct termios' is
                                _POSIX_VDISABLE, no character will have the
                                effect associated with that element.
   _POSIX_SYNC_IO               Synchronous I/O may be performed.
   _POSIX_ASYNC_IO              Asynchronous I/O may be performed.
   _POSIX_PRIO_IO               Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE             Low-level I/O supports large files.
   _LFS64_STDIO                 Standard I/O supports large files.
   */

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix_opt.h" 1
/* Define POSIX options for Linux.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */




/* Job control is supported.  */


/* Processes have a saved set-user-ID and a saved set-group-ID.  */


/* Priority scheduling is supported.  */


/* Synchronizing file data is supported.  */


/* The fsync function is present.  */


/* Mapping of files to memory is supported.  */


/* Locking of all memory is supported.  */


/* Locking of ranges of memory is supported.  */


/* Setting of memory protections is supported.  */


/* Some filesystems allow all users to change file ownership.  */


/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */


/* Filenames are not silently truncated.  */


/* X/Open realtime support is available.  */


/* X/Open thread realtime support is available.  */


/* XPG4.2 shared memory is supported.  */


/* Tell we have POSIX threads.  */


/* We have the reentrant functions described in POSIX.  */



/* We provide priority scheduling for threads.  */


/* We support user-defined stack sizes.  */


/* We support user-defined stacks.  */


/* We support priority inheritence.  */


/* We support priority protection, though only for non-robust
   mutexes.  */



/* We support priority inheritence for robust mutexes.  */


/* We do not support priority protection for robust mutexes.  */



/* We support POSIX.1b semaphores.  */


/* Real-time signals are supported.  */


/* We support asynchronous I/O.  */


/* Alternative name for Unix98.  */

/* Support for prioritization is also available.  */


/* The LFS support in asynchronous I/O is also available.  */


/* The rest of the LFS is also available.  */




/* POSIX shared memory objects are implemented.  */


/* CPU-time clocks support needs to be checked at runtime.  */


/* Clock support in threads must be also checked at runtime.  */


/* GNU libc provides regular expression handling.  */


/* Reader/Writer locks are available.  */


/* We have a POSIX shell.  */


/* We support the Timeouts option.  */


/* We support spinlocks.  */


/* The `spawn' function family is supported.  */


/* We have POSIX timers.  */


/* The barrier functions are available.  */


/* POSIX message queues are available.  */


/* Thread process-shared synchronization is supported.  */


/* The monotonic clock might be available.  */


/* The clock selection interfaces are available.  */


/* Advisory information interfaces are available.  */


/* IPv6 support is available.  */


/* Raw socket support is available.  */


/* We have at least one terminal.  */


/* Neither process nor thread sporadic server interfaces is available.  */



/* trace.h is not available.  */





/* Typed memory objects are not available.  */


# 206 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h" 2

/* Get the environment definitions from Unix98.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/environments.h" 1
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 23 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/environments.h" 2

/* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32    64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*/

# 66 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/environments.h"

/* We have 32-bit wide `int', `long int' and pointers and all platforms
   support LFS.  -mx32 has 64-bit wide `off_t'.  */





/* -m32 has 32-bit wide `off_t'.  */





/* We optionally provide an environment with the above size but an 64-bit
   side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  */

/* Environments with 64-bit wide pointers can be provided,
   so these macros aren't defined:
   # undef _POSIX_V7_LP64_OFF64
   # undef _POSIX_V7_LPBIG_OFFBIG
   # undef _POSIX_V6_LP64_OFF64
   # undef _POSIX_V6_LPBIG_OFFBIG
   # undef _XBS5_LP64_OFF64
   # undef _XBS5_LPBIG_OFFBIG
   and sysconf tests for it at runtime.  */



# 210 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h" 2


/* Standard file descriptors.  */





/* All functions that are not declared anywhere else.  */













/* The Single Unix specification says that some more types are
   available here.  */










# 256 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


typedef __useconds_t useconds_t;











typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;




/* Values for the second argument to access.
   These may be OR'd together.  */





/* Test for access to NAME using the real UID and real GID.  */
extern int access (const char *__name, int __type)  ;

# 302 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
       ;



/* Values for the WHENCE argument to lseek.  */
# 322 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Old BSD names for the same constants; just for compatibility.  */






/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */

extern __off_t lseek (int __fd, __off_t __offset, int __whence) ;
# 351 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int close (int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t write (int __fd, const void *__buf, size_t __n) ;



/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
                      __off_t __offset) ;

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
                       __off_t __offset) ;
# 402 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

# 415 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"

/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
extern int pipe (int __pipedes[2])  ;







/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
extern unsigned int alarm (unsigned int __seconds) ;

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern unsigned int sleep (unsigned int __seconds);



/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     ;

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int usleep (__useconds_t __useconds);



/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pause (void);


/* Change the owner and group of FILE.  */
extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
       ;


/* Change the owner and group of the file that FD is open on.  */
extern int fchown (int __fd, __uid_t __owner, __gid_t __group)  ;


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
       ;




/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
extern int fchownat (int __fd, const char *__file, __uid_t __owner,
                     __gid_t __group, int __flag)
       ;


/* Change the process's working directory to PATH.  */
extern int chdir (const char *__path)   ;


/* Change the process's working directory to the one FD is open on.  */
extern int fchdir (int __fd)  ;


/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
extern char *getcwd (char *__buf, size_t __size)  ;

# 522 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"



/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
extern char *getwd (char *__buf)
        ;



/* Duplicate FD, returning a new file descriptor on the same file.  */
extern int dup (int __fd)  ;

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
extern int dup2 (int __fd, int __fd2) ;







/* NULL-terminated array of "NAME=VALUE" environment variables.  */
extern char **__environ;





/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
extern int execve (const char *__path, char *const __argv[],
                   char *const __envp[])  ;


/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
      ;



/* Execute PATH with arguments ARGV and environment from `environ'.  */
extern int execv (const char *__path, char *const __argv[])
      ;

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
extern int execle (const char *__path, const char *__arg, ...)
      ;

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (const char *__path, const char *__arg, ...)
      ;

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvp (const char *__file, char *const __argv[])
      ;

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
extern int execlp (const char *__file, const char *__arg, ...)
      ;

# 597 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"



/* Add INC to priority of the current process.  */
extern int nice (int __inc)  ;



/* Terminate program execution with the low-order 8 bits of STATUS.  */
extern void _exit (int __status) ;


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/confname.h" 1
/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };

/* Values for the argument to `sysconf'.  */
enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,


    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,


    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,

    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };

/* Values for the NAME argument to `confstr'.  */
enum
  {
    _CS_PATH,                   /* The default search path.  */


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h" 2

/* Get file-specific configuration information about PATH.  */
extern long int pathconf (const char *__path, int __name)
      ;

/* Get file-specific configuration about descriptor FD.  */
extern long int fpathconf (int __fd, int __name) ;

/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) ;


/* Get the value of the string-valued system variable NAME.  */
extern size_t confstr (int __name, char *__buf, size_t __len) ;



/* Get the process ID of the calling process.  */
extern __pid_t getpid (void) ;

/* Get the process ID of the calling process's parent.  */
extern __pid_t getppid (void) ;

/* Get the process group ID of the calling process.  */
extern __pid_t getpgrp (void) ;

/* Get the process group ID of process PID.  */
extern __pid_t __getpgid (__pid_t __pid) ;

extern __pid_t getpgid (__pid_t __pid) ;



/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
extern int setpgid (__pid_t __pid, __pid_t __pgid) ;


/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   GNU provides the POSIX.1 function.  */

/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
extern int setpgrp (void) ;



/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
extern __pid_t setsid (void) ;


/* Return the session ID of the given process.  */
extern __pid_t getsid (__pid_t __pid) ;


/* Get the real user ID of the calling process.  */
extern __uid_t getuid (void) ;

/* Get the effective user ID of the calling process.  */
extern __uid_t geteuid (void) ;

/* Get the real group ID of the calling process.  */
extern __gid_t getgid (void) ;

/* Get the effective group ID of the calling process.  */
extern __gid_t getegid (void) ;

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
extern int getgroups (int __size, __gid_t __list[])  ;






/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
extern int setuid (__uid_t __uid)  ;


/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
extern int setreuid (__uid_t __ruid, __uid_t __euid)  ;



/* Set the effective user ID of the calling process to UID.  */
extern int seteuid (__uid_t __uid)  ;


/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
extern int setgid (__gid_t __gid)  ;


/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
extern int setregid (__gid_t __rgid, __gid_t __egid)  ;



/* Set the effective group ID of the calling process to GID.  */
extern int setegid (__gid_t __gid)  ;


# 754 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t fork (void) ;



/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t vfork (void) ;



/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
extern char *ttyname (int __fd) ;

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
       ;

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
extern int isatty (int __fd) ;


/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
extern int ttyslot (void) ;



/* Make a link to FROM named TO.  */
extern int link (const char *__from, const char *__to)
       ;


/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
extern int linkat (int __fromfd, const char *__from, int __tofd,
                   const char *__to, int __flags)
       ;



/* Make a symbolic link to FROM named TO.  */
extern int symlink (const char *__from, const char *__to)
       ;

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
extern ssize_t readlink (const char * __path,
                         char * __buf, size_t __len)
       ;



/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
extern int symlinkat (const char *__from, int __tofd,
                      const char *__to)   ;

/* Like readlink but a relative PATH is interpreted relative to FD.  */
extern ssize_t readlinkat (int __fd, const char * __path,
                           char * __buf, size_t __len)
       ;


/* Remove the link NAME.  */
extern int unlink (const char *__name)  ;


/* Remove the link NAME relative to FD.  */
extern int unlinkat (int __fd, const char *__name, int __flag)
      ;


/* Remove the directory PATH.  */
extern int rmdir (const char *__path)  ;


/* Return the foreground process group ID of FD.  */
extern __pid_t tcgetpgrp (int __fd) ;

/* Set the foreground process group ID of FD set PGRP_ID.  */
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) ;


/* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *getlogin (void);

/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getlogin_r (char *__name, size_t __name_len) ;



/* Set the login name returned by `getlogin'.  */
extern int setlogin (const char *__name)  ;




/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/getopt.h" 1
/* Declarations for getopt.
   Copyright (C) 1989-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */




# 46 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/getopt.h"





/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;

# 120 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/getopt.h"


/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       ;

# 171 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/getopt.h"

# 183 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/getopt.h"





/* Make sure we later can get all the definitions and declarations.  */


# 874 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h" 2




/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
extern int gethostname (char *__name, size_t __len)  ;




/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
extern int sethostname (const char *__name, size_t __len)
       ;

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
extern int sethostid (long int __id)  ;


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
extern int getdomainname (char *__name, size_t __len)
       ;
extern int setdomainname (const char *__name, size_t __len)
       ;


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
extern int vhangup (void) ;

/* Revoke the access of all descriptors currently open on FILE.  */
extern int revoke (const char *__file)   ;


/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
extern int profil (unsigned short int *__sample_buffer, size_t __size,
                   size_t __offset, unsigned int __scale)
      ;


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
extern int acct (const char *__name) ;


/* Successive calls return the shells listed in `/etc/shells'.  */
extern char *getusershell (void) ;
extern void endusershell (void) ; /* Discard cached info.  */
extern void setusershell (void) ; /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
extern int daemon (int __nochdir, int __noclose)  ;




/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
extern int chroot (const char *__path)   ;

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
extern char *getpass (const char *__prompt) ;



/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fsync (int __fd);











/* Return identifier for the current host.  */
extern long int gethostid (void);

/* Make all changes done to all files actually appear on disk.  */
extern void sync (void) ;



/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
extern int getpagesize (void)   ;


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
extern int getdtablesize (void) ;







/* Truncate FILE to LENGTH bytes.  */

extern int truncate (const char *__file, __off_t __length)
       ;
# 1010 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"






/* Truncate the file FD is open on to LENGTH bytes.  */

extern int ftruncate (int __fd, __off_t __length)  ;
# 1030 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"







/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
extern int brk (void *__addr)  ;

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
extern void *sbrk (intptr_t __delta) ;




/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
extern long int syscall (long int __sysno, ...) ;





/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  */







extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1096 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


# 1110 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Synchronize at least the data part of a file with the underlying
   media.  */
extern int fdatasync (int __fildes);



/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */
# 1138 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Prior to Issue 6, the Single Unix Specification required these
   prototypes to appear in this header.  They are also found in
   <stdio.h>.  */
# 1150 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/unistd.h"


/* Unix98 requires this function to be declared here.  In other
   standards it is in <pthread.h>.  */







/* Define some macros helping to catch buffer overflows.  */






# 15 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.21 String handling  <string.h>
 */








/* Get size_t and NULL from <stddef.h>.  */




/* Tell the caller that we provide correct C++ prototypes.  */






/* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void * __dest, const void * __src,
                     size_t __n)  ;
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, const void *__src, size_t __n)
      ;


/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */

extern void *memccpy (void * __dest, const void * __src,
                      int __c, size_t __n)
      ;




/* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n)  ;

/* Compare N bytes of S1 and S2.  */
extern int memcmp (const void *__s1, const void *__s2, size_t __n)
       ;

/* Search N bytes of S for C.  */
# 92 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern void *memchr (const void *__s, int __c, size_t __n)
        ;



# 121 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"



/* Copy SRC to DEST.  */
extern char *strcpy (char * __dest, const char * __src)
      ;
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char * __dest,
                      const char * __src, size_t __n)
      ;

/* Append SRC onto DEST.  */
extern char *strcat (char * __dest, const char * __src)
      ;
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char * __dest, const char * __src,
                      size_t __n)  ;

/* Compare S1 and S2.  */
extern int strcmp (const char *__s1, const char *__s2)
       ;
/* Compare N characters of S1 and S2.  */
extern int strncmp (const char *__s1, const char *__s2, size_t __n)
       ;

/* Compare the collated forms of S1 and S2.  */
extern int strcoll (const char *__s1, const char *__s2)
       ;
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm (char * __dest,
                       const char * __src, size_t __n)
      ;



/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/xlocale.h" 1
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;

# 160 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h" 2

/* Compare the collated forms of S1 and S2 using rules from L.  */
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
       ;
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
                         __locale_t __l)  ;



/* Duplicate S, returning an identical malloc'd string.  */
extern char *strdup (const char *__s)
       ;


/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */

extern char *strndup (const char *__string, size_t __n)
       ;


# 205 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"


/* Find the first occurrence of C in S.  */
# 231 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *strchr (const char *__s, int __c)
       ;

/* Find the last occurrence of C in S.  */
# 258 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *strrchr (const char *__s, int __c)
       ;



# 276 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"


/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
extern size_t strcspn (const char *__s, const char *__reject)
       ;
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
extern size_t strspn (const char *__s, const char *__accept)
       ;
/* Find the first occurrence in S of any character in ACCEPT.  */
# 310 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *strpbrk (const char *__s, const char *__accept)
       ;

/* Find the first occurrence of NEEDLE in HAYSTACK.  */
# 337 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *strstr (const char *__haystack, const char *__needle)
       ;



/* Divide S into tokens separated by characters in DELIM.  */
extern char *strtok (char * __s, const char * __delim)
      ;


/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
extern char *__strtok_r (char * __s,
                         const char * __delim,
                         char ** __save_ptr)
      ;

extern char *strtok_r (char * __s, const char * __delim,
                       char ** __save_ptr)
      ;


# 372 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"

# 390 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"



/* Return the length of S.  */
extern size_t strlen (const char *__s)
       ;



/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (const char *__string, size_t __maxlen)
       ;




/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) ;


/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */

/* Fill BUF with a string describing the meaning of the `errno' code in
   ERRNUM.  */





extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
      ;
# 437 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"


/* Translate error number to string according to the locale L.  */
extern char *strerror_l (int __errnum, __locale_t __l) ;



/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n)  ;


/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (const void *__src, void *__dest, size_t __n)
      ;

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n)  ;

/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
       ;

/* Find the first occurrence of C in S (same as strchr).  */
# 484 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *index (const char *__s, int __c)
       ;


/* Find the last occurrence of C in S (same as strrchr).  */
# 512 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"
extern char *rindex (const char *__s, int __c)
       ;


/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i)  ;

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */






/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (const char *__s1, const char *__s2)
       ;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
       ;


# 548 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"


/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
extern char *strsep (char ** __stringp,
                     const char * __delim)
      ;



/* Return a string describing the meaning of the signal number in SIG.  */
extern char *strsignal (int __sig) ;

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
extern char *__stpcpy (char * __dest, const char * __src)
      ;
extern char *stpcpy (char * __dest, const char * __src)
      ;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern char *__stpncpy (char * __dest,
                        const char * __src, size_t __n)
      ;
extern char *stpncpy (char * __dest,
                      const char * __src, size_t __n)
      ;


# 603 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"


# 638 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"

# 655 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/string.h"



# 16 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h" 1
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */








# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/uio.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */










/* This file defines `struct iovec'.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/uio.h" 1
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */











/* We should normally use the Linux kernel header file to define this
   type and macros but this calls for trouble because of the header
   includes other kernel headers.  */

/* Size of object which can be written atomically.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  */



/* Structure for scatter/gather I/O.  */
struct iovec
  {
    void *iov_base;     /* Pointer to data.  */
    size_t iov_len;     /* Length of data.  */
  };




# 29 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/uio.h" 2


/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;




/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
                       __off_t __offset) ;

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
                        __off_t __offset) ;
# 92 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/uio.h"

# 119 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/uio.h"



# 27 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h" 2
# 33 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"


/* This operating system-specific header file defines the SOCK_*, PF_*,
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h" 1
/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */













/* Type for length arguments in socket calls.  */





/* Get the architecture-dependent definition of enum __socket_type.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket_type.h" 1
/* Define enum __socket_type for generic Linux.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Types of sockets.  */
enum __socket_type
{
  SOCK_STREAM = 1,              /* Sequenced, reliable, connection-based
                                   byte streams.  */

  SOCK_DGRAM = 2,               /* Connectionless, unreliable datagrams
                                   of fixed maximum length.  */

  SOCK_RAW = 3,                 /* Raw protocol interface.  */

  SOCK_RDM = 4,                 /* Reliably-delivered messages.  */

  SOCK_SEQPACKET = 5,           /* Sequenced, reliable, connection-based,
                                   datagrams of fixed maximum length.  */

  SOCK_DCCP = 6,                /* Datagram Congestion Control Protocol.  */

  SOCK_PACKET = 10,             /* Linux specific way of getting packets
                                   at the dev level.  For writing rarp and
                                   other similar things on the user level. */


  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of paccept.  */

  SOCK_CLOEXEC = 02000000,      /* Atomically set close-on-exec flag for the
                                   new descriptor(s).  */

  SOCK_NONBLOCK = 00004000      /* Atomically mark descriptor(s) as
                                   non-blocking.  */

};
# 39 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h" 2

/* Protocol families.  */
# 87 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Address families.  */
# 135 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
# 162 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Maximum queue length specifiable by listen.  */


/* Get the definition of the macro to define the common sockaddr members.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sockaddr.h" 1
/* Definition of struct sockaddr_* common members and sizes, generic version.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */





/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */






/* Size of struct sockaddr_storage.  */


# 168 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h" 2

/* Structure describing a generic socket address.  */
struct sockaddr
  {
    sa_family_t sa_family;    /* Common data: address family and length.  */
    char sa_data[14];           /* Address data.  */
  };


/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */




struct sockaddr_storage
  {
    sa_family_t ss_family;    /* Address family, etc.  */
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;  /* Force desired alignment.  */
  };


/* Bits in the FLAGS argument to `send', `recv', et al.  */
enum
  {
    MSG_OOB             = 0x01, /* Process out-of-band data.  */

    MSG_PEEK            = 0x02, /* Peek at incoming messages.  */

    MSG_DONTROUTE       = 0x04, /* Don't use local routing.  */
# 205 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"
    MSG_CTRUNC          = 0x08, /* Control data lost before delivery.  */

    MSG_PROXY           = 0x10, /* Supply or ask second address.  */

    MSG_TRUNC           = 0x20,

    MSG_DONTWAIT        = 0x40, /* Nonblocking IO.  */

    MSG_EOR             = 0x80, /* End of record.  */

    MSG_WAITALL         = 0x100, /* Wait for a full request.  */

    MSG_FIN             = 0x200,

    MSG_SYN             = 0x400,

    MSG_CONFIRM         = 0x800, /* Confirm path validity.  */

    MSG_RST             = 0x1000,

    MSG_ERRQUEUE        = 0x2000, /* Fetch message from error queue.  */

    MSG_NOSIGNAL        = 0x4000, /* Do not generate SIGPIPE.  */

    MSG_MORE            = 0x8000,  /* Sender will send more.  */

    MSG_WAITFORONE      = 0x10000, /* Wait for at least one packet to return.*/

    MSG_BATCH           = 0x40000, /* sendmmsg: more messages coming.  */

    MSG_FASTOPEN        = 0x20000000, /* Send data in TCP SYN.  */


    MSG_CMSG_CLOEXEC    = 0x40000000    /* Set close_on_exit for file
                                           descriptor received through
                                           SCM_RIGHTS.  */

  };


/* Structure describing messages sent by
   `sendmsg' and received by `recvmsg'.  */
struct msghdr
  {
    void *msg_name;             /* Address to send to/receive from.  */
    socklen_t msg_namelen;      /* Length of address data.  */

    struct iovec *msg_iov;      /* Vector of data to send/receive into.  */
    size_t msg_iovlen;          /* Number of elements in the vector.  */

    void *msg_control;          /* Ancillary data (eg BSD filedesc passing). */
    size_t msg_controllen;      /* Ancillary data buffer length.
                                   !! The type should be socklen_t but the
                                   definition of the kernel is incompatible
                                   with this.  */

    int msg_flags;              /* Flags on received message.  */
  };

/* Structure used for storage of ancillary data object information.  */
struct cmsghdr
  {
    size_t cmsg_len;            /* Length of data in cmsg_data plus length
                                   of cmsghdr structure.
                                   !! The type should be socklen_t but the
                                   definition of the kernel is incompatible
                                   with this.  */
    int cmsg_level;             /* Originating protocol.  */
    int cmsg_type;              /* Protocol specific type.  */



  };

/* Ancillary data object manipulation macros.  */
# 294 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
                                      struct cmsghdr *__cmsg) ;
# 319 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
enum
  {
    SCM_RIGHTS = 0x01           /* Transfer file descriptors.  */





  };

# 341 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Ugly workaround for unclean kernel headers.  */
# 366 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Get socket manipulation related informations from kernel headers.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/asm/socket.h" 1
/* Copyright 2012 The MathWorks, Inc. */






# 22 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/asm/socket.h"

# 29 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/asm/socket.h"










# 369 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h" 2

# 400 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/socket.h"

/* Structure used to manipulate the SO_LINGER option.  */
struct linger
  {
    int l_onoff;                /* Nonzero to linger on close.  */
    int l_linger;               /* Time to linger.  */
  };

# 39 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h" 2


/* This is the 4.3 BSD `struct sockaddr' format, which is used as wire
   format in the grotty old 4.3 `talk' protocol.  */
struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };


/* The following constants should be used for the second parameter of
   `shutdown'.  */
enum
{
  SHUT_RD = 0,          /* No more receptions.  */

  SHUT_WR,              /* No more transmissions.  */

  SHUT_RDWR             /* No more receptions or transmissions.  */

};

/* This is the type we use for generic socket address arguments.

   With GCC 2.7 and later, the funky union causes redeclarations or
   uses with any of the listed types to be allowed without complaint.
   G++ 2.7 does not support transparent unions so there we want the
   old-style declaration, too.  */
# 98 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"

# 108 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"


/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) ;

/* Create two new sockets, of type TYPE in domain DOMAIN and using
   protocol PROTOCOL, which are connected to each other, and put file
   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
extern int socketpair (int __domain, int __type, int __protocol,
                       int __fds[2]) ;

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     ;

/* Put the local address of FD into *ADDR and its length in *LEN.  */
extern int getsockname (int __fd, struct sockaddr * __addr,
                        socklen_t * __len) ;

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);

/* Put the address of the peer connected to socket FD into *ADDR
   (which is *LEN bytes long), and its actual length into *LEN.  */
extern int getpeername (int __fd, struct sockaddr * __addr,
                        socklen_t * __len) ;


/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);

/* Read N bytes into BUF from socket FD.
   Returns the number read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);

/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
                       int __flags, const struct sockaddr * __addr,
                       socklen_t __addr_len);

/* Read N bytes into BUF through socket FD.
   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
   the sender, and store the actual size of the address in *ADDR_LEN.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvfrom (int __fd, void * __buf, size_t __n,
                         int __flags, struct sockaddr * __addr,
                         socklen_t * __addr_len);


/* Send a message described MESSAGE on socket FD.
   Returns the number of bytes sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
                        int __flags);

# 196 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"

/* Receive a message as described by MESSAGE from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);

# 214 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"


/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
   actual length.  Returns 0 on success, -1 for errors.  */
extern int getsockopt (int __fd, int __level, int __optname,
                       void * __optval,
                       socklen_t * __optlen) ;

/* Set socket FD's option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
extern int setsockopt (int __fd, int __level, int __optname,
                       const void *__optval, socklen_t __optlen) ;


/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
extern int listen (int __fd, int __n) ;

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept (int __fd, struct sockaddr * __addr,
                   socklen_t * __addr_len);

# 254 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/socket.h"

/* Shut down all or part of the connection open on socket FD.
   HOW determines what to shut down:
     SHUT_RD   = No more receptions;
     SHUT_WR   = No more transmissions;
     SHUT_RDWR = No more receptions or transmissions.
   Returns 0 on success, -1 for errors.  */
extern int shutdown (int __fd, int __how) ;



/* Determine wheter socket is at a out-of-band mark.  */
extern int sockatmark (int __fd) ;




/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
   returns 1 if FD is open on an object of the indicated type, 0 if not,
   or -1 for errors (setting errno).  */
extern int isfdtype (int __fd, int __fdtype) ;



/* Define some macros helping to catch buffer overflows.  */






# 17 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/inet.h" 1
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h" 1
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99: 7.18 Integer types <stdint.h>
 */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wchar.h" 1
/* wchar_t type related definitions.
   Copyright (C) 2000-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
   are not defined, give the right value and type as long as both int
   and wchar_t are 32-bit types.  Adding L'\0' to a constant value
   ensures that the type is correct; it is necessary to use (L'\0' +
   0) rather than just L'\0' so that the type in C++ is the promoted
   version of wchar_t rather than the distinct wchar_t type itself.
   Because wchar_t in preprocessor #if expressions is treated as
   intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
   wrong value for WCHAR_MAX in such expressions and so cannot be used
   to define __WCHAR_MAX in the unsigned case.  */

# 40 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wchar.h"

# 48 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wchar.h"

# 27 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 28 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h" 2

/* Exact integral types.  */

/* Signed.  */

/* There is some amount of overlap with <sys/types.h> as known by inet code */
# 46 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Unsigned.  */
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;

typedef unsigned int            uint32_t;






typedef unsigned long long int  uint64_t;



/* Small types.  */

/* Signed.  */
typedef signed char             int_least8_t;
typedef short int               int_least16_t;
typedef int                     int_least32_t;




typedef long long int           int_least64_t;


/* Unsigned.  */
typedef unsigned char           uint_least8_t;
typedef unsigned short int      uint_least16_t;
typedef unsigned int            uint_least32_t;




typedef unsigned long long int  uint_least64_t;



/* Fast types.  */

/* Signed.  */
typedef signed char             int_fast8_t;





typedef int                     int_fast16_t;
typedef int                     int_fast32_t;

typedef long long int           int_fast64_t;


/* Unsigned.  */
typedef unsigned char           uint_fast8_t;





typedef unsigned int            uint_fast16_t;
typedef unsigned int            uint_fast32_t;

typedef unsigned long long int  uint_fast64_t;



/* Types for `void *' pointers.  */
# 128 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"
typedef unsigned int            uintptr_t;



/* Largest integral types.  */





typedef long long int           intmax_t;

typedef unsigned long long int  uintmax_t;



# 151 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Limits of integral types.  */

/* Minimum of signed integral types.  */




/* Maximum of signed integral types.  */





/* Maximum of unsigned integral types.  */






/* Minimum of signed integral types having a minimum size.  */




/* Maximum of signed integral types having a minimum size.  */





/* Maximum of unsigned integral types having a minimum size.  */






/* Minimum of fast signed integral types having a minimum size.  */
# 200 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"
/* Maximum of fast signed integral types having a minimum size.  */
# 210 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Maximum of fast unsigned integral types having a minimum size.  */
# 221 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"


/* Values to test for integral types holding `void *' pointer.  */
# 233 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"


/* Minimum for largest signed integral type.  */

/* Maximum for largest signed integral type.  */


/* Maximum for largest unsigned integral type.  */



/* Limits of other integer types.  */

/* Limits of `ptrdiff_t' type.  */
# 254 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Limits of `sig_atomic_t'.  */



/* Limit of `size_t' type.  */
# 269 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Limits of `wchar_t'.  */

/* These constants might also be defined in <wchar.h>.  */




/* Limits of `wint_t'.  */



/* Signed.  */
# 290 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Unsigned.  */
# 300 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

/* Maximal type.  */
# 309 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/stdint.h"

# 23 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h" 2






/* Internet address.  */
typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };

/* Get system-specific definitions.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* Linux version.  */





/* If the application has already included linux/in6.h from a linux-based
   kernel then we will not define the IPv6 IPPROTO_* defines, in6_addr (nor the
   defines), sockaddr_in6, or ipv6_mreq. Same for in6_ptkinfo or ip6_mtuinfo
   in linux/ipv6.h. The ABI used by the linux-kernel and glibc match exactly.
   Neither the linux kernel nor glibc should break this ABI without coordination.
   In upstream kernel 56c176c9 the _UAPI prefix was stripped so we need to check
   for _LINUX_IN6_H and _IPV6_H now, and keep checking the old versions for
   maximum backwards compatibility.  */
# 43 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* Options for use with `getsockopt' and `setsockopt' at the IP level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */





/* For BSD compatibility.  */
# 75 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"





# 95 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* TProxy original addresses */








/* IP_MTU_DISCOVER arguments.  */




/* Always use interface mtu (ignores dst pmtu) but don't set DF flag.
   Also incoming ICMP frag_needed notifications will be ignored on
   this socket to prevent accepting spoofed ones.  */

/* Like IP_PMTUDISC_INTERFACE but allow packets to be fragmented.  */


# 129 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* To select the IP level.  */







/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
   The `ip_dst' field is used for the first-hop gateway when using a
   source route (this gets put into the header proper).  */
struct ip_opts
  {
    struct in_addr ip_dst;      /* First hop; zero without source route.  */
    char ip_opts[40];           /* Actually variable in size.  */
  };

/* Like `struct ip_mreq' but including interface specification by index.  */
struct ip_mreqn
  {
    struct in_addr imr_multiaddr;       /* IP multicast address of group */
    struct in_addr imr_address;         /* local IP address of interface */
    int imr_ifindex;                    /* Interface index */
  };

/* Structure used for IP_PKTINFO.  */
struct in_pktinfo
  {
    int ipi_ifindex;                    /* Interface index  */
    struct in_addr ipi_spec_dst;        /* Routing destination address  */
    struct in_addr ipi_addr;            /* Header destination address  */
  };


/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
# 175 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"



# 196 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* Advanced API (RFC3542) (1).  */
# 212 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* Advanced API (RFC3542) (2).  */



/* Obsolete synonyms for the above.  */
# 224 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* IPV6_MTU_DISCOVER values.  */
# 232 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/in.h"

/* Socket level values for IPv6.  */



/* Routing header options for IPv6.  */



# 38 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h" 2

/* Standard well-defined IP protocols.  */
enum
  {
    IPPROTO_IP = 0,        /* Dummy protocol for TCP.  */

    IPPROTO_ICMP = 1,      /* Internet Control Message Protocol.  */

    IPPROTO_IGMP = 2,      /* Internet Group Management Protocol. */

    IPPROTO_IPIP = 4,      /* IPIP tunnels (older KA9Q tunnels use 94).  */

    IPPROTO_TCP = 6,       /* Transmission Control Protocol.  */

    IPPROTO_EGP = 8,       /* Exterior Gateway Protocol.  */

    IPPROTO_PUP = 12,      /* PUP protocol.  */

    IPPROTO_UDP = 17,      /* User Datagram Protocol.  */

    IPPROTO_IDP = 22,      /* XNS IDP protocol.  */

    IPPROTO_TP = 29,       /* SO Transport Protocol Class 4.  */

    IPPROTO_DCCP = 33,     /* Datagram Congestion Control Protocol.  */

    IPPROTO_IPV6 = 41,     /* IPv6 header.  */

    IPPROTO_RSVP = 46,     /* Reservation Protocol.  */

    IPPROTO_GRE = 47,      /* General Routing Encapsulation.  */

    IPPROTO_ESP = 50,      /* encapsulating security payload.  */

    IPPROTO_AH = 51,       /* authentication header.  */

    IPPROTO_MTP = 92,      /* Multicast Transport Protocol.  */

    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */

    IPPROTO_ENCAP = 98,    /* Encapsulation Header.  */

    IPPROTO_PIM = 103,     /* Protocol Independent Multicast.  */

    IPPROTO_COMP = 108,    /* Compression Header Protocol.  */

    IPPROTO_SCTP = 132,    /* Stream Control Transmission Protocol.  */

    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */

    IPPROTO_MPLS = 137,    /* MPLS in IP.  */

    IPPROTO_RAW = 255,     /* Raw IP packets.  */

    IPPROTO_MAX
  };

/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
   network headers first and we should use those ABI-identical definitions
   instead of our own, otherwise 0.  */

enum
  {
    IPPROTO_HOPOPTS = 0,   /* IPv6 Hop-by-Hop options.  */

    IPPROTO_ROUTING = 43,  /* IPv6 routing header.  */

    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */

    IPPROTO_ICMPV6 = 58,   /* ICMPv6.  */

    IPPROTO_NONE = 59,     /* IPv6 no next header.  */

    IPPROTO_DSTOPTS = 60,  /* IPv6 destination options.  */

    IPPROTO_MH = 135       /* IPv6 mobility header.  */

  };


/* Type to represent a port.  */
typedef uint16_t in_port_t;

/* Standard well-known ports.  */
enum
  {
    IPPORT_ECHO = 7,            /* Echo service.  */
    IPPORT_DISCARD = 9,         /* Discard transmissions service.  */
    IPPORT_SYSTAT = 11,         /* System status service.  */
    IPPORT_DAYTIME = 13,        /* Time of day service.  */
    IPPORT_NETSTAT = 15,        /* Network status service.  */
    IPPORT_FTP = 21,            /* File Transfer Protocol.  */
    IPPORT_TELNET = 23,         /* Telnet protocol.  */
    IPPORT_SMTP = 25,           /* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37,     /* Timeserver service.  */
    IPPORT_NAMESERVER = 42,     /* Domain Name Service.  */
    IPPORT_WHOIS = 43,          /* Internet Whois service.  */
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,           /* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,         /* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,         /* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512,    /* execd service.  */
    IPPORT_LOGINSERVER = 513,   /* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,

    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000
  };

/* Definitions of the bits in an Internet address integer.

   On subnets, host and network parts are found according to
   the subnet mask, not these masks.  */
























/* Address to accept any incoming messages.  */

/* Address to send to all hosts.  */

/* Address indicating an error return.  */


/* Network number for local host loopback.  */

/* Address to loopback in software to local host.  */




/* Defines for Multicast INADDR.  */






/* IPv6 address */
struct in6_addr
  {
    union
      {
        uint8_t __u6_addr8[16];

        uint16_t __u6_addr16[8];
        uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;        /* :: */
extern const struct in6_addr in6addr_loopback;   /* ::1 */







/* Structure describing an Internet socket address.  */
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;                 /* Port number.  */
    struct in_addr sin_addr;            /* Internet address.  */

    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
                           (sizeof (unsigned short int)) -
                           sizeof (in_port_t) -
                           sizeof (struct in_addr)];
  };


/* Ditto, for IPv6.  */
struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;        /* Transport layer port # */
    uint32_t sin6_flowinfo;     /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
    uint32_t sin6_scope_id;     /* IPv6 scope-id */
  };



/* IPv4 multicast request.  */
struct ip_mreq
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* IP address of source.  */
    struct in_addr imr_interface;

    /* IP address of interface.  */
    struct in_addr imr_sourceaddr;
  };



/* Likewise, for IPv6.  */
struct ipv6_mreq
  {
    /* IPv6 multicast address of group */
    struct in6_addr ipv6mr_multiaddr;

    /* local interface */
    unsigned int ipv6mr_interface;
  };



/* Multicast group request.  */
struct group_req
  {
    /* Interface index.  */
    uint32_t gr_interface;

    /* Group address.  */
    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {
    /* Interface index.  */
    uint32_t gsr_interface;

    /* Group address.  */
    struct sockaddr_storage gsr_group;

    /* Source address.  */
    struct sockaddr_storage gsr_source;
  };


/* Full-state filter operations.  */
struct ip_msfilter
  {
    /* IP multicast address of group.  */
    struct in_addr imsf_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imsf_interface;

    /* Filter mode.  */
    uint32_t imsf_fmode;

    /* Number of source addresses.  */
    uint32_t imsf_numsrc;
    /* Source addresses.  */
    struct in_addr imsf_slist[1];
  };





struct group_filter
  {
    /* Interface index.  */
    uint32_t gf_interface;

    /* Group address.  */
    struct sockaddr_storage gf_group;

    /* Filter mode.  */
    uint32_t gf_fmode;

    /* Number of source addresses.  */
    uint32_t gf_numsrc;
    /* Source addresses.  */
    struct sockaddr_storage gf_slist[1];
};







/* Functions to convert between host and network byte order.

   Please note that these functions normally take `unsigned long int' or
   `unsigned short int' values as arguments and also return them.  But
   this was a short-sighted decision since on different systems the types
   may have different representations but the values are always the same.  */

extern uint32_t ntohl (uint32_t __netlong)  ;
extern uint16_t ntohs (uint16_t __netshort)
      ;
extern uint32_t htonl (uint32_t __hostlong)
      ;
extern uint16_t htons (uint16_t __hostshort)
      ;



/* Get machine dependent optimized versions of byte swapping functions.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/byteswap.h" 1
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 388 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h" 2

/* Polyspace: __align is a keyword for tasking dialect */





# 415 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h"

# 472 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h"


























# 504 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h"




/* Bind socket to a privileged IP port.  */
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) ;

/* The IPv6 version of this function.  */
extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     ;
























# 636 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netinet/in.h"



/* Polyspace */
# 23 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/inet.h" 2

/* Type for length arguments in socket calls.  */







/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data in network byte order.  */
extern in_addr_t inet_addr (const char *__cp) ;

/* Return the local host address part of the Internet address in IN.  */
extern in_addr_t inet_lnaof (struct in_addr __in) ;

/* Make Internet host address in network byte order by combining the
   network number NET with the local address HOST.  */
extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     ;

/* Return network number part of the Internet address IN.  */
extern in_addr_t inet_netof (struct in_addr __in) ;

/* Extract the network number in network byte order from the address
   in numbers-and-dots natation starting at CP.  */
extern in_addr_t inet_network (const char *__cp) ;

/* Convert Internet number in IN to ASCII representation.  The return value
   is a pointer to an internal array containing the string.  */
extern char *inet_ntoa (struct in_addr __in) ;

/* Convert from presentation format of an Internet number in buffer
   starting at CP to the binary network format and store result for
   interface type AF in buffer starting at BUF.  */
extern int inet_pton (int __af, const char * __cp,
                      void * __buf) ;

/* Convert a Internet address in binary network format for interface
   type AF in buffer starting at CP to presentation form and place
   result in buffer of length LEN astarting at BUF.  */
extern const char *inet_ntop (int __af, const void * __cp,
                              char * __buf, socklen_t __len)
     ;


/* The following functions are not part of XNS 5.2.  */

/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data and store the result in the structure INP.  */
extern int inet_aton (const char *__cp, struct in_addr *__inp) ;

/* Format a network number NET into presentation format and place result
   in buffer starting at BUF with length of LEN bytes.  */
extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) ;

/* Convert network number for interface type AF in buffer starting at
   CP to presentation format.  The result will specifiy BITS bits of
   the number.  */
extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
                            char *__buf, size_t __len) ;

/* Convert network number for interface type AF from presentation in
   buffer starting at CP to network format and store result int
   buffer starting at BUF of size LEN.  */
extern int inet_net_pton (int __af, const char *__cp,
                          void *__buf, size_t __len) ;

/* Convert ASCII representation in hexadecimal form of the Internet
   address to binary form and place result in buffer of length LEN
   starting at BUF.  */
extern unsigned int inet_nsap_addr (const char *__cp,
                                    unsigned char *__buf, int __len) ;

/* Convert internet address in binary form in LEN bytes starting at CP
   a presentation form and place result in BUF.  */
extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
                             char *__buf) ;




# 18 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h" 1
  /* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* All data returned by the network data base library are supplied in
   host order and returned in network order (suitable for use in
   system calls).  */









/* This is necessary to make this include file properly replace the
   Sun version.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/rpc/netdb.h" 1
/* @(#)netdb.h  2.1 88/07/29 3.9 RPCSRC */
/*
 * Copyright (c) 2010, Oracle America, Inc.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Cleaned up for GNU C library roland@gnu.ai.mit.edu:
   added multiple inclusion protection and use of <sys/cdefs.h>.
   In GNU this file is #include'd by <netdb.h>.  */











struct rpcent
{
  char *r_name;         /* Name of server for this rpc program.  */
  char **r_aliases;     /* Alias list.  */
  int r_number;         /* RPC program number.  */
};

extern void setrpcent (int __stayopen) ;
extern void endrpcent (void) ;
extern struct rpcent *getrpcbyname (const char *__name) ;
extern struct rpcent *getrpcbynumber (int __number) ;
extern struct rpcent *getrpcent (void) ;


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
                           char *__buffer, size_t __buflen,
                           struct rpcent **__result) ;

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
                             char *__buffer, size_t __buflen,
                             struct rpcent **__result) ;

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
                        size_t __buflen, struct rpcent **__result) ;




# 33 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h" 2


# 41 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/netdb.h" 1
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Description of data base entry for a single network.  NOTE: here a
   poor assumption is made.  The network number is expected to fit
   into an unsigned long int variable.  */
struct netent
{
  char *n_name;                 /* Official name of network.  */
  char **n_aliases;             /* Alias list.  */
  int n_addrtype;               /* Net address type.  */
  uint32_t n_net;               /* Network number.  */
};
# 43 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h" 2

/* Absolute file name for network data base files.  */
# 51 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"





/* Error status for non-reentrant lookup functions.
   We use a macro to access always the thread-specific `h_errno' variable.  */


/* Function to get address of global `h_errno' variable.  */
extern int *__h_errno_location (void)  ;


/* Possible values left in `h_errno'.  */
# 78 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"


/* Highest reserved Internet port number.  */









/* Print error indicated by `h_errno' variable on standard error.  STR
   if non-null is printed before the error string.  */
extern void herror (const char *__str) ;

/* Return string associated with error ERR_NUM.  */
extern const char *hstrerror (int __err_num) ;



/* Description of data base entry for a single host.  */
struct hostent
{
  char *h_name;                 /* Official name of host.  */
  char **h_aliases;             /* Alias list.  */
  int h_addrtype;               /* Host address type.  */
  int h_length;                 /* Length of address.  */
  char **h_addr_list;           /* List of addresses from name server.  */



};

/* Open host data base files and mark them as staying open even after
   a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void sethostent (int __stay_open);

/* Close host data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endhostent (void);

/* Get next entry from host data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostent (void);

/* Return entry from host data base which address match ADDR with
   length LEN and type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
                                      int __type);

/* Return entry from host data base for host with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyname (const char *__name);


/* Return entry from host data base for host with NAME.  AF must be
   set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
   for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct hostent *gethostbyname2 (const char *__name, int __af);

/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int gethostent_r (struct hostent * __result_buf,
                         char * __buf, size_t __buflen,
                         struct hostent ** __result,
                         int * __h_errnop);

extern int gethostbyaddr_r (const void * __addr, __socklen_t __len,
                            int __type,
                            struct hostent * __result_buf,
                            char * __buf, size_t __buflen,
                            struct hostent ** __result,
                            int * __h_errnop);

extern int gethostbyname_r (const char * __name,
                            struct hostent * __result_buf,
                            char * __buf, size_t __buflen,
                            struct hostent ** __result,
                            int * __h_errnop);

extern int gethostbyname2_r (const char * __name, int __af,
                             struct hostent * __result_buf,
                             char * __buf, size_t __buflen,
                             struct hostent ** __result,
                             int * __h_errnop);



/* Open network data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setnetent (int __stay_open);

/* Close network data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endnetent (void);

/* Get next entry from network data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetent (void);

/* Return entry from network data base which address match NET and
   type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyaddr (uint32_t __net, int __type);

/* Return entry from network data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyname (const char *__name);


/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getnetent_r (struct netent * __result_buf,
                        char * __buf, size_t __buflen,
                        struct netent ** __result,
                        int * __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
                           struct netent * __result_buf,
                           char * __buf, size_t __buflen,
                           struct netent ** __result,
                           int * __h_errnop);

extern int getnetbyname_r (const char * __name,
                           struct netent * __result_buf,
                           char * __buf, size_t __buflen,
                           struct netent ** __result,
                           int * __h_errnop);



/* Description of data base entry for a single service.  */
struct servent
{
  char *s_name;                 /* Official service name.  */
  char **s_aliases;             /* Alias list.  */
  int s_port;                   /* Port number.  */
  char *s_proto;                /* Protocol to use.  */
};

/* Open service data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setservent (int __stay_open);

/* Close service data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endservent (void);

/* Get next entry from service data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservent (void);

/* Return entry from network data base for network with NAME and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyname (const char *__name, const char *__proto);

/* Return entry from service data base which matches port PORT and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyport (int __port, const char *__proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getservent_r (struct servent * __result_buf,
                         char * __buf, size_t __buflen,
                         struct servent ** __result);

extern int getservbyname_r (const char * __name,
                            const char * __proto,
                            struct servent * __result_buf,
                            char * __buf, size_t __buflen,
                            struct servent ** __result);

extern int getservbyport_r (int __port, const char * __proto,
                            struct servent * __result_buf,
                            char * __buf, size_t __buflen,
                            struct servent ** __result);



/* Description of data base entry for a single service.  */
struct protoent
{
  char *p_name;                 /* Official protocol name.  */
  char **p_aliases;             /* Alias list.  */
  int p_proto;                  /* Protocol number.  */
};

/* Open protocol data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setprotoent (int __stay_open);

/* Close protocol data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endprotoent (void);

/* Get next entry from protocol data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotoent (void);

/* Return entry from protocol data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobyname (const char *__name);

/* Return entry from protocol data base which number is PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobynumber (int __proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getprotoent_r (struct protoent * __result_buf,
                          char * __buf, size_t __buflen,
                          struct protoent ** __result);

extern int getprotobyname_r (const char * __name,
                             struct protoent * __result_buf,
                             char * __buf, size_t __buflen,
                             struct protoent ** __result);

extern int getprotobynumber_r (int __proto,
                               struct protoent * __result_buf,
                               char * __buf, size_t __buflen,
                               struct protoent ** __result);


/* Establish network group NETGROUP for enumeration.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int setnetgrent (const char *__netgroup);

/* Free all space allocated by previous `setnetgrent' call.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern void endnetgrent (void);

/* Get next member of netgroup established by last `setnetgrent' call
   and return pointers to elements in HOSTP, USERP, and DOMAINP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent (char ** __hostp,
                        char ** __userp,
                        char ** __domainp);


/* Test whether NETGROUP contains the triple (HOST,USER,DOMAIN).

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int innetgr (const char *__netgroup, const char *__host,
                    const char *__user, const char *__domain);

/* Reentrant version of `getnetgrent' where result is placed in BUFFER.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent_r (char ** __hostp,
                          char ** __userp,
                          char ** __domainp,
                          char * __buffer, size_t __buflen);




/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
   The local user is LOCUSER, on the remote machine the command is
   executed as REMUSER.  In *FD2P the descriptor to the socket for the
   connection is returned.  The caller must have the right to use a
   reserved port.  When the function returns *AHOST contains the
   official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd (char ** __ahost, unsigned short int __rport,
                 const char * __locuser,
                 const char * __remuser,
                 const char * __cmd, int * __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd_af (char ** __ahost, unsigned short int __rport,
                    const char * __locuser,
                    const char * __remuser,
                    const char * __cmd, int * __fd2p,
                    sa_family_t __af);

/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
   CMD.  The process runs at the remote machine using the ID of user
   NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
   to the socket for the connection is returned.  When the function
   returns *AHOST contains the official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec (char ** __ahost, int __rport,
                  const char * __name,
                  const char * __pass,
                  const char * __cmd, int * __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec_af (char ** __ahost, int __rport,
                     const char * __name,
                     const char * __pass,
                     const char * __cmd, int * __fd2p,
                     sa_family_t __af);

/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
   If SUSER is not zero the user tries to become superuser.  Return 0 if
   it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok (const char *__rhost, int __suser,
                    const char *__remuser, const char *__locuser);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok_af (const char *__rhost, int __suser,
                       const char *__remuser, const char *__locuser,
                       sa_family_t __af);

/* Check whether user REMUSER on system indicated by IPv4 address
   RADDR is allowed to login as LOCUSER.  Non-IPv4 (e.g., IPv6) are
   not supported.  If SUSER is not zero the user tries to become
   superuser.  Return 0 if it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok (uint32_t __raddr, int __suser,
                     const char *__remuser, const char *__locuser);

/* This is the equivalent function where the pfamiliy if the address
   pointed to by RADDR is determined by the value of AF.  It therefore
   can be used for IPv6

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok_af (const void *__raddr, int __suser,
                        const char *__remuser, const char *__locuser,
                        sa_family_t __af);

/* Try to allocate reserved port, returning a descriptor for a socket opened
   at this port or -1 if unsuccessful.  The search for an available port
   will start at ALPORT and continues with lower numbers.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport (int *__alport);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport_af (int *__alport, sa_family_t __af);



/* Extension from POSIX.1:2001.  */

/* Structure to contain information about address of a service provider.  */
struct addrinfo
{
  int ai_flags;                 /* Input flags.  */
  int ai_family;                /* Protocol family for socket.  */
  int ai_socktype;              /* Socket type.  */
  int ai_protocol;              /* Protocol for socket.  */
  socklen_t ai_addrlen;         /* Length of socket address.  */
  struct sockaddr *ai_addr;     /* Socket address for socket.  */
  char *ai_canonname;           /* Canonical name for service location.  */
  struct addrinfo *ai_next;     /* Pointer to next in list.  */
};

# 596 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"

/* Possible values for `ai_flags' field in `addrinfo' structure.  */
# 616 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"

/* Error values for `getaddrinfo' function.  */
# 638 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"






# 656 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"

/* Translate name of a service location and/or a service name to set of
   socket addresses.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getaddrinfo (const char * __name,
                        const char * __service,
                        const struct addrinfo * __req,
                        struct addrinfo ** __pai);

/* Free `addrinfo' structure AI including associated storage.  */
extern void freeaddrinfo (struct addrinfo *__ai) ;

/* Convert error return from getaddrinfo() to a string.  */
extern const char *gai_strerror (int __ecode) ;

/* Translate a socket address to a location and service name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getnameinfo (const struct sockaddr * __sa,
                        socklen_t __salen, char * __host,
                        socklen_t __hostlen, char * __serv,
                        socklen_t __servlen, int __flags);


# 712 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/netdb.h"



# 20 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h" 1
/*
 * Copyright (c) 1983, 1987, 1989
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Portions Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *      @(#)resolv.h    8.1 (Berkeley) 6/2/93
 *      $BINDId: resolv.h,v 8.31 2000/03/30 20:16:50 vixie Exp $
 */



/* These headers are needed for types used in the `struct res_state'
   declaration.  */






# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h" 1
/* Compatibility header for old-style Unix parameters and limits.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types <limits.h>
 */







/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */



/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
/* Polyspace: [2011-08-17] We don't have another limits.h file */
/*#if !defined __GNUC__ || __GNUC__ < 2*/

/* We only protect from multiple inclusion here, because all the other
   #include's protect themselves, and in GCC 2 we may #include_next through
   multiple copies of this file before we get to GCC's.  */



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 46 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h" 2

/* We don't have #include_next.
   Define ANSI <limits.h> for standard 32-bit words.  */

/* These assume 8-bit `char's, 16-bit `short int's,
   and 32-bit `int's and `long int's.  */

/* Number of bits in a `char'.  */
/* Polyspace: [2011-08-23] Use the same builtin names than 'gcc'. */


/* Minimum and maximum values a `signed char' can hold.  */



/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */






/* Minimum and maximum values a `char' can hold.  */
# 80 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h"

/* Minimum and maximum values a `signed short int' can hold.  */



/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */






/* Minimum and maximum values a `signed int' can hold.  */



/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */


/* Minimum and maximum values a `signed long int' can hold.  */



/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */


/* Polyspace: [2012-02-21] The front-end defines __NO_LONG_LONG when 'long long' is disabled. */


/* Minimum and maximum values a `signed long long int' can hold.  */



/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */





/*#endif        / * GCC 2.  */



 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */
/*#if defined __GNUC__ && !defined _GCC_LIMITS_H_*/
/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
/*# include_next <limits.h>*/
/*#endif*/







/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */
# 153 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h"


/* POSIX adds things to <limits.h>.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix1_lim.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      POSIX Standard: 2.9.2 Minimum Values    Added to <limits.h>
 *
 *      Never include this file directly; use <limits.h> instead.
 */





/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */


/* Minimal number of outstanding asynchronous I/O operations.  */


/* Maximum length of arguments to `execve', including environment.  */


/* Maximum simultaneous processes per real user ID.  */






/* Minimal number of timer expiration overruns.  */


/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */


/* Maximum link count of a file.  */


/* Maximum length of login name.  */


/* Number of bytes in a terminal canonical input queue.  */


/* Number of bytes for which space will be
   available in a terminal input queue.  */


/* Maximum number of message queues open for a process.  */


/* Maximum number of supported message priorities.  */


/* Number of bytes in a filename.  */


/* Number of simultaneous supplementary group IDs per process.  */






/* Number of files one process can have open at once.  */












/* Number of bytes in a pathname.  */


/* Number of bytes than can be written atomically to a pipe.  */


/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */


/* Minimal number of realtime signals reserved for the application.  */


/* Number of semaphores a process can have.  */


/* Maximal value of a semaphore.  */


/* Number of pending realtime signals.  */


/* Largest value of a `ssize_t'.  */


/* Number of streams a process can have open at once.  */


/* The number of bytes in a symbolic link.  */


/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */


/* Number of timer for a process.  */


/* Maximum number of characters in a tty name.  */


/* Maximum length of a timezone name (element of `tzname').  */






# 154 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix1_lim.h"

/* Maximum clock resolution in nanoseconds.  */



/* Get the implementation-specific values for the above.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/local_lim.h" 1
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */
# 36 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/local_lim.h"

/* The kernel sources contain a file with all the needed information.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/limits.h" 1
/* Copyright 2012 The MathWorks, Inc. */






# 18 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/limits.h"



# 39 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/local_lim.h" 2

/* Have to remove NR_OPEN?  */




/* Have to remove LINK_MAX?  */




/* Have to remove OPEN_MAX?  */




/* Have to remove ARG_MAX?  */





/* The number of data keys per process.  */

/* This is the value this implementation supports.  */


/* Controlling the iterations of destructors for thread-specific data.  */

/* Number of iterations this implementation does.  */


/* The number of threads per process.  */

/* We have no predefined limit on the number of threads.  */


/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */


/* Minimum size for a thread.  We are free to choose a reasonable value.  */


/* Maximum number of timer expiration overruns.  */


/* Maximum tty name length.  */


/* Maximum login name length.  This is arbitrary.  */


/* Maximum host name length.  */


/* Maximum message queue priority level.  */


/* Maximum value the semaphore can have.  */
# 161 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix1_lim.h" 2







/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */





# 157 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h" 2


# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix2_lim.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */





/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */


/* The maximum number of elements allowed in an array by the `bc' utility.  */


/* The maximum `scale' value allowed by the `bc' utility.  */


/* The maximum length of a string constant accepted by the `bc' utility.  */


/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */


/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */


/* The maximum length, in bytes, of an input line.  */


/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */


/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */



/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */

# 86 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/posix2_lim.h"

/* This value is defined like this in regex.h.  */


# 161 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/limits.h" 2


# 27 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.14 Signal handling <signal.h>
 */











# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigset.h" 1
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

# 33 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigset.h"


/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */








/* Return a mask that includes the bit for SIG only.  */



/* Return the word index for SIG.  */


# 98 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigset.h"

/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);

# 122 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigset.h"


# 33 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2

/* An integral type that can be modified atomically, without the
   possibility of a signal arriving in the middle of the operation.  */




typedef __sig_atomic_t sig_atomic_t;





# 53 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/signum.h" 1
/* Signal number definitions.  Linux version.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */



/* Fake signal functions.  */









/* Signals.  */
# 67 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/signum.h"







/* These are the hard limits of the kernel.  These values should not be
   used directly at user level.  */



# 58 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2

# 71 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"


/* We need `struct timespec' later on.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.23 Date and time    <time.h>
 */



# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 51 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 67 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 83 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 95 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 107 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


# 128 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


# 436 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 76 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2



/* Get the `siginfo_t' type plus the needed symbols.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h" 1
/* siginfo_t, sigevent and constants.  Linux x86-64 version.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/wordsize.h" 1
/* Determine the wordsize from the preprocessor defines.  */







# 25 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h" 2






/* Type for data associated with a signal.  */
typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;






# 49 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h"

# 58 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;               /* Signal number.  */
    int si_errno;               /* If non-zero, an errno value associated with
                                   this signal, as defined in <errno.h>.  */
    int si_code;                /* Signal code.  */

    union
      {
        int _pad[((128 / sizeof (int)) - 3)];

         /* kill().  */
        struct
          {
            __pid_t si_pid;     /* Sending process ID.  */
            __uid_t si_uid;     /* Real user ID of sending process.  */
          } _kill;

        /* POSIX.1b timers.  */
        struct
          {
            int si_tid;         /* Timer ID.  */
            int si_overrun;     /* Overrun count.  */
            sigval_t si_sigval; /* Signal value.  */
          } _timer;

        /* POSIX.1b signals.  */
        struct
          {
            __pid_t si_pid;     /* Sending process ID.  */
            __uid_t si_uid;     /* Real user ID of sending process.  */
            sigval_t si_sigval; /* Signal value.  */
          } _rt;

        /* SIGCHLD.  */
        struct
          {
            __pid_t si_pid;     /* Which child.  */
            __uid_t si_uid;     /* Real user ID of sending process.  */
            int si_status;      /* Exit value or signal.  */
            __sigchld_clock_t si_utime;
            __sigchld_clock_t si_stime;
          } _sigchld;

        /* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
        struct
          {
            void *si_addr;      /* Faulting insn/memory ref.  */
            short int si_addr_lsb;      /* Valid LSB of the reported address.  */
            struct
              {
                void *_lower;
                void *_upper;
              } si_addr_bnd;
          } _sigfault;

        /* SIGPOLL.  */
        struct
          {
            long int si_band;   /* Band event for SIGPOLL.  */
            int si_fd;
          } _sigpoll;

        /* SIGSYS.  */
        struct
          {
            void *_call_addr;   /* Calling user insn.  */
            int _syscall;       /* Triggering system call number.  */
            unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
          } _sigsys;
      } _sifields;
  } siginfo_t ;


/* X/Open requires some more fields with fixed names.  */
# 156 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h"


/* Values for `si_code'.  Positive values are reserved for kernel-generated
   signals.  */
enum
{
  SI_ASYNCNL = -60,             /* Sent by asynch name lookup completion.  */

  SI_TKILL = -6,                /* Sent by tkill.  */

  SI_SIGIO,                     /* Sent by queued SIGIO. */

  SI_ASYNCIO,                   /* Sent by AIO completion.  */

  SI_MESGQ,                     /* Sent by real time mesq state change.  */

  SI_TIMER,                     /* Sent by timer expiration.  */

  SI_QUEUE,                     /* Sent by sigqueue.  */

  SI_USER,                      /* Sent by kill, sigsend.  */

  SI_KERNEL = 0x80              /* Send by kernel.  */

};



/* `si_code' values for SIGILL signal.  */
enum
{
  ILL_ILLOPC = 1,               /* Illegal opcode.  */

  ILL_ILLOPN,                   /* Illegal operand.  */

  ILL_ILLADR,                   /* Illegal addressing mode.  */

  ILL_ILLTRP,                   /* Illegal trap. */

  ILL_PRVOPC,                   /* Privileged opcode.  */

  ILL_PRVREG,                   /* Privileged register.  */

  ILL_COPROC,                   /* Coprocessor error.  */

  ILL_BADSTK                    /* Internal stack error.  */

};

/* `si_code' values for SIGFPE signal.  */
enum
{
  FPE_INTDIV = 1,               /* Integer divide by zero.  */

  FPE_INTOVF,                   /* Integer overflow.  */

  FPE_FLTDIV,                   /* Floating point divide by zero.  */

  FPE_FLTOVF,                   /* Floating point overflow.  */

  FPE_FLTUND,                   /* Floating point underflow.  */

  FPE_FLTRES,                   /* Floating point inexact result.  */

  FPE_FLTINV,                   /* Floating point invalid operation.  */

  FPE_FLTSUB                    /* Subscript out of range.  */

};

/* `si_code' values for SIGSEGV signal.  */
enum
{
  SEGV_MAPERR = 1,              /* Address not mapped to object.  */

  SEGV_ACCERR                   /* Invalid permissions for mapped object.  */

};

/* `si_code' values for SIGBUS signal.  */
enum
{
  BUS_ADRALN = 1,               /* Invalid address alignment.  */

  BUS_ADRERR,                   /* Non-existant physical address.  */

  BUS_OBJERR,                   /* Object specific hardware error.  */

  BUS_MCEERR_AR,                /* Hardware memory error: action required.  */

  BUS_MCEERR_AO                 /* Hardware memory error: action optional.  */

};


# 261 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h"


/* `si_code' values for SIGCHLD signal.  */
enum
{
  CLD_EXITED = 1,               /* Child has exited.  */

  CLD_KILLED,                   /* Child was killed.  */

  CLD_DUMPED,                   /* Child terminated abnormally.  */

  CLD_TRAPPED,                  /* Traced child has trapped.  */

  CLD_STOPPED,                  /* Child has stopped.  */

  CLD_CONTINUED                 /* Stopped child has continued.  */

};

/* `si_code' values for SIGPOLL signal.  */
enum
{
  POLL_IN = 1,                  /* Data input available.  */

  POLL_OUT,                     /* Output buffers available.  */

  POLL_MSG,                     /* Input message available.   */

  POLL_ERR,                     /* I/O error.  */

  POLL_PRI,                     /* High priority input available.  */

  POLL_HUP                      /* Device disconnected.  */

};










/* Structure to transport application-defined values with signals.  */
# 313 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/siginfo.h"

/* Forward declaration.  */





typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
        int _pad[((64 / sizeof (int)) - 3)];

        /* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
           thread to receive the signal.  */
        __pid_t _tid;

        struct
          {
            void (*_function) (sigval_t);       /* Function to start.  */
            pthread_attr_t *_attribute;         /* Thread attributes.  */
          } _sigev_thread;
      } _sigev_un;
  } sigevent_t;

/* POSIX names to access some of the members.  */



/* `sigev_notify' values.  */
enum
{
  SIGEV_SIGNAL = 0,             /* Notify via signal.  */

  SIGEV_NONE,                   /* Other notification: meaningless.  */

  SIGEV_THREAD,                 /* Deliver via thread creation.  */


  SIGEV_THREAD_ID = 4           /* Send signal to specific thread.  */

};

# 81 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2



/* Type of a signal handler.  */
typedef void (*__sighandler_t) (int);

/* The X/Open definition of `signal' specifies the SVID semantic.  Use
   the additional function `sysv_signal' when X/Open compatibility is
   requested.  */
extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     ;





/* Set the handler for the signal SIG to HANDLER, returning the old
   handler, or SIG_ERR on error.
   By default `signal' has the BSD semantic.  */


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     ;
# 114 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"


# 122 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"

/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is < -1, send SIG to all processes in process group - PID.  */

extern int kill (__pid_t __pid, int __sig) ;



/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */
extern int killpg (__pid_t __pgrp, int __sig) ;



/* Raise signal SIG, i.e., send SIG to yourself.  */
extern int raise (int __sig) ;



/* SVID names for the same things.  */
extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     ;
extern int gsignal (int __sig) ;



/* Print a message describing the meaning of the given signal number.  */
extern void psignal (int __sig, const char *__s);

/* Print a message describing the meaning of the given signal information.  */
extern void psiginfo (const siginfo_t *__pinfo, const char *__s);




/* The `sigpause' function in X/Open defines the argument as the
   signal number.  This requires redirecting to another function
   because the default version in glibc uses an old BSD interface.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

# 175 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"



/* None of the following functions should be used anymore.  They are here
   only for compatibility.  A single word (`int') is not guaranteed to be
   enough to hold a complete signal mask and therefore these functions
   simply do not work in many situations.  Use `sigprocmask' instead.  */

/* Compute mask for signal SIG.  */


/* Block signals in MASK, returning the old mask.  */
extern int sigblock (int __mask)  ;

/* Set the mask of blocked signals to MASK, returning the old mask.  */
extern int sigsetmask (int __mask)  ;

/* Return currently selected signal mask.  */
extern int siggetmask (void)  ;











/* 4.4 BSD uses the name `sig_t' for this.  */

typedef __sighandler_t sig_t;




/* Clear all signals from SET.  */
extern int sigemptyset (sigset_t *__set)  ;

/* Set all signals in SET.  */
extern int sigfillset (sigset_t *__set)  ;

/* Add SIGNO to SET.  */
extern int sigaddset (sigset_t *__set, int __signo)  ;

/* Remove SIGNO from SET.  */
extern int sigdelset (sigset_t *__set, int __signo)  ;

/* Return 1 if SIGNO is in SET, 0 if not.  */
extern int sigismember (const sigset_t *__set, int __signo)
      ;

# 240 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"

/* Get the system-specific definitions of `struct sigaction'
   and the `SA_*' and `SIG_*'. constants.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigaction.h" 1
/* The proper definitions for Linux's sigaction.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Structure describing the action to be taken when a signal arrives.  */
struct sigaction
  {
    /* Signal handler.  */

    union
      {
        /* Used if SA_SIGINFO is not set.  */
        __sighandler_t sa_handler;
        /* Used if SA_SIGINFO is set.  */
        void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;






    /* Additional set of signals to be blocked.  */
    __sigset_t sa_mask;

    /* Special flags.  */
    int sa_flags;

    /* Restore handler.  */
    void (*sa_restorer) (void);
  };

/* Bits in `sa_flags'.  */
# 68 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigaction.h"

/* Some aliases for the SA_ constants.  */





/* Values for the HOW argument to `sigprocmask'.  */
# 244 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2

/* Get and/or change the set of blocked signals.  */
extern int sigprocmask (int __how, const sigset_t * __set,
                        sigset_t * __oset) ;

/* Change the set of blocked signals to SET,
   wait until a signal arrives, and restore the set of blocked signals.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigsuspend (const sigset_t *__set) ;

/* Get and/or set the action for signal SIG.  */
extern int sigaction (int __sig, const struct sigaction * __act,
                      struct sigaction * __oact) ;

/* Put in SET all signals that are blocked and waiting to be delivered.  */
extern int sigpending (sigset_t *__set)  ;


/* Select any of pending signals from SET or wait for any to arrive.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwait (const sigset_t * __set, int * __sig)
     ;


/* Select any of pending signals from SET and place information in INFO.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwaitinfo (const sigset_t * __set,
                        siginfo_t * __info) ;

/* Select any of pending signals from SET and place information in INFO.
   Wait the time specified by TIMEOUT if no signal is pending.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigtimedwait (const sigset_t * __set,
                         siginfo_t * __info,
                         const struct timespec * __timeout)
     ;

/* Send signal SIG to the process PID.  Associate data in VAL with the
   signal.  */
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     ;






/* Names of the signals.  This variable exists only for compatibility.
   Use `strsignal' instead (see <string.h>).  */
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigcontext.h" 1
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */












struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t    element[4];
};





struct _fpstate
{
  /* Regular FPU environment.  */
  __uint32_t    cw;
  __uint32_t            sw;
  __uint32_t            tag;
  __uint32_t            ipoff;
  __uint32_t            cssel;
  __uint32_t            dataoff;
  __uint32_t            datasel;
  struct _fpreg _st[8];
  unsigned short status;
  unsigned short magic;

  /* FXSR FPU environment.  */
  __uint32_t            _fxsr_env[6];
  __uint32_t            mxcsr;
  __uint32_t            reserved;
  struct _fpxreg        _fxsr_st[8];
  struct _xmmreg        _xmm[8];
  __uint32_t            padding[56];
};


/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
   we need sigcontext.  Some packages have come to rely on
   sigcontext_struct being defined on 32-bit x86, so define this for
   their benefit.  */





struct sigcontext
{
  unsigned short gs, __gsh;
  unsigned short fs, __fsh;
  unsigned short es, __esh;
  unsigned short ds, __dsh;
  unsigned long edi;
  unsigned long esi;
  unsigned long ebp;
  unsigned long esp;
  unsigned long ebx;
  unsigned long edx;
  unsigned long ecx;
  unsigned long eax;
  unsigned long trapno;
  unsigned long err;
  unsigned long eip;
  unsigned short cs, __csh;
  unsigned long eflags;
  unsigned long esp_at_signal;
  unsigned short ss, __ssh;
  struct _fpstate * fpstate;
  unsigned long oldmask;
  unsigned long cr2;
};

# 174 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigcontext.h"

struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};

# 307 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2

/* Restore the state saved in SCP.  */
extern int sigreturn (struct sigcontext *__scp) ;








/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
   (causing them to fail with EINTR); if INTERRUPT is zero, make system
   calls be restarted after signal SIG.  */
extern int siginterrupt (int sig, int interruptnum) ;

# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigstack.h" 1
/* sigstack, sigaltstack definitions.
   Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Structure describing a signal stack (obsolete).  */
struct sigstack
  {
    void *ss_sp;                /* Signal stack pointer.  */
    int ss_onstack;             /* Nonzero if executing on this stack.  */
  };


/* Possible values for `ss_flags.'.  */
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};

/* Minimum stack size for a signal handler.  */


/* System default stack size.  */



/* Alternate, preferred interface.  */
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 324 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2

/* This will define `ucontext_t' and `mcontext_t'.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/ucontext.h" 1
/* Copyright (C) 2001-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.14 Signal handling <signal.h>
 */

# 23 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/ucontext.h" 2

/* We need the signal context definitions even if they are not used
   included in <signal.h>.  */


# 144 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/ucontext.h"

/* Type for general register.  */
typedef int greg_t;

/* Number of general registers.  */


/* Container for all general registers.  */
typedef greg_t gregset_t[19];

# 198 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/ucontext.h"

/* Definitions taken from the kernel headers.  */
struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};

/* Structure to describe FPU registers.  */
typedef struct _libc_fpstate *fpregset_t;

/* Context to describe whole processor state.  */
typedef struct
  {
    gregset_t gregs;
    /* Due to Linux's history we have to use a pointer here.  The SysV/i386
       ABI requires a struct with the values.  */
    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;

/* Userlevel context.  */
typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;



# 327 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2


/* Run signals handlers on the stack specified by SS (if not NULL).
   If OSS is not NULL, it is filled in with the old signal stack status.
   This interface is obsolete and on many platform not implemented.  */
extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
      ;

/* Alternate signal handler stack interface.
   This interface should always be preferred over `sigstack'.  */
extern int sigaltstack (const struct sigaltstack * __ss,
                        struct sigaltstack * __oss) ;



# 357 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h"


/* Some of the functions for handling signals in threaded programs must
   be defined here.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/sigthread.h" 1
/* Signal handling function for threaded programs.
   Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */








/* Functions for handling signals. */

/* Modify the signal mask for the calling thread.  The arguments have
   the same meaning as for sigprocmask(2). */
extern int pthread_sigmask (int __how,
                            const __sigset_t * __newmask,
                            __sigset_t * __oldmask);

/* Send signal SIGNO to the given thread. */
extern int pthread_kill (pthread_t __threadid, int __signo) ;







# 363 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/signal.h" 2


/* The following functions are used internally in the C library and in
   other code which need deep insights.  */

/* Return number of available real-time signal with highest priority.  */
extern int __libc_current_sigrtmin (void) ;
/* Return number of available real-time signal with lowest priority.  */
extern int __libc_current_sigrtmax (void) ;





# 29 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h" 2

/* This file defines some things in system-specific ways.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/param.h" 1
/* Old-style Unix parameters and limits.  Linux version.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */









# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/param.h" 1
/* Copyright 2012 The MathWorks, Inc. */














# 29 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/param.h" 2

/* The kernel headers define ARG_MAX.  The value is wrong, though.  */







/* The following are not really correct but it is a value we used for a
   long time and which seems to be usable.  People should not use NOFILE
   and NCARGS anyway.  */
# 32 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h" 2


/* BSD names for some <limits.h> values.  */



# 65 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h"


/* Magical constants.  */
# 74 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h"


/* Unit of `st_blocks'.  */





/* Bit map related macros.  */





/* Macros for counting and rounding.  */
# 100 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/param.h"

/* Macros for min/max.  */




# 63 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h" 1
/*
 * Copyright (c) 1983, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *      $BINDId: nameser.h,v 8.37 2000/03/30 21:16:49 vixie Exp $
 */




/*! \file */







/*%
 * Revision information.  This is the release date in YYYYMMDD format.
 * It can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__NAMESER > 19931104)".  Do not
 * compare for equality; rather, use it to determine whether your libbind.a
 * contains a new enough lib/nameser/ to support the feature you need.
 */


/*
 * Define constants based on RFC 883, RFC 1034, RFC 1035
 */
# 90 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"
/*
 * These can be expanded with synonyms, just keep ns_parse.c:ns_parserecord()
 * in synch with it.
 */
typedef enum __ns_sect {
        ns_s_qd = 0,            /*%< Query: Question. */
        ns_s_zn = 0,            /*%< Update: Zone. */
        ns_s_an = 1,            /*%< Query: Answer. */
        ns_s_pr = 1,            /*%< Update: Prerequisites. */
        ns_s_ns = 2,            /*%< Query: Name servers. */
        ns_s_ud = 2,            /*%< Update: Update. */
        ns_s_ar = 3,            /*%< Query|Update: Additional records. */
        ns_s_max = 4
} ns_sect;

/*%
 * This is a message handle.  It is caller allocated and has no dynamic data.
 * This structure is intended to be opaque to all but ns_parse.c, thus the
 * leading _'s on the member names.  Use the accessor functions, not the _'s.
 */
typedef struct __ns_msg {
        const u_char    *_msg, *_eom;
        u_int16_t       _id, _flags, _counts[ns_s_max];
        const u_char    *_sections[ns_s_max];
        ns_sect         _sect;
        int             _rrnum;
        const u_char    *_msg_ptr;
} ns_msg;

/* Private data structure - do not use from outside library. */
struct _ns_flagdata {  int mask, shift;  };
extern const struct _ns_flagdata _ns_flagdata[];

/* Accessor macros - this is part of the public interface. */







/*%
 * This is a parsed record.  It is caller allocated and has no dynamic data.
 */
typedef struct __ns_rr {
        char            name[1025];
        u_int16_t       type;
        u_int16_t       rr_class;
        u_int32_t       ttl;
        u_int16_t       rdlength;
        const u_char *  rdata;
} ns_rr;

/* Accessor macros - this is part of the public interface. */
# 150 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"

/*%
 * These don't have to be in the same order as in the packet flags word,
 * and they can even overlap in some cases, but they will need to be kept
 * in synch with ns_parse.c:ns_flagdata[].
 */
typedef enum __ns_flag {
        ns_f_qr,                /*%< Question/Response. */
        ns_f_opcode,            /*%< Operation code. */
        ns_f_aa,                /*%< Authoritative Answer. */
        ns_f_tc,                /*%< Truncation occurred. */
        ns_f_rd,                /*%< Recursion Desired. */
        ns_f_ra,                /*%< Recursion Available. */
        ns_f_z,                 /*%< MBZ. */
        ns_f_ad,                /*%< Authentic Data (DNSSEC). */
        ns_f_cd,                /*%< Checking Disabled (DNSSEC). */
        ns_f_rcode,             /*%< Response code. */
        ns_f_max
} ns_flag;

/*%
 * Currently defined opcodes.
 */
typedef enum __ns_opcode {
        ns_o_query = 0,         /*%< Standard query. */
        ns_o_iquery = 1,        /*%< Inverse query (deprecated/unsupported). */
        ns_o_status = 2,        /*%< Name server status query (unsupported). */
                                /* Opcode 3 is undefined/reserved. */
        ns_o_notify = 4,        /*%< Zone change notification. */
        ns_o_update = 5,        /*%< Zone update message. */
        ns_o_max = 6
} ns_opcode;

/*%
 * Currently defined response codes.
 */
typedef enum __ns_rcode {
        ns_r_noerror = 0,       /*%< No error occurred. */
        ns_r_formerr = 1,       /*%< Format error. */
        ns_r_servfail = 2,      /*%< Server failure. */
        ns_r_nxdomain = 3,      /*%< Name error. */
        ns_r_notimpl = 4,       /*%< Unimplemented. */
        ns_r_refused = 5,       /*%< Operation refused. */
        /* these are for BIND_UPDATE */
        ns_r_yxdomain = 6,      /*%< Name exists */
        ns_r_yxrrset = 7,       /*%< RRset exists */
        ns_r_nxrrset = 8,       /*%< RRset does not exist */
        ns_r_notauth = 9,       /*%< Not authoritative for zone */
        ns_r_notzone = 10,      /*%< Zone of record different from zone section */
        ns_r_max = 11,
        /* The following are EDNS extended rcodes */
        ns_r_badvers = 16,
        /* The following are TSIG errors */
        ns_r_badsig = 16,
        ns_r_badkey = 17,
        ns_r_badtime = 18
} ns_rcode;

/* BIND_UPDATE */
typedef enum __ns_update_operation {
        ns_uop_delete = 0,
        ns_uop_add = 1,
        ns_uop_max = 2
} ns_update_operation;

/* Polyspace: data is a macro for iar dialect */





/*%
 * This structure is used for TSIG authenticated messages
 */
struct ns_tsig_key {
        char name[1025], alg[1025];
        unsigned char *data;
        int len;
};
typedef struct ns_tsig_key ns_tsig_key;

/*%
 * This structure is used for TSIG authenticated TCP messages
 */
struct ns_tcp_tsig_state {
        int counter;
        struct dst_key *key;
        void *ctx;
        unsigned char sig[512];
        int siglen;
};
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;









/*%
 * Currently defined type values for resources and queries.
 */
typedef enum __ns_type {
        ns_t_invalid = 0,       /*%< Cookie. */
        ns_t_a = 1,             /*%< Host address. */
        ns_t_ns = 2,            /*%< Authoritative server. */
        ns_t_md = 3,            /*%< Mail destination. */
        ns_t_mf = 4,            /*%< Mail forwarder. */
        ns_t_cname = 5,         /*%< Canonical name. */
        ns_t_soa = 6,           /*%< Start of authority zone. */
        ns_t_mb = 7,            /*%< Mailbox domain name. */
        ns_t_mg = 8,            /*%< Mail group member. */
        ns_t_mr = 9,            /*%< Mail rename name. */
        ns_t_null = 10,         /*%< Null resource record. */
        ns_t_wks = 11,          /*%< Well known service. */
        ns_t_ptr = 12,          /*%< Domain name pointer. */
        ns_t_hinfo = 13,        /*%< Host information. */
        ns_t_minfo = 14,        /*%< Mailbox information. */
        ns_t_mx = 15,           /*%< Mail routing information. */
        ns_t_txt = 16,          /*%< Text strings. */
        ns_t_rp = 17,           /*%< Responsible person. */
        ns_t_afsdb = 18,        /*%< AFS cell database. */
        ns_t_x25 = 19,          /*%< X_25 calling address. */
        ns_t_isdn = 20,         /*%< ISDN calling address. */
        ns_t_rt = 21,           /*%< Router. */
        ns_t_nsap = 22,         /*%< NSAP address. */
        ns_t_nsap_ptr = 23,     /*%< Reverse NSAP lookup (deprecated). */
        ns_t_sig = 24,          /*%< Security signature. */
        ns_t_key = 25,          /*%< Security key. */
        ns_t_px = 26,           /*%< X.400 mail mapping. */
        ns_t_gpos = 27,         /*%< Geographical position (withdrawn). */
        ns_t_aaaa = 28,         /*%< Ip6 Address. */
        ns_t_loc = 29,          /*%< Location Information. */
        ns_t_nxt = 30,          /*%< Next domain (security). */
        ns_t_eid = 31,          /*%< Endpoint identifier. */
        ns_t_nimloc = 32,       /*%< Nimrod Locator. */
        ns_t_srv = 33,          /*%< Server Selection. */
        ns_t_atma = 34,         /*%< ATM Address */
        ns_t_naptr = 35,        /*%< Naming Authority PoinTeR */
        ns_t_kx = 36,           /*%< Key Exchange */
        ns_t_cert = 37,         /*%< Certification record */
        ns_t_a6 = 38,           /*%< IPv6 address (deprecated, use ns_t_aaaa) */
        ns_t_dname = 39,        /*%< Non-terminal DNAME (for IPv6) */
        ns_t_sink = 40,         /*%< Kitchen sink (experimentatl) */
        ns_t_opt = 41,          /*%< EDNS0 option (meta-RR) */
        ns_t_apl = 42,          /*%< Address prefix list (RFC3123) */
        ns_t_tkey = 249,        /*%< Transaction key */
        ns_t_tsig = 250,        /*%< Transaction signature. */
        ns_t_ixfr = 251,        /*%< Incremental zone transfer. */
        ns_t_axfr = 252,        /*%< Transfer zone of authority. */
        ns_t_mailb = 253,       /*%< Transfer mailbox records. */
        ns_t_maila = 254,       /*%< Transfer mail agent records. */
        ns_t_any = 255,         /*%< Wildcard match. */
        ns_t_zxfr = 256,        /*%< BIND-specific, nonstandard. */
        ns_t_max = 65536
} ns_type;

/* Exclusively a QTYPE? (not also an RTYPE) */


/* Some kind of meta-RR? (not a QTYPE, but also not an RTYPE) */

/* Exclusively an RTYPE? (not also a QTYPE or a meta-RR) */





/*%
 * Values for class field
 */
typedef enum __ns_class {
        ns_c_invalid = 0,       /*%< Cookie. */
        ns_c_in = 1,            /*%< Internet. */
        ns_c_2 = 2,             /*%< unallocated/unsupported. */
        ns_c_chaos = 3,         /*%< MIT Chaos-net. */
        ns_c_hs = 4,            /*%< MIT Hesiod. */
        /* Query class values which do not appear in resource records */
        ns_c_none = 254,        /*%< for prereq. sections in update requests */
        ns_c_any = 255,         /*%< Wildcard match. */
        ns_c_max = 65536
} ns_class;

/* DNSSEC constants. */

typedef enum __ns_key_types {
        ns_kt_rsa = 1,          /*%< key type RSA/MD5 */
        ns_kt_dh  = 2,          /*%< Diffie Hellman */
        ns_kt_dsa = 3,          /*%< Digital Signature Standard (MANDATORY) */
        ns_kt_private = 254     /*%< Private key type starts with OID */
} ns_key_types;

typedef enum __ns_cert_types {
        cert_t_pkix = 1,        /*%< PKIX (X.509v3) */
        cert_t_spki = 2,        /*%< SPKI */
        cert_t_pgp  = 3,        /*%< PGP */
        cert_t_url  = 253,      /*%< URL private type */
        cert_t_oid  = 254       /*%< OID private type */
} ns_cert_types;

/* Flags field of the KEY RR rdata. */





/* The type bits can also be interpreted independently, as single bits: */
# 383 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"
/* The Algorithm field of the KEY and SIG RR's is an integer, {1..254} */
# 390 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"
/* Protocol values  */
/* value 0 is reserved */






/* Signatures */


        /* Total of binary mod and exp */

        /* Max length of text sig block */








/* Offsets into SIG record rdata to find various values */
# 421 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"
/* How RR types are represented as bit-flags in NXT records */






/*%
 * EDNS0 extended flags and option codes, host order.
 */



/*%
 * Inline versions of get/put short/long.  Pointer is advanced.
 */
# 444 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"

# 454 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"

# 462 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"

# 472 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h"


int             ns_msg_getflag (ns_msg, int) ;
u_int           ns_get16 (const u_char *) ;
u_long          ns_get32 (const u_char *) ;
void            ns_put16 (u_int, u_char *) ;
void            ns_put32 (u_long, u_char *) ;
int             ns_initparse (const u_char *, int, ns_msg *) ;
int             ns_skiprr (const u_char *, const u_char *, ns_sect, int)
     ;
int             ns_parserr (ns_msg *, ns_sect, int, ns_rr *) ;
int             ns_sprintrr (const ns_msg *, const ns_rr *,
                             const char *, const char *, char *, size_t)
     ;
int             ns_sprintrrf (const u_char *, size_t, const char *,
                              ns_class, ns_type, u_long, const u_char *,
                              size_t, const char *, const char *,
                              char *, size_t) ;
int             ns_format_ttl (u_long, char *, size_t) ;
int             ns_parse_ttl (const char *, u_long *) ;
u_int32_t       ns_datetosecs (const char *, int *) ;
int             ns_name_ntol (const u_char *, u_char *, size_t) ;
int             ns_name_ntop (const u_char *, char *, size_t) ;
int             ns_name_pton (const char *, u_char *, size_t) ;
int             ns_name_unpack (const u_char *, const u_char *,
                                const u_char *, u_char *, size_t) ;
int             ns_name_pack (const u_char *, u_char *, int,
                              const u_char **, const u_char **) ;
int             ns_name_uncompress (const u_char *, const u_char *,
                                    const u_char *, char *, size_t) ;
int             ns_name_compress (const char *, u_char *, size_t,
                                  const u_char **, const u_char **) ;
int             ns_name_skip (const u_char **, const u_char *) ;
void            ns_name_rollback (const u_char *, const u_char **,
                                  const u_char **) ;
int             ns_sign (u_char *, int *, int, int, void *,
                         const u_char *, int, u_char *, int *, time_t) ;
int             ns_sign2 (u_char *, int *, int, int, void *,
                          const u_char *, int, u_char *, int *, time_t,
                          u_char **, u_char **) ;
int             ns_sign_tcp (u_char *, int *, int, int,
                             ns_tcp_tsig_state *, int) ;
int             ns_sign_tcp2 (u_char *, int *, int, int,
                              ns_tcp_tsig_state *, int,
                              u_char **, u_char **) ;
int             ns_sign_tcp_init (void *, const u_char *, int,
                                  ns_tcp_tsig_state *) ;
u_char          *ns_find_tsig (u_char *, u_char *) ;
int             ns_verify (u_char *, int *, void *, const u_char *, int,
                           u_char *, int *, time_t *, int) ;
int             ns_verify_tcp (u_char *, int *, ns_tcp_tsig_state *, int)
     ;
int             ns_verify_tcp_init (void *, const u_char *, int,
                                    ns_tcp_tsig_state *) ;
int             ns_samedomain (const char *, const char *) ;
int             ns_subdomain (const char *, const char *) ;
int             ns_makecanon (const char *, char *, size_t) ;
int             ns_samename (const char *, const char *) ;


# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser_compat.h" 1
/* Copyright (c) 1983, 1989
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*%
 *      from nameser.h  8.1 (Berkeley) 6/2/93
 *      $BINDId: nameser_compat.h,v 8.11 1999/01/02 08:00:58 vixie Exp $
 */








/*%
 * Structure for query header.  The order of the fields is machine- and
 * compiler-dependent, depending on the byte/bit order and the layout
 * of bit fields.  We use bit fields only in int variables, as this
 * is all ANSI requires.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
        unsigned        id :16;         /*%< query identification number */

                        /* fields in third byte */
        unsigned        qr: 1;          /*%< response flag */
        unsigned        opcode: 4;      /*%< purpose of message */
        unsigned        aa: 1;          /*%< authoritive answer */
        unsigned        tc: 1;          /*%< truncated message */
        unsigned        rd: 1;          /*%< recursion desired */
                        /* fields in fourth byte */
        unsigned        ra: 1;          /*%< recursion available */
        unsigned        unused :1;      /*%< unused bits (MBZ as of 4.9.3a3) */
        unsigned        ad: 1;          /*%< authentic data from named */
        unsigned        cd: 1;          /*%< checking disabled by resolver */
        unsigned        rcode :4;       /*%< response code */


                        /* fields in third byte */
        unsigned        rd :1;          /*%< recursion desired */
        unsigned        tc :1;          /*%< truncated message */
        unsigned        aa :1;          /*%< authoritive answer */
        unsigned        opcode :4;      /*%< purpose of message */
        unsigned        qr :1;          /*%< response flag */
                        /* fields in fourth byte */
        unsigned        rcode :4;       /*%< response code */
        unsigned        cd: 1;          /*%< checking disabled by resolver */
        unsigned        ad: 1;          /*%< authentic data from named */
        unsigned        unused :1;      /*%< unused bits (MBZ as of 4.9.3a3) */
        unsigned        ra :1;          /*%< recursion available */

                        /* remaining bytes */
        unsigned        qdcount :16;    /*%< number of question entries */
        unsigned        ancount :16;    /*%< number of answer entries */
        unsigned        nscount :16;    /*%< number of authority entries */
        unsigned        arcount :16;    /*%< number of resource entries */
} HEADER;

# 99 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser_compat.h"












# 122 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser_compat.h"
/*#define BADSIG                ns_r_badsig*/
/*#define BADKEY                ns_r_badkey*/
/*#define BADTIME               ns_r_badtime*/





# 173 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser_compat.h"




/* BIND_UPDATE */









/*! \file */
# 534 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/arpa/nameser.h" 2


/* Polyspace */






/*! \file */
# 66 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h" 2





typedef enum { res_goahead, res_nextns, res_modified, res_done, res_error }
        res_sendhookact;

typedef res_sendhookact (*res_send_qhook) (struct sockaddr_in * const *__ns,
                                           const u_char **__query,
                                           int *__querylen,
                                           u_char *__ans,
                                           int __anssiz,
                                           int *__resplen);

typedef res_sendhookact (*res_send_rhook) (const struct sockaddr_in *__ns,
                                           const u_char *__query,
                                           int __querylen,
                                           u_char *__ans,
                                           int __anssiz,
                                           int *__resplen);

/*
 * Global defines and variables for resolver stub.
 */





# 103 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h"

struct __res_state {
        int     retrans;                /* retransmition time interval */
        int     retry;                  /* number of times to retransmit */
        u_long  options;                /* option flags - see below. */
        int     nscount;                /* number of name servers */
        struct sockaddr_in
                nsaddr_list[3];     /* address of name server */

        u_short id;                     /* current message id */
        /* 2 byte hole here.  */
        char    *dnsrch[6+1];   /* components of domain to search */
        char    defdname[256];          /* default domain (deprecated) */
        u_long  pfcode;                 /* RES_PRF_ flags - see below. */
        unsigned ndots:4;               /* threshold for initial abs. query */
        unsigned nsort:4;               /* number of elements in sort_list[] */
        unsigned ipv6_unavail:1;        /* connecting to IPv6 server failed */
        unsigned unused:23;
        struct {
                struct in_addr  addr;
                u_int32_t       mask;
        } sort_list[10];
        /* 4 byte hole here on 64-bit architectures.  */
        res_send_qhook qhook;           /* query hook */
        res_send_rhook rhook;           /* response hook */
        int     res_h_errno;            /* last one set for this context */
        int     _vcsock;                /* PRIVATE: for res_send VC i/o */
        u_int   _flags;                 /* PRIVATE: see below */
        /* 4 byte hole here on 64-bit architectures.  */
        union {
                char    pad[52];        /* On an i386 this means 512b total. */
                struct {
                        u_int16_t               nscount;
                        u_int16_t               nsmap[3];
                        int                     nssocks[3];
                        u_int16_t               nscount6;
                        u_int16_t               nsinit;
                        struct sockaddr_in6     *nsaddrs[3];




                        unsigned int            _initstamp[2];

                } _ext;
        } _u;
};

typedef struct __res_state *res_state;




/*
 * Revision information.  This is the release date in YYYYMMDD format.
 * It can change every day so the right thing to do with it is use it
 * in preprocessor commands such as "#if (__RES > 19931104)".  Do not
 * compare for equality; rather, use it to determine whether your resolver
 * is new enough to contain a certain feature.
 */



/*
 * Resolver configuration file.
 * Normally not present, but may contain the address of the
 * inital name server(s) to query and the domain search list.
 */





struct res_sym {
        int     number;         /* Identifying number, like T_MX */
        char *  name;           /* Its symbolic name, like "MX" */
        char *  humanname;      /* Its fun name, like "mail exchanger" */
};

/*
 * Resolver flags (used to be discrete per-module statics ints).
 */




/* res_findzonecut() options */


/*
 * Resolver options (keep these in synch with res_debug.c, please)
 */
# 224 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h"



/*
 * Resolver "pfcode" values.  Used by dig.
 */
# 245 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h"
/*                      0x00008000      */

/* Things involving an internal (static) resolver context. */

extern struct __res_state *__res_state(void) ;



# 265 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h"


void            __fp_nquery (const u_char *, int, FILE *) ;
void            __fp_query (const u_char *, FILE *) ;
const char *    __hostalias (const char *) ;
void            __p_query (const u_char *) ;
void            __res_close (void) ;
int             __res_init (void) ;
int             __res_isourserver (const struct sockaddr_in *) ;
int             __res_mkquery (int, const char *, int, int, const u_char *,
                             int, const u_char *, u_char *, int) ;
int             __res_query (const char *, int, int, u_char *, int) ;
int             __res_querydomain (const char *, const char *, int, int,
                                 u_char *, int) ;
int             __res_search (const char *, int, int, u_char *, int) ;
int             __res_send (const u_char *, int, u_char *, int) ;


# 325 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/resolv.h"

int             __res_hnok (const char *) ;
int             __res_ownok (const char *) ;
int             __res_mailok (const char *) ;
int             __res_dnok (const char *) ;
int             __sym_ston (const struct res_sym *, const char *, int *) ;
const char *    __sym_ntos (const struct res_sym *, int, int *) ;
const char *    __sym_ntop (const struct res_sym *, int, int *) ;
int             __b64_ntop (u_char const *, size_t, char *, size_t) ;
int             __b64_pton (char const *, u_char *, size_t) ;
int             __loc_aton (const char *__ascii, u_char *__binary) ;
const char *    __loc_ntoa (const u_char *__binary, char *__ascii) ;
int             __dn_skipname (const u_char *, const u_char *) ;
void            __putlong (u_int32_t, u_char *) ;
void            __putshort (u_int16_t, u_char *) ;
const char *    __p_class (int) ;
const char *    __p_time (u_int32_t) ;
const char *    __p_type (int) ;
const char *    __p_rcode (int) ;
const u_char *  __p_cdnname (const u_char *, const u_char *, int, FILE *)
     ;
const u_char *  __p_cdname (const u_char *, const u_char *, FILE *) ;
const u_char *  __p_fqnname (const u_char *__cp, const u_char *__msg,
                           int, char *, int) ;
const u_char *  __p_fqname (const u_char *, const u_char *, FILE *) ;
const char *    __p_option (u_long __option) ;
char *          __p_secstodate (u_long) ;
int             __dn_count_labels (const char *) ;
int             __dn_comp (const char *, u_char *, int, u_char **, u_char **)
     ;
int             __dn_expand (const u_char *, const u_char *, const u_char *,
                           char *, int) ;
u_int           __res_randomid (void) ;
int             __res_nameinquery (const char *, int, int,
                                 const u_char *, const u_char *) ;
int             __res_queriesmatch (const u_char *, const u_char *,
                                  const u_char *, const u_char *) ;
const char *    __p_section (int __section, int __opcode) ;
/* Things involving a resolver context. */
int             __res_ninit (res_state) ;
int             __res_nisourserver (const res_state,
                                  const struct sockaddr_in *) ;
void            __fp_resstat (const res_state, FILE *) ;
void            __res_npquery (const res_state, const u_char *, int, FILE *)
     ;
const char *    __res_hostalias (const res_state, const char *, char *, size_t)
     ;
int             __res_nquery (res_state, const char *, int, int, u_char *, int)
     ;
int             __res_nsearch (res_state, const char *, int, int, u_char *, int)
     ;
int             __res_nquerydomain (res_state, const char *, const char *, int,
                                  int, u_char *, int) ;
int             __res_nmkquery (res_state, int, const char *, int, int,
                              const u_char *, int, const u_char *, u_char *,
                              int) ;
int             __res_nsend (res_state, const u_char *, int, u_char *, int)
     ;
void            __res_nclose (res_state) ;



# 21 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/errno.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.5 Errors    <errno.h>
 */



/* The includer defined __need_Emath if he wants only the definitions
   of EDOM and ERANGE, and not everything else.  */







/* Get the error number constants from the system-specific file.
   This file will test __need_Emath and _ERRNO_H.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/errno.h" 1
/* Error constants.  Linux specific version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */



# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/errno.h" 1
/* Copyright 2012 The MathWorks, Inc. */




# 48 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/errno.h"

# 131 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/linux/errno.h"

# 25 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/errno.h" 2

/* Linux has no ENOTSUP error code.  */


/* Older Linux versions also had no ECANCELED error code.  */




/* Support for error codes to support robust mutexes was added later, too.  */














/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void)  ;


/* When using threads, errno is a per-thread value.  */





# 36 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/errno.h" 2




/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */




# 57 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/errno.h"





/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */
# 22 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2


# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h" 1
/* crypto/bio/bio.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */










/******************************************************************************
 * Detect operating systems.  This probably needs completing.
 * The result is that at least one OPENSSL_SYS_os macro should be defined.
 * However, if none is defined, Unix is assumed.
 **/



/* ----------------------- Macintosh, before MacOS X ----------------------- */





/* ----------------------- NetWare ----------------------------------------- */





/* ---------------------- Microsoft operating systems ---------------------- */

/* Note that MSDOS actually denotes 32-bit environments running on top of
   MS-DOS, such as DJGPP one. */





/* For 32 bit environment, there seems to be the CygWin environment and then
   all the others that try to do the same thing Microsoft does... */
# 118 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* Anything that tries to look like Microsoft is "Windows" */
# 127 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* DLL settings.  This part is a bit tough, because it's up to the application
   implementor how he or she will link the application, so it requires some
   macro to be used. */
# 139 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* -------------------------------- OpenVMS -------------------------------- */
# 153 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* --------------------------------- OS/2 ---------------------------------- */





/* --------------------------------- Unix ---------------------------------- */
# 194 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* --------------------------------- VOS ----------------------------------- */
# 205 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* ------------------------------- VxWorks --------------------------------- */




/* --------------------------------- BeOS ---------------------------------- */
# 221 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/**
 * That's it for OS-specific stuff
 *****************************************************************************/


/* Specials for I/O an exit */
# 235 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* Definitions of OPENSSL_GLOBAL and OPENSSL_EXTERN, to define and declare
   certain global symbols that, with some compilers under VMS, have to be
   defined and declared explicitely with globaldef and globalref.
   Definitions of OPENSSL_EXPORT and OPENSSL_IMPORT, to define and declare
   DLL exports and imports for compilers under Win32.  These are a little
   more complicated to use.  Basically, for any library that exports some
   global variables, the following code must be present in the header file
   that declares them, before OPENSSL_EXTERN is used:

   #ifdef SOME_BUILD_FLAG_MACRO
   # undef OPENSSL_EXTERN
   # define OPENSSL_EXTERN OPENSSL_EXPORT
   #endif

   The default is to have OPENSSL_EXPORT, OPENSSL_IMPORT and OPENSSL_GLOBAL
   have some generally sensible values, and for OPENSSL_EXTERN to have the
   value OPENSSL_IMPORT.
*/

# 269 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"

/* Macros to allow global variables to be reached through function calls when
   required (if a shared library version requires it, for example.
   The way it's done allows definitions like this:

        // in foobar.c
        OPENSSL_IMPLEMENT_GLOBAL(int,foobar,0)
        // in foobar.h
        OPENSSL_DECLARE_GLOBAL(int,foobar);
        #define foobar OPENSSL_GLOBAL_REF(foobar)
*/
# 291 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h"





















# 63 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h" 2






# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 1
/* crypto/crypto.h */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */






# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 123 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2





# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/stack.h" 1
/* crypto/stack/stack.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */








typedef struct stack_st
        {
        int num;
        char **data;
        int sorted;

        int num_alloc;
        int (*comp)(const void *, const void *);
        } _STACK;  /* Use STACK_OF(...) instead */




int sk_num(const _STACK *);
void *sk_value(const _STACK *, int);

void *sk_set(_STACK *, int, void *);

_STACK *sk_new(int (*cmp)(const void *, const void *));
_STACK *sk_new_null(void);
void sk_free(_STACK *);
void sk_pop_free(_STACK *st, void (*func)(void *));
int sk_insert(_STACK *sk, void *data, int where);
void *sk_delete(_STACK *st, int loc);
void *sk_delete_ptr(_STACK *st, void *p);
int sk_find(_STACK *st, void *data);
int sk_find_ex(_STACK *st, void *data);
int sk_push(_STACK *st, void *data);
int sk_unshift(_STACK *st, void *data);
void *sk_shift(_STACK *st);
void *sk_pop(_STACK *st);
void sk_zero(_STACK *st);
int (*sk_set_cmp_func(_STACK *sk, int (*c)(const void *, const void *)))
        (const void *, const void *);
_STACK *sk_dup(_STACK *st);
void sk_sort(_STACK *st);
int sk_is_sorted(const _STACK *st);





# 129 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h" 1
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */















/* In C++ we get problems because an explicit cast is needed from (void *)
 * we use CHECKED_STACK_OF to ensure the correct type is passed in the macros
 * below. 
 */

















# 100 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"




/* Strings are special: normally an lhash entry will point to a single
 * (somewhat) mutable object. In the case of strings:
 *
 * a) Instead of a single char, there is an array of chars, NUL-terminated.
 * b) The string may have be immutable.
 *
 * So, they need their own declarations. Especially important for
 * type-checking tools, such as Deputy.
 *
o * In practice, however, it appears to be hard to have a const
 * string. For now, I'm settling for dealing with the fact it is a
 * string at all.
 */
typedef char *OPENSSL_STRING;

typedef const char *OPENSSL_CSTRING;

/* Confusingly, LHASH_OF(STRING) deals with char ** throughout, but
 * STACK_OF(STRING) is really more like STACK_OF(char), only, as
 * mentioned above, instead of a single char each entry is a
 * NUL-terminated array of chars. So, we have to implement STRING
 * specially for STACK_OF. This is dealt with in the autogenerated
 * macros below.
 */

struct stack_st_OPENSSL_STRING { _STACK stack; };

/* Similarly, we sometimes use a block of characters, NOT
 * nul-terminated. These should also be distinguished from "normal"
 * stacks. */

typedef void *OPENSSL_BLOCK;
struct stack_st_OPENSSL_BLOCK { _STACK stack; };

/* SKM_sk_... stack macros are internal to safestack.h:
 * never use them directly, use sk_<type>_... instead */
# 184 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 192 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"



















/* This block of defines is updated by util/mkstack.pl, please do not touch! */
# 233 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 255 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 277 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 299 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 321 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 343 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 365 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 387 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 409 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 431 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 453 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 475 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 497 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 519 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 541 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 563 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 585 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 607 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 629 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 651 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 673 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 695 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 717 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 739 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 761 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 783 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 805 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 827 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 849 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 871 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 893 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 915 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 937 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 959 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 981 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1003 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1025 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1047 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1069 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1091 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1113 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1135 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1157 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1179 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1201 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1223 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1245 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1267 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1289 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1311 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1333 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1355 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1377 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1399 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1421 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1443 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1465 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1487 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1509 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1531 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1553 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1575 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1597 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1619 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1641 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1663 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1685 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1707 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1729 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1751 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1773 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1795 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1817 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1839 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1861 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1883 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1905 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1927 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1949 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1971 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 1993 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2015 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2037 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2059 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2081 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2103 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2125 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2149 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"


# 2174 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"


# 2199 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"


# 2209 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2218 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2227 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2236 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2245 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2254 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2263 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2272 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2281 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2290 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2299 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2308 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2317 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2326 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2335 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2344 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2353 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2362 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2371 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2380 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2389 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2398 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2407 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2416 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2425 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"







# 2449 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2467 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2485 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2503 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2521 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2539 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2557 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2575 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2593 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2611 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2629 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2647 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"

# 2665 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/safestack.h"
/* End of util/mkstack.pl block, you may now edit :-) */


# 130 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/opensslv.h" 1







/* Numeric release version identifier:
 * MNNFFPPS: major minor fix patch status
 * The status nibble has one of the values 0 for development, 1 to e for betas
 * 1 to 14, and f for release.  The patch level is exactly that.
 * For example:
 * 0.9.3-dev      0x00903000
 * 0.9.3-beta1    0x00903001
 * 0.9.3-beta2-dev 0x00903002
 * 0.9.3-beta2    0x00903002 (same as ...beta2-dev)
 * 0.9.3          0x0090300f
 * 0.9.3a         0x0090301f
 * 0.9.4          0x0090400f
 * 1.2.3z         0x102031af
 *
 * For continuity reasons (because 0.9.5 is already out, and is coded
 * 0x00905100), between 0.9.5 and 0.9.6 the coding of the patch level
 * part is slightly different, by setting the highest bit.  This means
 * that 0.9.5a looks like this: 0x0090581f.  At 0.9.6, we can start
 * with 0x0090600S...
 *
 * (Prior to 0.9.3-dev a different scheme was used: 0.9.2b is 0x0922.)
 * (Prior to 0.9.5a beta1, a different scheme was used: MMNNFFRBB for
 *  major minor fix final patch/beta)
 */
# 39 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/opensslv.h"


/* The macros below are to be used for shared library (.so, .dll, ...)
 * versioning.  That kind of versioning works a bit differently between
 * operating systems.  The most usual scheme is to set a major and a minor
 * number, and have the runtime loader check that the major number is equal
 * to what it was at application link time, while the minor number has to
 * be greater or equal to what it was at application link time.  With this
 * scheme, the version number is usually part of the file name, like this:
 *
 *      libcrypto.so.0.9
 *
 * Some unixen also make a softlink with the major verson number only:
 *
 *      libcrypto.so.0
 *
 * On Tru64 and IRIX 6.x it works a little bit differently.  There, the
 * shared library version is stored in the file, and is actually a series
 * of versions, separated by colons.  The rightmost version present in the
 * library when linking an application is stored in the application to be
 * matched at run time.  When the application is run, a check is done to
 * see if the library version stored in the application matches any of the
 * versions in the version string of the library itself.
 * This version string can be constructed in any way, depending on what
 * kind of matching is desired.  However, to implement the same scheme as
 * the one used in the other unixen, all compatible versions, from lowest
 * to highest, should be part of the string.  Consecutive builds would
 * give the following versions strings:
 *
 *      3.0
 *      3.0:3.1
 *      3.0:3.1:3.2
 *      4.0
 *      4.0:4.1
 *
 * Notice how version 4 is completely incompatible with version, and
 * therefore give the breach you can see.
 *
 * There may be other schemes as well that I haven't yet discovered.
 *
 * So, here's the way it works here: first of all, the library version
 * number doesn't need at all to match the overall OpenSSL version.
 * However, it's nice and more understandable if it actually does.
 * The current library version is stored in the macro SHLIB_VERSION_NUMBER,
 * which is just a piece of text in the format "M.m.e" (Major, minor, edit).
 * For the sake of Tru64, IRIX, and any other OS that behaves in similar ways,
 * we need to keep a history of version numbers, which is done in the
 * macro SHLIB_VERSION_HISTORY.  The numbers are separated by colons and
 * should only keep the versions that are binary compatible with the current.
 */




# 131 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ossl_typ.h" 1
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */








# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 63 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ossl_typ.h" 2

# 83 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
typedef struct asn1_string_st ASN1_ENUMERATED;
typedef struct asn1_string_st ASN1_BIT_STRING;
typedef struct asn1_string_st ASN1_OCTET_STRING;
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
typedef struct asn1_string_st ASN1_T61STRING;
typedef struct asn1_string_st ASN1_IA5STRING;
typedef struct asn1_string_st ASN1_GENERALSTRING;
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
typedef struct asn1_string_st ASN1_BMPSTRING;
typedef struct asn1_string_st ASN1_UTCTIME;
typedef struct asn1_string_st ASN1_TIME;
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
typedef struct asn1_string_st ASN1_VISIBLESTRING;
typedef struct asn1_string_st ASN1_UTF8STRING;
typedef struct asn1_string_st ASN1_STRING;
typedef int ASN1_BOOLEAN;
typedef int ASN1_NULL;


typedef struct ASN1_ITEM_st ASN1_ITEM;
typedef struct asn1_pctx_st ASN1_PCTX;

# 114 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ossl_typ.h"




typedef struct bignum_st BIGNUM;
typedef struct bignum_ctx BN_CTX;
typedef struct bn_blinding_st BN_BLINDING;
typedef struct bn_mont_ctx_st BN_MONT_CTX;
typedef struct bn_recp_ctx_st BN_RECP_CTX;
typedef struct bn_gencb_st BN_GENCB;

typedef struct buf_mem_st BUF_MEM;

typedef struct evp_cipher_st EVP_CIPHER;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
typedef struct env_md_st EVP_MD;
typedef struct env_md_ctx_st EVP_MD_CTX;
typedef struct evp_pkey_st EVP_PKEY;

typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;

typedef struct evp_pkey_method_st EVP_PKEY_METHOD;
typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef struct dh_st DH;
typedef struct dh_method DH_METHOD;

typedef struct dsa_st DSA;
typedef struct dsa_method DSA_METHOD;

typedef struct rsa_st RSA;
typedef struct rsa_meth_st RSA_METHOD;

typedef struct rand_meth_st RAND_METHOD;

typedef struct ecdh_method ECDH_METHOD;
typedef struct ecdsa_method ECDSA_METHOD;

typedef struct x509_st X509;
typedef struct X509_algor_st X509_ALGOR;
typedef struct X509_crl_st X509_CRL;
typedef struct x509_crl_method_st X509_CRL_METHOD;
typedef struct x509_revoked_st X509_REVOKED;
typedef struct X509_name_st X509_NAME;
typedef struct X509_pubkey_st X509_PUBKEY;
typedef struct x509_store_st X509_STORE;
typedef struct x509_store_ctx_st X509_STORE_CTX;

typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;

typedef struct v3_ext_ctx X509V3_CTX;
typedef struct conf_st CONF;

typedef struct store_st STORE;
typedef struct store_method_st STORE_METHOD;

typedef struct ui_st UI;
typedef struct ui_method_st UI_METHOD;

typedef struct st_ERR_FNS ERR_FNS;

typedef struct engine_st ENGINE;
typedef struct ssl_st SSL;
typedef struct ssl_ctx_st SSL_CTX;

typedef struct X509_POLICY_NODE_st X509_POLICY_NODE;
typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL;
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;

typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;
typedef struct DIST_POINT_st DIST_POINT;
typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;
typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;

  /* If placed in pkcs12.h, we end up with a circular depency with pkcs7.h */



typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
/* Callback types for crypto.h */
typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                                        int idx, long argl, void *argp);
typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                                        int idx, long argl, void *argp);
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, 
                                        int idx, long argl, void *argp);

typedef struct ocsp_req_ctx_st OCSP_REQ_CTX;
typedef struct ocsp_response_st OCSP_RESPONSE;
typedef struct ocsp_responder_id_st OCSP_RESPID;

# 132 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2





/* Resolve problems on some operating systems with symbol names that clash
   one way or another */
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/symhacks.h" 1
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 59 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/symhacks.h" 2

/* Hacks to solve the problem with linkers incapable of handling very long
   symbol names.  In the case of VMS, the limit is 31 characters on VMS for
   VAX. */
/* Note that this affects util/libeay.num and util/ssleay.num...  you may
   change those manually, but that's not recommended, as those files are
   controlled centrally and updated on Unix, and the central definition
   may disagree with yours, which in turn may come with shareable library
   incompatibilities. */
# 441 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/symhacks.h"


/* Case insensitive linking causes problems.... */
# 479 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/symhacks.h"


# 140 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h" 2





/* Backward compatibility to SSLeay */
/* This is more to be used to check the correct DLL is being used
 * in the MS world. */


/* #define SSLEAY_OPTIONS       1 no longer supported */





/* Already declared in ossl_typ.h */
# 169 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

/* A generic structure to pass assorted data in a expandable way */
typedef struct openssl_item_st
        {
        int code;
        void *value;            /* Not used for flag attributes */
        size_t value_size;      /* Max size of value for output, length for input */
        size_t *value_length;   /* Returned length of value for output */
        } OPENSSL_ITEM;


/* When changing the CRYPTO_LOCK_* list, be sure to maintin the text lock
 * names in cryptlib.c
 */

# 225 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"






# 251 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

/* Some applications as well as some parts of OpenSSL need to allocate
   and deallocate locks in a dynamic fashion.  The following typedef
   makes this possible in a type-safe manner.  */
/* struct CRYPTO_dynlock_value has to be defined by the application. */
typedef struct
        {
        int references;
        struct CRYPTO_dynlock_value *data;
        } CRYPTO_dynlock;


/* The following can be used to detect memory leaks in the SSLeay library.
 * It used, it turns on malloc checking */






/* The following are bit values to turn on or off options connected to the
 * malloc checking functionality */

/* Adds time to the memory checking information */

/* Adds thread number to the memory checking information */





/* predec of the BIO type */
typedef struct bio_st BIO_dummy;

struct crypto_ex_data_st
        {
        struct stack_st_void *sk;
        int dummy; /* gcc is screwing up this data structure :-( */
        };
struct stack_st_void { _STACK stack; };

/* This stuff is basically class callback functions
 * The current classes are SSL_CTX, SSL, SSL_SESSION, and a few more */

typedef struct crypto_ex_data_func_st
        {
        long argl;      /* Arbitary long */
        void *argp;     /* Arbitary void * */
        CRYPTO_EX_new *new_func;
        CRYPTO_EX_free *free_func;
        CRYPTO_EX_dup *dup_func;
        } CRYPTO_EX_DATA_FUNCS;

struct stack_st_CRYPTO_EX_DATA_FUNCS { _STACK stack; };

/* Per class, we have a STACK of CRYPTO_EX_DATA_FUNCS for each CRYPTO_EX_DATA
 * entry.
 */

# 326 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

/* Dynamically assigned indexes start from this value (don't use directly, use
 * via CRYPTO_ex_data_new_class). */



/* This is the default callbacks, but we can have others as well:
 * this is needed in Win32 where the application malloc and the
 * library malloc may not be the same.
 */









/* Set standard debugging functions (not done by default
 * unless CRYPTO_MDEBUG is defined) */
# 355 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

int CRYPTO_mem_ctrl(int mode);
int CRYPTO_is_mem_check_on(void);

/* for applications */



/* for library-internal use */




# 378 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"






const char *SSLeay_version(int type);
unsigned long SSLeay(void);

int OPENSSL_issetugid(void);

/* An opaque type representing an implementation of "ex_data" support */
typedef struct st_CRYPTO_EX_DATA_IMPL   CRYPTO_EX_DATA_IMPL;
/* Return an opaque pointer to the current "ex_data" implementation */
const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);
/* Sets the "ex_data" implementation to be used (if it's not too late) */
int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);
/* Get a new "ex_data" class, and return the corresponding "class_index" */
int CRYPTO_ex_data_new_class(void);
/* Within a given class, get/register a new index */
int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
                CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
                CRYPTO_EX_free *free_func);
/* Initialise/duplicate/free CRYPTO_EX_DATA variables corresponding to a given
 * class (invokes whatever per-class callbacks are applicable) */
int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
                CRYPTO_EX_DATA *from);
void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
/* Get/set data in a CRYPTO_EX_DATA variable corresponding to a particular index
 * (relative to the class type involved) */
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad,int idx);
/* This function cleans up all "ex_data" state. It mustn't be called under
 * potential race-conditions. */
void CRYPTO_cleanup_all_ex_data(void);

int CRYPTO_get_new_lockid(char *name);

int CRYPTO_num_locks(void); /* return CRYPTO_NUM_LOCKS (shared libs!) */
void CRYPTO_lock(int mode, int type,const char *file,int line);
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,
                                              const char *file,int line));
void (*CRYPTO_get_locking_callback(void))(int mode,int type,const char *file,
                int line);
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,
                                              const char *file, int line));
int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,int type,
                                          const char *file,int line);

/* Don't use this structure directly. */
typedef struct crypto_threadid_st
        {
        void *ptr;
        unsigned long val;
        } CRYPTO_THREADID;
/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */
void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);
void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);
int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));
void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);
void CRYPTO_THREADID_current(CRYPTO_THREADID *id);
int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b);
void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src);
unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);

void CRYPTO_set_id_callback(unsigned long (*func)(void));
unsigned long (*CRYPTO_get_id_callback(void))(void);
unsigned long CRYPTO_thread_id(void);


const char *CRYPTO_get_lock_name(int type);
int CRYPTO_add_lock(int *pointer,int amount,int type, const char *file,
                    int line);

int CRYPTO_get_new_dynlockid(void);
void CRYPTO_destroy_dynlockid(int i);
struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i);
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*dyn_create_function)(const char *file, int line));
void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line));
void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)(struct CRYPTO_dynlock_value *l, const char *file, int line));
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))(const char *file,int line);
void (*CRYPTO_get_dynlock_lock_callback(void))(int mode, struct CRYPTO_dynlock_value *l, const char *file,int line);
void (*CRYPTO_get_dynlock_destroy_callback(void))(struct CRYPTO_dynlock_value *l, const char *file,int line);

/* CRYPTO_set_mem_functions includes CRYPTO_set_locked_mem_functions --
 * call the latter last if you need different functions */
int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*free_func)(void *));
int CRYPTO_set_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                void *(*r)(void *,size_t,const char *,int),
                                void (*f)(void *));
int CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                       void (*free_func)(void *));
int CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),
                                   void (*r)(void *,void *,int,const char *,int,int),
                                   void (*f)(void *,int),
                                   void (*so)(long),
                                   long (*go)(void));
void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *));
void CRYPTO_get_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                 void *(**r)(void *, size_t,const char *,int),
                                 void (**f)(void *));
void CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                        void (**f)(void *));
void CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),
                                    void (**r)(void *,void *,int,const char *,int,int),
                                    void (**f)(void *,int),
                                    void (**so)(long),
                                    long (**go)(void));

void *CRYPTO_malloc_locked(int num, const char *file, int line);
void CRYPTO_free_locked(void *ptr);
void *CRYPTO_malloc(int num, const char *file, int line);
char *CRYPTO_strdup(const char *str, const char *file, int line);
void CRYPTO_free(void *ptr);
void *CRYPTO_realloc(void *addr,int num, const char *file, int line);
void *CRYPTO_realloc_clean(void *addr,int old_num,int num,const char *file,
                           int line);
void *CRYPTO_remalloc(void *addr,int num, const char *file, int line);

void OPENSSL_cleanse(void *ptr, size_t len);

void CRYPTO_set_mem_debug_options(long bits);
long CRYPTO_get_mem_debug_options(void);



int CRYPTO_push_info_(const char *info, const char *file, int line);
int CRYPTO_pop_info(void);
int CRYPTO_remove_all_info(void);


/* Default debugging functions (enabled by CRYPTO_malloc_debug_init() macro;
 * used as default in CRYPTO_MDEBUG compilations): */
/* The last argument has the following significance:
 *
 * 0:   called before the actual memory allocation has taken place
 * 1:   called after the actual memory allocation has taken place
 */
void CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_free(void *addr,int before_p);
/* Tell the debugging code about options.  By default, the following values
 * apply:
 *
 * 0:                           Clear all options.
 * V_CRYPTO_MDEBUG_TIME (1):    Set the "Show Time" option.
 * V_CRYPTO_MDEBUG_THREAD (2):  Set the "Show Thread Number" option.
 * V_CRYPTO_MDEBUG_ALL (3):     1 + 2
 */
void CRYPTO_dbg_set_options(long bits);
long CRYPTO_dbg_get_options(void);



void CRYPTO_mem_leaks_fp(FILE *);

void CRYPTO_mem_leaks(struct bio_st *bio);
/* unsigned long order, char *file, int line, int num_bytes, char *addr */
typedef void *CRYPTO_MEM_LEAK_CB(unsigned long, const char *, int, int, void *);
void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb);

/* die if we have to */
void OpenSSLDie(const char *file,int line,const char *assertion);


unsigned long *OPENSSL_ia32cap_loc(void);

int OPENSSL_isservice(void);

int FIPS_mode(void);
int FIPS_mode_set(int r);

void OPENSSL_init(void);



# 576 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

/* CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal. It
 * takes an amount of time dependent on |len|, but independent of the contents
 * of |a| and |b|. Unlike memcmp, it cannot be used to put elements into a
 * defined order as the return value when a != b is undefined, other than to be
 * non-zero. */
int CRYPTO_memcmp(const void *a, const void *b, size_t len);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_CRYPTO_strings(void);

/* Error codes for the CRYPTO functions. */

/* Function codes. */
# 603 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/crypto.h"

/* Reason codes. */



# 70 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h" 2

# 78 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"





/* These are the 'types' of BIOs */




# 111 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"





/* BIO_FILENAME_READ|BIO_CLOSE to open or close on free.
 * BIO_set_fp(in,stdin,BIO_NOCLOSE); */



/* These are used in the following macros and are passed to
 * BIO_ctrl() */
# 136 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"
/* callback is int cb(BIO *bio,state,ret); */





/* dgram BIO stuff */
# 151 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"



                                        
/* #ifdef IP_MTU_DISCOVER */

/* #endif */

# 166 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"















/* SCTP stuff */
# 194 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* modifiers */





# 207 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"
/* "UPLINK" flag denotes file descriptors provided by application.
   It defaults to 0, as most platforms don't require UPLINK interface. */



/* Used in BIO_gethostbyname() */






/* Mostly used in the SSL BIO */
/* Not used anymore
 * #define BIO_FLAGS_PROTOCOL_DELAYED_READ 0x10
 * #define BIO_FLAGS_PROTOCOL_DELAYED_WRITE 0x20
 * #define BIO_FLAGS_PROTOCOL_STARTUP   0x40
 */



/* This is used with memory BIOs: it means we shouldn't free up or change the
 * data in any way.
 */


typedef struct bio_st BIO;

void BIO_set_flags(BIO *b, int flags);
int  BIO_test_flags(const BIO *b, int flags);
void BIO_clear_flags(BIO *b, int flags);

# 246 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* These are normally used internally in BIOs */





/* These should be used by the application to tell why we should retry */






/* The next three are used in conjunction with the
 * BIO_should_io_special() condition.  After this returns true,
 * BIO *BIO_get_retry_BIO(BIO *bio, int *reason); will walk the BIO 
 * stack and return the 'reason' for the special and the offending BIO.
 * Given a BIO, BIO_get_retry_reason(bio) will return the code. */
/* Returned from the SSL bio when the certificate retrieval code had an error */

/* Returned from the connect BIO when a connect would have blocked */

/* Returned from the accept BIO when an accept would have blocked */


/* These are passed by the BIO callback */
# 279 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* The callback is called before and after the underling operation,
 * The BIO_CB_RETURN flag indicates if it is after the call */





long (*BIO_get_callback(const BIO *b)) (struct bio_st *,int,const char *,int, long,long);
void BIO_set_callback(BIO *b, 
        long (*callback)(struct bio_st *,int,const char *,int, long,long));
char *BIO_get_callback_arg(const BIO *b);
void BIO_set_callback_arg(BIO *b, char *arg);

const char * BIO_method_name(const BIO *b);
int BIO_method_type(const BIO *b);

typedef void bio_info_cb(struct bio_st *, int, const char *, int, long, long);

typedef struct bio_method_st
        {
        int type;
        const char *name;
        int (*bwrite)(BIO *, const char *, int);
        int (*bread)(BIO *, char *, int);
        int (*bputs)(BIO *, const char *);
        int (*bgets)(BIO *, char *, int);
        long (*ctrl)(BIO *, int, long, void *);
        int (*create)(BIO *);
        int (*destroy)(BIO *);
        long (*callback_ctrl)(BIO *, int, bio_info_cb *);
        } BIO_METHOD;

struct bio_st
        {
        BIO_METHOD *method;
        /* bio, mode, argp, argi, argl, ret */
        long (*callback)(struct bio_st *,int,const char *,int, long,long);
        char *cb_arg; /* first argument for the callback */

        int init;
        int shutdown;
        int flags;      /* extra storage */
        int retry_reason;
        int num;
        void *ptr;
        struct bio_st *next_bio;        /* used by filter BIOs */
        struct bio_st *prev_bio;        /* used by filter BIOs */
        int references;
        unsigned long num_read;
        unsigned long num_write;

        CRYPTO_EX_DATA ex_data;
        };

struct stack_st_BIO { _STACK stack; };

typedef struct bio_f_buffer_ctx_struct
        {
        /* Buffers are setup like this:
         *
         * <---------------------- size ----------------------->
         * +---------------------------------------------------+
         * | consumed | remaining          | free space        |
         * +---------------------------------------------------+
         * <-- off --><------- len ------->
         */

        /* BIO *bio; */ /* this is now in the BIO struct */
        int ibuf_size;  /* how big is the input buffer */
        int obuf_size;  /* how big is the output buffer */

        char *ibuf;             /* the char array */
        int ibuf_len;           /* how many bytes are in it */
        int ibuf_off;           /* write/read offset */

        char *obuf;             /* the char array */
        int obuf_len;           /* how many bytes are in it */
        int obuf_off;           /* write/read offset */
        } BIO_F_BUFFER_CTX;

/* Prefix and suffix callback in ASN1 BIO */
typedef int asn1_ps_func(BIO *b, unsigned char **pbuf, int *plen, void *parg);


/* SCTP parameter structs */
struct bio_dgram_sctp_sndinfo
        {
        uint16_t snd_sid;
        uint16_t snd_flags;
        uint32_t snd_ppid;
        uint32_t snd_context;
        };

struct bio_dgram_sctp_rcvinfo
        {
        uint16_t rcv_sid;
        uint16_t rcv_ssn;
        uint16_t rcv_flags;
        uint32_t rcv_ppid;
        uint32_t rcv_tsn;
        uint32_t rcv_cumtsn;
        uint32_t rcv_context;
        };

struct bio_dgram_sctp_prinfo
        {
        uint16_t pr_policy;
        uint32_t pr_value;
        };


/* connect BIO stuff */
# 400 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"
/*#define BIO_CONN_get_param_hostname   BIO_ctrl */

# 438 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

# 452 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"












/* BIO_s_connect() and BIO_s_socks4a_connect() */
# 473 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"




/* BIO_s_accept_socket() */


/* #define BIO_set_nbio(b,n)    BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL) */













/* BIO_s_proxy_client() */


/* BIO_set_nbio(b,n) */

/* BIO *BIO_get_filter_bio(BIO *bio); */


















/* name is cast to lose const, but might be better to route through a function
   so we can do it safely */
# 535 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* WARNING WARNING, this ups the reference count on the read bio of the
 * SSL structure.  This is because the ssl read BIO is now pointed to by
 * the next_bio field in the bio.  So when you free the BIO, make sure
 * you are doing a BIO_free_all() to catch the underlying BIO. */
# 549 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* defined in evp.h */
/* #define BIO_set_md(b,md)     BIO_ctrl(b,BIO_C_SET_MD,1,(char *)md) */







/* For the BIO_f_buffer() type */






/* Don't use the next one unless you know what you are doing :-) */


# 575 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"
/* ...pending macros have inappropriate return type */
size_t BIO_ctrl_pending(BIO *b);
size_t BIO_ctrl_wpending(BIO *b);





/* For the BIO_f_buffer() type */


/* For BIO_s_bio() */





/* macros with inappropriate type -- but ...pending macros use int too: */


size_t BIO_ctrl_get_write_guarantee(BIO *b);
size_t BIO_ctrl_get_read_request(BIO *b);
int BIO_ctrl_reset_read_request(BIO *b);

/* ctrl macros for dgram */
# 614 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* These two aren't currently implemented */
/* int BIO_get_ex_num(BIO *bio); */
/* void BIO_set_ex_free_func(BIO *bio,int idx,void (*cb)()); */
int BIO_set_ex_data(BIO *bio,int idx,void *data);
void *BIO_get_ex_data(BIO *bio,int idx);
int BIO_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
unsigned long BIO_number_read(BIO *bio);
unsigned long BIO_number_written(BIO *bio);

/* For BIO_f_asn1() */
int BIO_asn1_set_prefix(BIO *b, asn1_ps_func *prefix,
                                        asn1_ps_func *prefix_free);
int BIO_asn1_get_prefix(BIO *b, asn1_ps_func **pprefix,
                                        asn1_ps_func **pprefix_free);
int BIO_asn1_set_suffix(BIO *b, asn1_ps_func *suffix,
                                        asn1_ps_func *suffix_free);
int BIO_asn1_get_suffix(BIO *b, asn1_ps_func **psuffix,
                                        asn1_ps_func **psuffix_free);


BIO_METHOD *BIO_s_file(void );
BIO *BIO_new_file(const char *filename, const char *mode);
BIO *BIO_new_fp(FILE *stream, int close_flag);


BIO *   BIO_new(BIO_METHOD *type);
int     BIO_set(BIO *a,BIO_METHOD *type);
int     BIO_free(BIO *a);
void    BIO_vfree(BIO *a);
int     BIO_read(BIO *b, void *data, int len);
int     BIO_gets(BIO *bp,char *buf, int size);
int     BIO_write(BIO *b, const void *data, int len);
int     BIO_puts(BIO *bp,const char *buf);
int     BIO_indent(BIO *b,int indent,int max);
long    BIO_ctrl(BIO *bp,int cmd,long larg,void *parg);
long BIO_callback_ctrl(BIO *b, int cmd, void (*fp)(struct bio_st *, int, const char *, int, long, long));
char *  BIO_ptr_ctrl(BIO *bp,int cmd,long larg);
long    BIO_int_ctrl(BIO *bp,int cmd,long larg,int iarg);
BIO *   BIO_push(BIO *b,BIO *append);
BIO *   BIO_pop(BIO *b);
void    BIO_free_all(BIO *a);
BIO *   BIO_find_type(BIO *b,int bio_type);
BIO *   BIO_next(BIO *b);
BIO *   BIO_get_retry_BIO(BIO *bio, int *reason);
int     BIO_get_retry_reason(BIO *bio);
BIO *   BIO_dup_chain(BIO *in);

int BIO_nread0(BIO *bio, char **buf);
int BIO_nread(BIO *bio, char **buf, int num);
int BIO_nwrite0(BIO *bio, char **buf);
int BIO_nwrite(BIO *bio, char **buf, int num);

long BIO_debug_callback(BIO *bio,int cmd,const char *argp,int argi,
        long argl,long ret);

BIO_METHOD *BIO_s_mem(void);
BIO *BIO_new_mem_buf(void *buf, int len);
BIO_METHOD *BIO_s_socket(void);
BIO_METHOD *BIO_s_connect(void);
BIO_METHOD *BIO_s_accept(void);
BIO_METHOD *BIO_s_fd(void);

BIO_METHOD *BIO_s_log(void);

BIO_METHOD *BIO_s_bio(void);
BIO_METHOD *BIO_s_null(void);
BIO_METHOD *BIO_f_null(void);
BIO_METHOD *BIO_f_buffer(void);



BIO_METHOD *BIO_f_nbio_test(void);

BIO_METHOD *BIO_s_datagram(void);

BIO_METHOD *BIO_s_datagram_sctp(void);



/* BIO_METHOD *BIO_f_ber(void); */

int BIO_sock_should_retry(int i);
int BIO_sock_non_fatal_error(int error);
int BIO_dgram_non_fatal_error(int error);

int BIO_fd_should_retry(int i);
int BIO_fd_non_fatal_error(int error);
int BIO_dump_cb(int (*cb)(const void *data, size_t len, void *u),
                void *u, const char *s, int len);
int BIO_dump_indent_cb(int (*cb)(const void *data, size_t len, void *u),
                       void *u, const char *s, int len, int indent);
int BIO_dump(BIO *b,const char *bytes,int len);
int BIO_dump_indent(BIO *b,const char *bytes,int len,int indent);

int BIO_dump_fp(FILE *fp, const char *s, int len);
int BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent);

struct hostent *BIO_gethostbyname(const char *name);
/* We might want a thread-safe interface too:
 * struct hostent *BIO_gethostbyname_r(const char *name,
 *     struct hostent *result, void *buffer, size_t buflen);
 * or something similar (caller allocates a struct hostent,
 * pointed to by "result", and additional buffer space for the various
 * substructures; if the buffer does not suffice, NULL is returned
 * and an appropriate error code is set).
 */
int BIO_sock_error(int sock);
int BIO_socket_ioctl(int fd, long type, void *arg);
int BIO_socket_nbio(int fd,int mode);
int BIO_get_port(const char *str, unsigned short *port_ptr);
int BIO_get_host_ip(const char *str, unsigned char *ip);
int BIO_get_accept_socket(char *host_port,int mode);
int BIO_accept(int sock,char **ip_port);
int BIO_sock_init(void );
void BIO_sock_cleanup(void);
int BIO_set_tcp_ndelay(int sock,int turn_on);

BIO *BIO_new_socket(int sock, int close_flag);
BIO *BIO_new_dgram(int fd, int close_flag);

BIO *BIO_new_dgram_sctp(int fd, int close_flag);
int BIO_dgram_is_sctp(BIO *bio);
int BIO_dgram_sctp_notification_cb(BIO *b,
                                   void (*handle_notifications)(BIO *bio, void *context, void *buf),
                                   void *context);
int BIO_dgram_sctp_wait_for_dry(BIO *b);
int BIO_dgram_sctp_msg_waiting(BIO *b);

BIO *BIO_new_fd(int fd, int close_flag);
BIO *BIO_new_connect(char *host_port);
BIO *BIO_new_accept(char *host_port);

int BIO_new_bio_pair(BIO **bio1, size_t writebuf1,
        BIO **bio2, size_t writebuf2);
/* If successful, returns 1 and in *bio1, *bio2 two BIO pair endpoints.
 * Otherwise returns 0 and sets *bio1 and *bio2 to NULL.
 * Size 0 uses default value.
 */

void BIO_copy_next_retry(BIO *b);

/*long BIO_ghbn_ctrl(int cmd,int iarg,char *parg);*/






int BIO_printf(BIO *bio, const char *format, ...)
        ;
int BIO_vprintf(BIO *bio, const char *format, va_list args)
        ;
int BIO_snprintf(char *buf, size_t n, const char *format, ...)
        ;
int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
        ;


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_BIO_strings(void);

/* Error codes for the BIO functions. */

/* Function codes. */
# 816 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

/* Reason codes. */
# 847 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bio.h"

# 25 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 1
/* ssl/ssl.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 147 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2

# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/comp.h" 1










typedef struct comp_ctx_st COMP_CTX;

typedef struct comp_method_st
        {
        int type;               /* NID for compression library */
        const char *name;       /* A text string to identify the library */
        int (*init)(COMP_CTX *ctx);
        void (*finish)(COMP_CTX *ctx);
        int (*compress)(COMP_CTX *ctx,
                        unsigned char *out, unsigned int olen,
                        unsigned char *in, unsigned int ilen);
        int (*expand)(COMP_CTX *ctx,
                      unsigned char *out, unsigned int olen,
                      unsigned char *in, unsigned int ilen);
        /* The following two do NOTHING, but are kept for backward compatibility */
        long (*ctrl)(void);
        long (*callback_ctrl)(void);
        } COMP_METHOD;

struct comp_ctx_st
        {
        COMP_METHOD *meth;
        unsigned long compress_in;
        unsigned long compress_out;
        unsigned long expand_in;
        unsigned long expand_out;

        CRYPTO_EX_DATA  ex_data;
        };


COMP_CTX *COMP_CTX_new(COMP_METHOD *meth);
void COMP_CTX_free(COMP_CTX *ctx);
int COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,
        unsigned char *in, int ilen);
int COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,
        unsigned char *in, int ilen);
COMP_METHOD *COMP_rle(void );
COMP_METHOD *COMP_zlib(void );
void COMP_zlib_cleanup(void);







/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_COMP_strings(void);

/* Error codes for the COMP functions. */

/* Function codes. */





/* Reason codes. */




# 150 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 1
/* crypto/x509/x509.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 68 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/buffer.h" 1
/* crypto/buffer/buffer.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
















/* Already declared in ossl_typ.h */
/* typedef struct buf_mem_st BUF_MEM; */

struct buf_mem_st
        {
        size_t length;  /* current number of bytes */
        char *data;
        size_t max;     /* size of buffer */
        };

BUF_MEM *BUF_MEM_new(void);
void    BUF_MEM_free(BUF_MEM *a);
int     BUF_MEM_grow(BUF_MEM *str, size_t len);
int     BUF_MEM_grow_clean(BUF_MEM *str, size_t len);
char *  BUF_strdup(const char *str);
char *  BUF_strndup(const char *str, size_t siz);
void *  BUF_memdup(const void *data, size_t siz);
void    BUF_reverse(unsigned char *out, const unsigned char *in, size_t siz);

/* safe string functions */
size_t BUF_strlcpy(char *dst,const char *src,size_t siz);
size_t BUF_strlcat(char *dst,const char *src,size_t siz);


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_BUF_strings(void);

/* Error codes for the BUF functions. */

/* Function codes. */
# 113 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/buffer.h"

/* Reason codes. */

# 71 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h" 1
/* crypto/evp/evp.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 69 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"









/*
#define EVP_RC2_KEY_SIZE                16
#define EVP_RC4_KEY_SIZE                16
#define EVP_BLOWFISH_KEY_SIZE           16
#define EVP_CAST5_KEY_SIZE              16
#define EVP_RC5_32_12_16_KEY_SIZE       16
*/






/* Default PKCS#5 iteration count */


# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h" 1
/* crypto/objects/objects.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */






# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/obj_mac.h" 1
/* crypto/objects/obj_mac.h */

/* THIS FILE IS GENERATED FROM objects.txt by objects.pl via the
 * following command:
 * perl objects.pl objects.txt obj_mac.num obj_mac.h
 */

/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































# 66 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h" 2
# 958 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h" 1
/* crypto/asn1/asn1.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.23 Date and time    <time.h>
 */













/* Get size_t and NULL from <stddef.h>.  */




/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h" 1
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

# 37 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"





/* ISO/IEC 9899:1999 7.23.1: Components of time
   The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
   the number per second of the value returned by the `clock' function.  */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */


# 58 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"


/* Identifier for system-wide realtime clock.  */

/* Monotonic system-wide clock.  */

/* High-resolution timer from the CPU.  */

/* Thread-specific CPU-time clock.  */

/* Monotonic system-wide clock, not adjusted for frequency scaling.  */

/* Identifier for system-wide realtime clock, updated only on ticks.  */

/* Monotonic system-wide clock, updated only on ticks.  */

/* Monotonic system-wide clock that includes time spent in suspension.  */

/* Like CLOCK_REALTIME but also wakes suspended system.  */

/* Like CLOCK_BOOTTIME but also wakes suspended system.  */

/* Like CLOCK_REALTIME but in International Atomic Time.  */


/* Flag to indicate time is absolute.  */



# 97 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"




# 42 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h" 2

/* This is the obsolete POSIX.1-1988 name for the same constant.  */








# 67 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 83 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 95 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 107 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


# 128 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"




/* Used by other time functions.  */
struct tm
{
  int tm_sec;                   /* Seconds.     [0-60] (1 leap second) */
  int tm_min;                   /* Minutes.     [0-59] */
  int tm_hour;                  /* Hours.       [0-23] */
  int tm_mday;                  /* Day.         [1-31] */
  int tm_mon;                   /* Month.       [0-11] */
  int tm_year;                  /* Year - 1900.  */
  int tm_wday;                  /* Day of week. [0-6] */
  int tm_yday;                  /* Days in year.[0-365] */
  int tm_isdst;                 /* DST.         [-1/0/1]*/


  long int tm_gmtoff;           /* Seconds east of UTC.  */
  const char *tm_zone;          /* Timezone abbreviation.  */




};







/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;



# 178 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"



/* Time base values for timespec_get.  */
/* Polyspace [2013-11-21] Boost 1.49 is not even ready for this so, as this macro is not used in any libc header,
                          we disable it.
# define TIME_UTC 1
 */




/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) ;

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) ;

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
      ;

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) ;


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char * __s, size_t __maxsize,
                        const char * __format,
                        const struct tm * __tp) ;


# 220 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"


/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */


extern size_t strftime_l (char * __s, size_t __maxsize,
                          const char * __format,
                          const struct tm * __tp,
                          __locale_t __loc) ;










/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (const time_t *__timer) ;

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (const time_t *__timer) ;



/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (const time_t * __timer,
                            struct tm * __tp) ;

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (const time_t * __timer,
                               struct tm * __tp) ;



/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) ;

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) ;



/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (const struct tm * __tp,
                        char * __buf) ;

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (const time_t * __timer,
                      char * __buf) ;



/* Defined in localtime.c.  */
extern char *__tzname[2];       /* Current timezone names.  */
extern int __daylight;          /* If daylight-saving time is ever in use.  */
extern long int __timezone;     /* Seconds west of UTC.  */



/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) ;



extern int daylight;
extern long int timezone;



/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (const time_t *__when) ;



/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */





/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) ;

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) ;

/* Return the number of days in YEAR.  */
extern int dysize (int __year)   ;




/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (const struct timespec *__requested_time,
                      struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) ;

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) ;

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     ;


/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
                            const struct timespec *__req,
                            struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) ;



/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
                         struct sigevent * __evp,
                         timer_t * __timerid) ;

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) ;

/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
                          const struct itimerspec * __value,
                          struct itimerspec * __ovalue) ;

/* Get current value of timer TIMERID and store it in VALUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     ;

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) ;




/* Set TS to calendar time based in time base BASE.  */
extern int timespec_get (struct timespec *__ts, int __base)
      ;



# 417 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"

# 432 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/time.h"





# 63 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 64 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h" 2








# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h" 1
/* crypto/bn/bn.h */
/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the Eric Young open source
 * license provided above.
 *
 * The binary polynomial arithmetic software is originally written by 
 * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
 *
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 129 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h" 2










/* These preprocessor symbols control various aspects of the bignum headers and
 * library code. They're not defined by any "normal" configuration, as they are
 * intended for development and testing purposes. NB: defining all three can be
 * useful for debugging application code as well as openssl itself.
 *
 * BN_DEBUG - turn on various debugging alterations to the bignum code
 * BN_DEBUG_RAND - uses random poisoning of unused words to trip up
 * mismanagement of bignum internals. You must also define BN_DEBUG.
 */
/* #define BN_DEBUG */
/* #define BN_DEBUG_RAND */







/* This next option uses the C libraries (2 word)/(1 word) function.
 * If it is not defined, I use my C version (which is slower).
 * The reason for this flag is that when the particular C compiler
 * library routine is used, and the library is linked with a different
 * compiler, the library is missing.  This mostly happens when the
 * library is built with gcc and then linked using normal cc.  This would
 * be a common occurrence because gcc normally produces code that is
 * 2 times faster than system compilers for the big number stuff.
 * For machines with only one compiler (or shared libraries), this should
 * be on.  Again this in only really a problem on machines
 * using "long long's", are 32bit, and are not using my assembler code. */
# 174 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

/* assuming long is 64bit - this is the DEC Alpha
 * unsigned long long is only 64 bits :-(, don't define
 * BN_LLONG for the DEC Alpha */
# 199 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

/* This is where the long long data type is 64 bits, but long is 32.
 * For machines where there are 64bit registers, this is the mode to use.
 * IRIX, on R4000 and above should use this mode, along with the relevant
 * assembler code :-).  Do NOT define BN_LLONG.
 */
# 226 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

# 255 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

/* 2011-02-22 SMS.
 * In various places, a size_t variable or a type cast to size_t was
 * used to perform integer-only operations on pointers.  This failed on
 * VMS with 64-bit pointers (CC /POINTER_SIZE = 64) because size_t is
 * still only 32 bits.  What's needed in these cases is an integer type
 * with the same size as a pointer, which size_t is not certain to be. 
 * The only fix here is VMS-specific.
 */
# 273 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"



# 283 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"



                                      /* avoid leaking exponent information through timings
                                      * (BN_mod_exp_mont() will call BN_mod_exp_mont_consttime) */








/* get a clone of a BIGNUM with changed flags, for *temporary* use only
 * (the two BIGNUMs cannot not be used in parallel!) */
# 306 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

/* Already declared in ossl_typ.h */
# 317 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

struct bignum_st
        {
        unsigned long *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
        int top;        /* Index of last used d +1. */
        /* The next are internal book keeping for bn_expand. */
        int dmax;       /* Size of the d array. */
        int neg;        /* one if the number is negative */
        int flags;
        };

/* Used for montgomery multiplication */
struct bn_mont_ctx_st
        {
        int ri;        /* number of bits in R */
        BIGNUM RR;     /* used to convert to montgomery form */
        BIGNUM N;      /* The modulus */
        BIGNUM Ni;     /* R*(1/R mod N) - N*Ni = 1
                        * (Ni is only stored for bignum algorithm) */
        unsigned long n0[2];/* least significant word(s) of Ni;
                          (type changed with 0.9.9, was "BN_ULONG n0;" before) */
        int flags;
        };

/* Used for reciprocal division/mod functions
 * It cannot be shared between threads
 */
struct bn_recp_ctx_st
        {
        BIGNUM N;       /* the divisor */
        BIGNUM Nr;      /* the reciprocal */
        int num_bits;
        int shift;
        int flags;
        };

/* Used for slow "generation" functions. */
struct bn_gencb_st
        {
        unsigned int ver;       /* To handle binary (in)compatibility */
        void *arg;              /* callback-specific data */
        union
                {
                /* if(ver==1) - handles old style callbacks */
                void (*cb_1)(int, int, void *);
                /* if(ver==2) - new callback style */
                int (*cb_2)(int, int, BN_GENCB *);
                } cb;
        };
/* Wrapper function to make using BN_GENCB easier,  */
int BN_GENCB_call(BN_GENCB *cb, int a, int b);
/* Macro to populate a BN_GENCB structure with an "old"-style callback */





/* Macro to populate a BN_GENCB structure with a "new"-style callback */









/* number of Miller-Rabin iterations for an error rate  of less than 2^-80
 * for random 'b'-bit input, b >= 100 (taken from table 4.4 in the Handbook
 * of Applied Cryptography [Menezes, van Oorschot, Vanstone; CRC Press 1996];
 * original paper: Damgaard, Landrock, Pomerance: Average case error estimates
 * for the strong probable prime test. -- Math. Comp. 61 (1993) 177-194) */
# 401 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"



/* Note that BN_abs_is_word didn't work reliably for w == 0 until 0.9.8 */
# 411 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

# 424 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

const BIGNUM *BN_value_one(void);
char *  BN_options(void);
BN_CTX *BN_CTX_new(void);

void    BN_CTX_init(BN_CTX *c);

void    BN_CTX_free(BN_CTX *c);
void    BN_CTX_start(BN_CTX *ctx);
BIGNUM *BN_CTX_get(BN_CTX *ctx);
void    BN_CTX_end(BN_CTX *ctx);
int     BN_rand(BIGNUM *rnd, int bits, int top,int bottom);
int     BN_pseudo_rand(BIGNUM *rnd, int bits, int top,int bottom);
int     BN_rand_range(BIGNUM *rnd, const BIGNUM *range);
int     BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range);
int     BN_num_bits(const BIGNUM *a);
int     BN_num_bits_word(unsigned long);
BIGNUM *BN_new(void);
void    BN_init(BIGNUM *);
void    BN_clear_free(BIGNUM *a);
BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
void    BN_swap(BIGNUM *a, BIGNUM *b);
BIGNUM *BN_bin2bn(const unsigned char *s,int len,BIGNUM *ret);
int     BN_bn2bin(const BIGNUM *a, unsigned char *to);
BIGNUM *BN_mpi2bn(const unsigned char *s,int len,BIGNUM *ret);
int     BN_bn2mpi(const BIGNUM *a, unsigned char *to);
int     BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int     BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int     BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int     BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int     BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
int     BN_sqr(BIGNUM *r, const BIGNUM *a,BN_CTX *ctx);
/** BN_set_negative sets sign of a BIGNUM
 * \param  b  pointer to the BIGNUM object
 * \param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise 
 */
void    BN_set_negative(BIGNUM *b, int n);
/** BN_is_negative returns 1 if the BIGNUM is negative
 * \param  a  pointer to the BIGNUM object
 * \return 1 if a < 0 and 0 otherwise
 */


int     BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
        BN_CTX *ctx);

int     BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
int     BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m);
int     BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m);
int     BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m);
int     BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m, BN_CTX *ctx);
int     BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m);

unsigned long BN_mod_word(const BIGNUM *a, unsigned long w);
unsigned long BN_div_word(BIGNUM *a, unsigned long w);
int     BN_mul_word(BIGNUM *a, unsigned long w);
int     BN_add_word(BIGNUM *a, unsigned long w);
int     BN_sub_word(BIGNUM *a, unsigned long w);
int     BN_set_word(BIGNUM *a, unsigned long w);
unsigned long BN_get_word(const BIGNUM *a);

int     BN_cmp(const BIGNUM *a, const BIGNUM *b);
void    BN_free(BIGNUM *a);
int     BN_is_bit_set(const BIGNUM *a, int n);
int     BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
int     BN_lshift1(BIGNUM *r, const BIGNUM *a);
int     BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,BN_CTX *ctx);

int     BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        const BIGNUM *m,BN_CTX *ctx);
int     BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
        const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont);
int     BN_mod_exp_mont_word(BIGNUM *r, unsigned long a, const BIGNUM *p,
        const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
int     BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1,
        const BIGNUM *a2, const BIGNUM *p2,const BIGNUM *m,
        BN_CTX *ctx,BN_MONT_CTX *m_ctx);
int     BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        const BIGNUM *m,BN_CTX *ctx);

int     BN_mask_bits(BIGNUM *a,int n);

int     BN_print_fp(FILE *fp, const BIGNUM *a);


int     BN_print(BIO *fp, const BIGNUM *a);



int     BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx);
int     BN_rshift(BIGNUM *r, const BIGNUM *a, int n);
int     BN_rshift1(BIGNUM *r, const BIGNUM *a);
void    BN_clear(BIGNUM *a);
BIGNUM *BN_dup(const BIGNUM *a);
int     BN_ucmp(const BIGNUM *a, const BIGNUM *b);
int     BN_set_bit(BIGNUM *a, int n);
int     BN_clear_bit(BIGNUM *a, int n);
char *  BN_bn2hex(const BIGNUM *a);
char *  BN_bn2dec(const BIGNUM *a);
int     BN_hex2bn(BIGNUM **a, const char *str);
int     BN_dec2bn(BIGNUM **a, const char *str);
int     BN_asc2bn(BIGNUM **a, const char *str);
int     BN_gcd(BIGNUM *r,const BIGNUM *a,const BIGNUM *b,BN_CTX *ctx);
int     BN_kronecker(const BIGNUM *a,const BIGNUM *b,BN_CTX *ctx); /* returns -2 for error */
BIGNUM *BN_mod_inverse(BIGNUM *ret,
        const BIGNUM *a, const BIGNUM *n,BN_CTX *ctx);
BIGNUM *BN_mod_sqrt(BIGNUM *ret,
        const BIGNUM *a, const BIGNUM *n,BN_CTX *ctx);

void    BN_consttime_swap(unsigned long swap, BIGNUM *a, BIGNUM *b, int nwords);

/* Deprecated versions */

BIGNUM *BN_generate_prime(BIGNUM *ret,int bits,int safe,
        const BIGNUM *add, const BIGNUM *rem,
        void (*callback)(int,int,void *),void *cb_arg);
int     BN_is_prime(const BIGNUM *p,int nchecks,
        void (*callback)(int,int,void *),
        BN_CTX *ctx,void *cb_arg);
int     BN_is_prime_fasttest(const BIGNUM *p,int nchecks,
        void (*callback)(int,int,void *),BN_CTX *ctx,void *cb_arg,
        int do_trial_division);


/* Newer versions */
int     BN_generate_prime_ex(BIGNUM *ret,int bits,int safe, const BIGNUM *add,
                const BIGNUM *rem, BN_GENCB *cb);
int     BN_is_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb);
int     BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx,
                int do_trial_division, BN_GENCB *cb);

int BN_X931_generate_Xpq(BIGNUM *Xp, BIGNUM *Xq, int nbits, BN_CTX *ctx);

int BN_X931_derive_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,
                        const BIGNUM *Xp, const BIGNUM *Xp1, const BIGNUM *Xp2,
                        const BIGNUM *e, BN_CTX *ctx, BN_GENCB *cb);
int BN_X931_generate_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,
                        BIGNUM *Xp1, BIGNUM *Xp2,
                        const BIGNUM *Xp,
                        const BIGNUM *e, BN_CTX *ctx,
                        BN_GENCB *cb);

BN_MONT_CTX *BN_MONT_CTX_new(void );
void BN_MONT_CTX_init(BN_MONT_CTX *ctx);
int BN_mod_mul_montgomery(BIGNUM *r,const BIGNUM *a,const BIGNUM *b,
        BN_MONT_CTX *mont, BN_CTX *ctx);


int BN_from_montgomery(BIGNUM *r,const BIGNUM *a,
        BN_MONT_CTX *mont, BN_CTX *ctx);
void BN_MONT_CTX_free(BN_MONT_CTX *mont);
int BN_MONT_CTX_set(BN_MONT_CTX *mont,const BIGNUM *mod,BN_CTX *ctx);
BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to,BN_MONT_CTX *from);
BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,
                                        const BIGNUM *mod, BN_CTX *ctx);

/* BN_BLINDING flags */



BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod);
void BN_BLINDING_free(BN_BLINDING *b);
int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);
int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *);
int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b, BN_CTX *);

unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);
void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);

CRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);
unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);
void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);
BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
        const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,
        int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),
        BN_MONT_CTX *m_ctx);


void BN_set_params(int mul,int high,int low,int mont);
int BN_get_params(int which); /* 0, mul, 1 high, 2 low, 3 mont */


void    BN_RECP_CTX_init(BN_RECP_CTX *recp);
BN_RECP_CTX *BN_RECP_CTX_new(void);
void    BN_RECP_CTX_free(BN_RECP_CTX *recp);
int     BN_RECP_CTX_set(BN_RECP_CTX *recp,const BIGNUM *rdiv,BN_CTX *ctx);
int     BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,
        BN_RECP_CTX *recp,BN_CTX *ctx);
int     BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        const BIGNUM *m, BN_CTX *ctx);
int     BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,
        BN_RECP_CTX *recp, BN_CTX *ctx);



/* Functions for arithmetic over binary polynomials represented by BIGNUMs. 
 *
 * The BIGNUM::neg property of BIGNUMs representing binary polynomials is
 * ignored.
 *
 * Note that input arguments are not const so that their bit arrays can
 * be expanded to the appropriate size if needed.
 */

int     BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b); /*r = a + b*/

int     BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p); /*r=a mod p*/
int     BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const BIGNUM *p, BN_CTX *ctx); /* r = (a * b) mod p */
int     BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        BN_CTX *ctx); /* r = (a * a) mod p */
int     BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *b, const BIGNUM *p,
        BN_CTX *ctx); /* r = (1 / b) mod p */
int     BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const BIGNUM *p, BN_CTX *ctx); /* r = (a / b) mod p */
int     BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const BIGNUM *p, BN_CTX *ctx); /* r = (a ^ b) mod p */
int     BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        BN_CTX *ctx); /* r = sqrt(a) mod p */
int     BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
        BN_CTX *ctx); /* r^2 + r = a mod p */

/* Some functions allow for representation of the irreducible polynomials
 * as an unsigned int[], say p.  The irreducible f(t) is then of the form:
 *     t^p[0] + t^p[1] + ... + t^p[k]
 * where m = p[0] > p[1] > ... > p[k] = 0.
 */
int     BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[]);
        /* r = a mod p */
int     BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const int p[], BN_CTX *ctx); /* r = (a * b) mod p */
int     BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],
        BN_CTX *ctx); /* r = (a * a) mod p */
int     BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *b, const int p[],
        BN_CTX *ctx); /* r = (1 / b) mod p */
int     BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const int p[], BN_CTX *ctx); /* r = (a / b) mod p */
int     BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
        const int p[], BN_CTX *ctx); /* r = (a ^ b) mod p */
int     BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a,
        const int p[], BN_CTX *ctx); /* r = sqrt(a) mod p */
int     BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a,
        const int p[], BN_CTX *ctx); /* r^2 + r = a mod p */
int     BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max);
int     BN_GF2m_arr2poly(const int p[], BIGNUM *a);



/* faster mod functions for the 'NIST primes' 
 * 0 <= a < p^2 */
int BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
int BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
int BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
int BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);

const BIGNUM *BN_get0_nist_prime_192(void);
const BIGNUM *BN_get0_nist_prime_224(void);
const BIGNUM *BN_get0_nist_prime_256(void);
const BIGNUM *BN_get0_nist_prime_384(void);
const BIGNUM *BN_get0_nist_prime_521(void);

/* library internal functions */




BIGNUM *bn_expand2(BIGNUM *a, int words);

BIGNUM *bn_dup_expand(const BIGNUM *a, int words); /* unused */


/* Bignum consistency macros
 * There is one "API" macro, bn_fix_top(), for stripping leading zeroes from
 * bignum data after direct manipulations on the data. There is also an
 * "internal" macro, bn_check_top(), for verifying that there are no leading
 * zeroes. Unfortunately, some auditing is required due to the fact that
 * bn_fix_top() has become an overabused duct-tape because bignum data is
 * occasionally passed around in an inconsistent state. So the following
 * changes have been made to sort this out;
 * - bn_fix_top()s implementation has been moved to bn_correct_top()
 * - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and
 *   bn_check_top() is as before.
 * - if BN_DEBUG *is* defined;
 *   - bn_check_top() tries to pollute unused words even if the bignum 'top' is
 *     consistent. (ed: only if BN_DEBUG_RAND is defined)
 *   - bn_fix_top() maps to bn_check_top() rather than "fixing" anything.
 * The idea is to have debug builds flag up inconsistent bignums when they
 * occur. If that occurs in a bn_fix_top(), we examine the code in question; if
 * the use of bn_fix_top() was appropriate (ie. it follows directly after code
 * that manipulates the bignum) it is converted to bn_correct_top(), and if it
 * was not appropriate, we convert it permanently to bn_check_top() and track
 * down the cause of the bug. Eventually, no internal code should be using the
 * bn_fix_top() macro. External applications and libraries should try this with
 * their own code too, both in terms of building against the openssl headers
 * with BN_DEBUG defined *and* linking with a version of OpenSSL built with it
 * defined. This not only improves external code, it provides more test
 * coverage for openssl's own code.
 */

# 789 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"









# 810 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

unsigned long bn_mul_add_words(unsigned long *rp, const unsigned long *ap, int num, unsigned long w);
unsigned long bn_mul_words(unsigned long *rp, const unsigned long *ap, int num, unsigned long w);
void     bn_sqr_words(unsigned long *rp, const unsigned long *ap, int num);
unsigned long bn_div_words(unsigned long h, unsigned long l, unsigned long d);
unsigned long bn_add_words(unsigned long *rp, const unsigned long *ap, const unsigned long *bp,int num);
unsigned long bn_sub_words(unsigned long *rp, const unsigned long *ap, const unsigned long *bp,int num);

/* Primes from RFC 2409 */
BIGNUM *get_rfc2409_prime_768(BIGNUM *bn);
BIGNUM *get_rfc2409_prime_1024(BIGNUM *bn);

/* Primes from RFC 3526 */
BIGNUM *get_rfc3526_prime_1536(BIGNUM *bn);
BIGNUM *get_rfc3526_prime_2048(BIGNUM *bn);
BIGNUM *get_rfc3526_prime_3072(BIGNUM *bn);
BIGNUM *get_rfc3526_prime_4096(BIGNUM *bn);
BIGNUM *get_rfc3526_prime_6144(BIGNUM *bn);
BIGNUM *get_rfc3526_prime_8192(BIGNUM *bn);

int BN_bntest_rand(BIGNUM *rnd, int bits, int top,int bottom);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_BN_strings(void);

/* Error codes for the BN functions. */

/* Function codes. */
# 881 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

/* Reason codes. */
# 900 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/bn.h"

# 75 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h" 2


























# 132 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

/* For use with d2i_ASN1_type_bytes() */
# 153 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

/* For use with ASN1_mbstring_copy() */










struct X509_algor_st;
struct stack_st_X509_ALGOR { _STACK stack; };




/* We MUST make sure that, except for constness, asn1_ctx_st and
   asn1_const_ctx are exactly the same.  Fortunately, as soon as
   the old ASN1 parsing macros are gone, we can throw this away
   as well... */
typedef struct asn1_ctx_st
        {
        unsigned char *p;/* work char pointer */
        int eos;        /* end of sequence read for indefinite encoding */
        int error;      /* error code to use when returning an error */
        int inf;        /* constructed if 0x20, indefinite is 0x21 */
        int tag;        /* tag from last 'get object' */
        int xclass;     /* class from last 'get object' */
        long slen;      /* length of last 'get object' */
        unsigned char *max; /* largest value of p allowed */
        unsigned char *q;/* temporary variable */
        unsigned char **pp;/* variable */
        int line;       /* used in error processing */
        } ASN1_CTX;

typedef struct asn1_const_ctx_st
        {
        const unsigned char *p;/* work char pointer */
        int eos;        /* end of sequence read for indefinite encoding */
        int error;      /* error code to use when returning an error */
        int inf;        /* constructed if 0x20, indefinite is 0x21 */
        int tag;        /* tag from last 'get object' */
        int xclass;     /* class from last 'get object' */
        long slen;      /* length of last 'get object' */
        const unsigned char *max; /* largest value of p allowed */
        const unsigned char *q;/* temporary variable */
        const unsigned char **pp;/* variable */
        int line;       /* used in error processing */
        } ASN1_const_CTX;

/* These are used internally in the ASN1_OBJECT to keep track of
 * whether the names and data need to be free()ed */




typedef struct asn1_object_st
        {
        const char *sn,*ln;
        int nid;
        int length;
        const unsigned char *data;      /* data remains const after init */
        int flags;      /* Should we free this one */
        } ASN1_OBJECT;


/* This indicates that the ASN1_STRING is not a real value but just a place
 * holder for the location where indefinite length constructed data should
 * be inserted in the memory buffer 
 */


/* This flag is used by the CMS code to indicate that a string is not
 * complete and is a place holder for content when it had all been 
 * accessed. The flag will be reset when content has been written to it.
 */


/* This flag is used by ASN1 code to indicate an ASN1_STRING is an MSTRING
 * type.
 */

/* This is the base type that holds just about everything :-) */
struct asn1_string_st
        {
        int length;
        int type;
        unsigned char *data;
        /* The value of the following field depends on the type being
         * held.  It is mostly being used for BIT_STRING so if the
         * input data has a non-zero 'unused bits' value, it will be
         * handled correctly */
        long flags;
        };

/* ASN1_ENCODING structure: this is used to save the received
 * encoding of an ASN1 type. This is useful to get round
 * problems with invalid encodings which can break signatures.
 */

typedef struct ASN1_ENCODING_st
        {
        unsigned char *enc;     /* DER encoding */
        long len;               /* Length of encoding */
        int modified;            /* set to 1 if 'enc' is invalid */
        } ASN1_ENCODING;

/* Used with ASN1 LONG type: if a long is set to this it is omitted */








typedef struct asn1_string_table_st {
        int nid;
        long minsize;
        long maxsize;
        unsigned long mask;
        unsigned long flags;
} ASN1_STRING_TABLE;

struct stack_st_ASN1_STRING_TABLE { _STACK stack; };

/* size limits: this stuff is taken straight from RFC2459 */

# 291 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

/* Declarations for template structures: for full definitions
 * see asn1t.h
 */
typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;
typedef struct ASN1_TLC_st ASN1_TLC;
/* This is just an opaque pointer */
typedef struct ASN1_VALUE_st ASN1_VALUE;

/* Declare ASN1 functions: the implement macro in in asn1t.h */














































# 357 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"





typedef void *d2i_of_void(void * *,const unsigned char * *,long); typedef int i2d_of_void(void *,unsigned char * *);

/* The following macros and typedefs allow an ASN1_ITEM
 * to be embedded in a structure and referenced. Since
 * the ASN1_ITEM pointers need to be globally accessible
 * (possibly from shared libraries) they may exist in
 * different forms. On platforms that support it the
 * ASN1_ITEM structure itself will be globally exported.
 * Other platforms will export a function that returns
 * an ASN1_ITEM pointer.
 *
 * To handle both cases transparently the macros below
 * should be used instead of hard coding an ASN1_ITEM
 * pointer in a structure.
 *
 * The structure will look like this:
 *
 * typedef struct SOMETHING_st {
 *      ...
 *      ASN1_ITEM_EXP *iptr;
 *      ...
 * } SOMETHING; 
 *
 * It would be initialised as e.g.:
 *
 * SOMETHING somevar = {...,ASN1_ITEM_ref(X509),...};
 *
 * and the actual pointer extracted with:
 *
 * const ASN1_ITEM *it = ASN1_ITEM_ptr(somevar.iptr);
 *
 * Finally an ASN1_ITEM pointer can be extracted from an
 * appropriate reference with: ASN1_ITEM_rptr(X509). This
 * would be used when a function takes an ASN1_ITEM * argument.
 *
 */



/* ASN1_ITEM pointer exported type */
typedef const ASN1_ITEM ASN1_ITEM_EXP;

/* Macro to obtain ASN1_ITEM pointer from exported type */


/* Macro to include ASN1_ITEM pointer from base type */







# 436 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

/* Parameters used by ASN1_STRING_print_ex() */

/* These determine which characters to escape:
 * RFC2253 special characters, control characters and
 * MSB set characters
 */






/* This flag determines how we do escaping: normally
 * RC2253 backslash only, set this to use backslash and
 * quote.
 */




/* These three flags are internal use only. */

/* Character is a valid PrintableString character */

/* Character needs escaping if it is the first character */

/* Character needs escaping if it is the last character */


/* NB the internal flags are safely reused below by flags
 * handled at the top level.
 */

/* If this is set we convert all character strings
 * to UTF8 first 
 */



/* If this is set we don't attempt to interpret content:
 * just assume all strings are 1 byte per character. This
 * will produce some pretty odd looking output!
 */



/* If this is set we include the string type in the output */


/* This determines which strings to display and which to
 * 'dump' (hex dump of content octets or DER encoding). We can
 * only dump non character strings or everything. If we
 * don't dump 'unknown' they are interpreted as character
 * strings with 1 octet per character and are subject to
 * the usual escaping options.
 */




/* These determine what 'dumping' does, we can dump the
 * content octets or the DER encoding: both use the
 * RFC2253 #XXXXX notation.
 */



/* All the string flags consistent with RFC2253,
 * escaping control characters isn't essential in
 * RFC2253 but it is advisable anyway.
 */

# 515 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

struct stack_st_ASN1_INTEGER { _STACK stack; };


struct stack_st_ASN1_GENERALSTRING { _STACK stack; };

typedef struct asn1_type_st
        {
        int type;
        union   {
                char *ptr;
                ASN1_BOOLEAN            boolean;
                ASN1_STRING *           asn1_string;
                ASN1_OBJECT *           object;
                ASN1_INTEGER *          integer;
                ASN1_ENUMERATED *       enumerated;
                ASN1_BIT_STRING *       bit_string;
                ASN1_OCTET_STRING *     octet_string;
                ASN1_PRINTABLESTRING *  printablestring;
                ASN1_T61STRING *        t61string;
                ASN1_IA5STRING *        ia5string;
                ASN1_GENERALSTRING *    generalstring;
                ASN1_BMPSTRING *        bmpstring;
                ASN1_UNIVERSALSTRING *  universalstring;
                ASN1_UTCTIME *          utctime;
                ASN1_GENERALIZEDTIME *  generalizedtime;
                ASN1_VISIBLESTRING *    visiblestring;
                ASN1_UTF8STRING *       utf8string;
                /* set and sequence are left complete and still
                 * contain the set or sequence bytes */
                ASN1_STRING *           set;
                ASN1_STRING *           sequence;
                ASN1_VALUE *            asn1_value;
                } value;
        } ASN1_TYPE;

struct stack_st_ASN1_TYPE { _STACK stack; };


typedef struct stack_st_ASN1_TYPE ASN1_SEQUENCE_ANY;

ASN1_SEQUENCE_ANY *d2i_ASN1_SEQUENCE_ANY(ASN1_SEQUENCE_ANY * *a, const unsigned char * *in, long len); int i2d_ASN1_SEQUENCE_ANY(const ASN1_SEQUENCE_ANY *a, unsigned char * *out); extern const ASN1_ITEM ASN1_SEQUENCE_ANY_it;
ASN1_SEQUENCE_ANY *d2i_ASN1_SET_ANY(ASN1_SEQUENCE_ANY * *a, const unsigned char * *in, long len); int i2d_ASN1_SET_ANY(const ASN1_SEQUENCE_ANY *a, unsigned char * *out); extern const ASN1_ITEM ASN1_SET_ANY_it;

typedef struct NETSCAPE_X509_st
        {
        ASN1_OCTET_STRING *header;
        X509 *cert;
        } NETSCAPE_X509;

/* This is used to contain a list of bit names */
typedef struct BIT_STRING_BITNAME_st {
        int bitnum;
        const char *lname;
        const char *sname;
} BIT_STRING_BITNAME;







/* Macros for string operations */
# 587 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 595 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 603 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 616 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"





# 632 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 639 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"







# 653 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 661 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 669 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 679 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 689 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 701 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"



















# 729 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 739 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 749 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 759 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 769 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

  /* for the is_set parameter to i2d_ASN1_SET */



ASN1_TYPE *ASN1_TYPE_new(void); void ASN1_TYPE_free(ASN1_TYPE *a); ASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE * *a, const unsigned char * *in, long len); int i2d_ASN1_TYPE(ASN1_TYPE *a, unsigned char * *out); extern const ASN1_ITEM ASN1_ANY_it;

int ASN1_TYPE_get(ASN1_TYPE *a);
void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value);
int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value);
int            ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b);

ASN1_OBJECT *   ASN1_OBJECT_new(void );
void            ASN1_OBJECT_free(ASN1_OBJECT *a);
int             i2d_ASN1_OBJECT(ASN1_OBJECT *a,unsigned char **pp);
ASN1_OBJECT *   c2i_ASN1_OBJECT(ASN1_OBJECT **a,const unsigned char **pp,
                        long length);
ASN1_OBJECT *   d2i_ASN1_OBJECT(ASN1_OBJECT **a,const unsigned char **pp,
                        long length);

extern const ASN1_ITEM ASN1_OBJECT_it;

struct stack_st_ASN1_OBJECT { _STACK stack; };


ASN1_STRING *   ASN1_STRING_new(void);
void            ASN1_STRING_free(ASN1_STRING *a);
int             ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);
ASN1_STRING *   ASN1_STRING_dup(const ASN1_STRING *a);
ASN1_STRING *   ASN1_STRING_type_new(int type );
int             ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b);
  /* Since this is used to store all sorts of things, via macros, for now, make
     its data void * */
int             ASN1_STRING_set(ASN1_STRING *str, const void *data, int len);
void            ASN1_STRING_set0(ASN1_STRING *str, void *data, int len);
int ASN1_STRING_length(const ASN1_STRING *x);
void ASN1_STRING_length_set(ASN1_STRING *x, int n);
int ASN1_STRING_type(ASN1_STRING *x);
unsigned char * ASN1_STRING_data(ASN1_STRING *x);

ASN1_BIT_STRING *ASN1_BIT_STRING_new(void); void ASN1_BIT_STRING_free(ASN1_BIT_STRING *a); ASN1_BIT_STRING *d2i_ASN1_BIT_STRING(ASN1_BIT_STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_BIT_STRING_it;
int             i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a,unsigned char **pp);
ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,const unsigned char **pp,
                        long length);
int             ASN1_BIT_STRING_set(ASN1_BIT_STRING *a, unsigned char *d,
                        int length );
int             ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value);
int             ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n);
int            ASN1_BIT_STRING_check(ASN1_BIT_STRING *a,
                                     unsigned char *flags, int flags_len);


int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,
                                BIT_STRING_BITNAME *tbl, int indent);

int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl);
int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,
                                BIT_STRING_BITNAME *tbl);

int             i2d_ASN1_BOOLEAN(int a,unsigned char **pp);
int             d2i_ASN1_BOOLEAN(int *a,const unsigned char **pp,long length);

ASN1_INTEGER *ASN1_INTEGER_new(void); void ASN1_INTEGER_free(ASN1_INTEGER *a); ASN1_INTEGER *d2i_ASN1_INTEGER(ASN1_INTEGER * *a, const unsigned char * *in, long len); int i2d_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char * *out); extern const ASN1_ITEM ASN1_INTEGER_it;
int             i2c_ASN1_INTEGER(ASN1_INTEGER *a,unsigned char **pp);
ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a,const unsigned char **pp,
                        long length);
ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a,const unsigned char **pp,
                        long length);
ASN1_INTEGER *  ASN1_INTEGER_dup(const ASN1_INTEGER *x);
int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y);

ASN1_ENUMERATED *ASN1_ENUMERATED_new(void); void ASN1_ENUMERATED_free(ASN1_ENUMERATED *a); ASN1_ENUMERATED *d2i_ASN1_ENUMERATED(ASN1_ENUMERATED * *a, const unsigned char * *in, long len); int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned char * *out); extern const ASN1_ITEM ASN1_ENUMERATED_it;

int ASN1_UTCTIME_check(ASN1_UTCTIME *a);
ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s,time_t t);
ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
                                int offset_day, long offset_sec);
int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);
int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);




int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *a);
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,time_t t);
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
             time_t t, int offset_day, long offset_sec);
int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str);

ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void); void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a); ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_OCTET_STRING_it;
ASN1_OCTET_STRING *     ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *a);
int     ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a, const ASN1_OCTET_STRING *b);
int     ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str, const unsigned char *data, int len);

ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void); void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *a); ASN1_VISIBLESTRING *d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING * *a, const unsigned char * *in, long len); int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_VISIBLESTRING_it;
ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void); void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *a); ASN1_UNIVERSALSTRING *d2i_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING * *a, const unsigned char * *in, long len); int i2d_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_UNIVERSALSTRING_it;
ASN1_UTF8STRING *ASN1_UTF8STRING_new(void); void ASN1_UTF8STRING_free(ASN1_UTF8STRING *a); ASN1_UTF8STRING *d2i_ASN1_UTF8STRING(ASN1_UTF8STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_UTF8STRING_it;
ASN1_NULL *ASN1_NULL_new(void); void ASN1_NULL_free(ASN1_NULL *a); ASN1_NULL *d2i_ASN1_NULL(ASN1_NULL * *a, const unsigned char * *in, long len); int i2d_ASN1_NULL(ASN1_NULL *a, unsigned char * *out); extern const ASN1_ITEM ASN1_NULL_it;
ASN1_BMPSTRING *ASN1_BMPSTRING_new(void); void ASN1_BMPSTRING_free(ASN1_BMPSTRING *a); ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING * *a, const unsigned char * *in, long len); int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_BMPSTRING_it;

int UTF8_getc(const unsigned char *str, int len, unsigned long *val);
int UTF8_putc(unsigned char *str, int len, unsigned long value);

ASN1_STRING *ASN1_PRINTABLE_new(void); void ASN1_PRINTABLE_free(ASN1_STRING *a); ASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_PRINTABLE(ASN1_STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_PRINTABLE_it;

ASN1_STRING *DIRECTORYSTRING_new(void); void DIRECTORYSTRING_free(ASN1_STRING *a); ASN1_STRING *d2i_DIRECTORYSTRING(ASN1_STRING * *a, const unsigned char * *in, long len); int i2d_DIRECTORYSTRING(ASN1_STRING *a, unsigned char * *out); extern const ASN1_ITEM DIRECTORYSTRING_it;
ASN1_STRING *DISPLAYTEXT_new(void); void DISPLAYTEXT_free(ASN1_STRING *a); ASN1_STRING *d2i_DISPLAYTEXT(ASN1_STRING * *a, const unsigned char * *in, long len); int i2d_DISPLAYTEXT(ASN1_STRING *a, unsigned char * *out); extern const ASN1_ITEM DISPLAYTEXT_it;
ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void); void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *a); ASN1_PRINTABLESTRING *d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING * *a, const unsigned char * *in, long len); int i2d_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_PRINTABLESTRING_it;
ASN1_T61STRING *ASN1_T61STRING_new(void); void ASN1_T61STRING_free(ASN1_T61STRING *a); ASN1_T61STRING *d2i_ASN1_T61STRING(ASN1_T61STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_T61STRING(ASN1_T61STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_T61STRING_it;
ASN1_IA5STRING *ASN1_IA5STRING_new(void); void ASN1_IA5STRING_free(ASN1_IA5STRING *a); ASN1_IA5STRING *d2i_ASN1_IA5STRING(ASN1_IA5STRING * *a, const unsigned char * *in, long len); int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_IA5STRING_it;
ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void); void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *a); ASN1_GENERALSTRING *d2i_ASN1_GENERALSTRING(ASN1_GENERALSTRING * *a, const unsigned char * *in, long len); int i2d_ASN1_GENERALSTRING(ASN1_GENERALSTRING *a, unsigned char * *out); extern const ASN1_ITEM ASN1_GENERALSTRING_it;
ASN1_UTCTIME *ASN1_UTCTIME_new(void); void ASN1_UTCTIME_free(ASN1_UTCTIME *a); ASN1_UTCTIME *d2i_ASN1_UTCTIME(ASN1_UTCTIME * *a, const unsigned char * *in, long len); int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a, unsigned char * *out); extern const ASN1_ITEM ASN1_UTCTIME_it;
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void); void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *a); ASN1_GENERALIZEDTIME *d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME * *a, const unsigned char * *in, long len); int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a, unsigned char * *out); extern const ASN1_ITEM ASN1_GENERALIZEDTIME_it;
ASN1_TIME *ASN1_TIME_new(void); void ASN1_TIME_free(ASN1_TIME *a); ASN1_TIME *d2i_ASN1_TIME(ASN1_TIME * *a, const unsigned char * *in, long len); int i2d_ASN1_TIME(ASN1_TIME *a, unsigned char * *out); extern const ASN1_ITEM ASN1_TIME_it;

extern const ASN1_ITEM ASN1_OCTET_STRING_NDEF_it;

ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s,time_t t);
ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s,time_t t,
                                int offset_day, long offset_sec);
int ASN1_TIME_check(ASN1_TIME *t);
ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out);
int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);

int i2d_ASN1_SET(struct stack_st_OPENSSL_BLOCK *a, unsigned char **pp,
                 i2d_of_void *i2d, int ex_tag, int ex_class,
                 int is_set);
struct stack_st_OPENSSL_BLOCK *d2i_ASN1_SET(struct stack_st_OPENSSL_BLOCK **a,
                              const unsigned char **pp,
                              long length, d2i_of_void *d2i,
                              void (*free_func)(OPENSSL_BLOCK), int ex_tag,
                              int ex_class);


int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a);
int a2i_ASN1_INTEGER(BIO *bp,ASN1_INTEGER *bs,char *buf,int size);
int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a);
int a2i_ASN1_ENUMERATED(BIO *bp,ASN1_ENUMERATED *bs,char *buf,int size);
int i2a_ASN1_OBJECT(BIO *bp,ASN1_OBJECT *a);
int a2i_ASN1_STRING(BIO *bp,ASN1_STRING *bs,char *buf,int size);
int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type);

int i2t_ASN1_OBJECT(char *buf,int buf_len,ASN1_OBJECT *a);

int a2d_ASN1_OBJECT(unsigned char *out,int olen, const char *buf, int num);
ASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data,int len,
        const char *sn, const char *ln);

int ASN1_INTEGER_set(ASN1_INTEGER *a, long v);
long ASN1_INTEGER_get(const ASN1_INTEGER *a);
ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);
BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai,BIGNUM *bn);

int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);
long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a);
ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai);
BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai,BIGNUM *bn);

/* General */
/* given a string, return the correct type, max is the maximum length */
int ASN1_PRINTABLE_type(const unsigned char *s, int max);

int i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass);
ASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, const unsigned char **pp,
        long length, int Ptag, int Pclass);
unsigned long ASN1_tag2bit(int tag);
/* type is one or more of the B_ASN1_ values. */
ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a,const unsigned char **pp,
                long length,int type);

/* PARSING */
int asn1_Finish(ASN1_CTX *c);
int asn1_const_Finish(ASN1_const_CTX *c);

/* SPECIALS */
int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,
        int *pclass, long omax);
int ASN1_check_infinite_end(unsigned char **p,long len);
int ASN1_const_check_infinite_end(const unsigned char **p,long len);
void ASN1_put_object(unsigned char **pp, int constructed, int length,
        int tag, int xclass);
int ASN1_put_eoc(unsigned char **pp);
int ASN1_object_size(int constructed, int length, int tag);

/* Used to implement other functions */
void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x);











void *ASN1_item_dup(const ASN1_ITEM *it, void *x);

/* ASN1 alloc/free macros for when a type is only used internally */






void *ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x);







void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x);
int ASN1_i2d_fp(i2d_of_void *i2d,FILE *out,void *x);











int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x);
int ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags);


int ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in);


void *ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x);







void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x);
int ASN1_i2d_bio(i2d_of_void *i2d,BIO *out, unsigned char *x);











int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x);
int ASN1_UTCTIME_print(BIO *fp, const ASN1_UTCTIME *a);
int ASN1_GENERALIZEDTIME_print(BIO *fp, const ASN1_GENERALIZEDTIME *a);
int ASN1_TIME_print(BIO *fp, const ASN1_TIME *a);
int ASN1_STRING_print(BIO *bp, const ASN1_STRING *v);
int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags);
int ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,
                                unsigned char *buf, int off);
int ASN1_parse(BIO *bp,const unsigned char *pp,long len,int indent);
int ASN1_parse_dump(BIO *bp,const unsigned char *pp,long len,int indent,int dump);

const char *ASN1_tag2str(int tag);

/* Used to load and write netscape format cert */

NETSCAPE_X509 *NETSCAPE_X509_new(void); void NETSCAPE_X509_free(NETSCAPE_X509 *a); NETSCAPE_X509 *d2i_NETSCAPE_X509(NETSCAPE_X509 * *a, const unsigned char * *in, long len); int i2d_NETSCAPE_X509(NETSCAPE_X509 *a, unsigned char * *out); extern const ASN1_ITEM NETSCAPE_X509_it;

int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s);

int ASN1_TYPE_set_octetstring(ASN1_TYPE *a,
        unsigned char *data, int len);
int ASN1_TYPE_get_octetstring(ASN1_TYPE *a,
        unsigned char *data, int max_len);
int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num,
        unsigned char *data, int len);
int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a,long *num,
        unsigned char *data, int max_len);

struct stack_st_OPENSSL_BLOCK *ASN1_seq_unpack(const unsigned char *buf, int len,
                                 d2i_of_void *d2i, void (*free_func)(OPENSSL_BLOCK));
unsigned char *ASN1_seq_pack(struct stack_st_OPENSSL_BLOCK *safes, i2d_of_void *i2d,
                             unsigned char **buf, int *len );
void *ASN1_unpack_string(ASN1_STRING *oct, d2i_of_void *d2i);
void *ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it);
ASN1_STRING *ASN1_pack_string(void *obj, i2d_of_void *i2d,
                              ASN1_OCTET_STRING **oct);






ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_OCTET_STRING **oct);

void ASN1_STRING_set_default_mask(unsigned long mask);
int ASN1_STRING_set_default_mask_asc(const char *p);
unsigned long ASN1_STRING_get_default_mask(void);
int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,
                                        int inform, unsigned long mask);
int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
                                        int inform, unsigned long mask, 
                                        long minsize, long maxsize);

ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out, 
                const unsigned char *in, int inlen, int inform, int nid);
ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid);
int ASN1_STRING_TABLE_add(int, long, long, unsigned long, unsigned long);
void ASN1_STRING_TABLE_cleanup(void);

/* ASN1 template functions */

/* Old API compatible functions */
ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it);
void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);
ASN1_VALUE * ASN1_item_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it);
int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it);
int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it);

void ASN1_add_oid_module(void);

ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf);
ASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf);

/* ASN1 Print flags */

/* Indicate missing OPTIONAL fields */

/* Mark start and end of SEQUENCE */

/* Mark start and end of SEQUENCE/SET OF */

/* Show the ASN1 type of primitives */

/* Don't show ASN1 type of ANY */

/* Don't show ASN1 type of MSTRINGs */

/* Don't show field names in SEQUENCE */

/* Show structure names of each SEQUENCE field */

/* Don't show structure name even at top level */


int ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,
                                const ASN1_ITEM *it, const ASN1_PCTX *pctx);
ASN1_PCTX *ASN1_PCTX_new(void);
void ASN1_PCTX_free(ASN1_PCTX *p);
unsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p);
void ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags);
unsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p);
void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags);
unsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p);
void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags);
unsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p);
void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags);
unsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p);
void ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags);

BIO_METHOD *BIO_f_asn1(void);

BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it);

int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
                                const ASN1_ITEM *it);
int PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
                                const char *hdr,
                                const ASN1_ITEM *it);
int SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
                                int ctype_nid, int econt_nid,
                                struct stack_st_X509_ALGOR *mdalgs,
                                const ASN1_ITEM *it);
ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it);
int SMIME_crlf_copy(BIO *in, BIO *out, int flags);
int SMIME_text(BIO *in, BIO *out);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_ASN1_strings(void);

/* Error codes for the ASN1 functions. */

/* Function codes. */
# 1280 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

/* Reason codes. */
# 1402 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/asn1.h"

# 961 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h" 2

# 968 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"











typedef struct obj_name_st
        {
        int type;
        int alias;
        const char *name;
        const char *data;
        } OBJ_NAME;




int OBJ_NAME_init(void);
int OBJ_NAME_new_index(unsigned long (*hash_func)(const char *),
                       int (*cmp_func)(const char *, const char *),
                       void (*free_func)(const char *, int, const char *));
const char *OBJ_NAME_get(const char *name,int type);
int OBJ_NAME_add(const char *name,int type,const char *data);
int OBJ_NAME_remove(const char *name,int type);
void OBJ_NAME_cleanup(int type); /* -1 for everything */
void OBJ_NAME_do_all(int type,void (*fn)(const OBJ_NAME *,void *arg),
                     void *arg);
void OBJ_NAME_do_all_sorted(int type,void (*fn)(const OBJ_NAME *,void *arg),
                            void *arg);

ASN1_OBJECT *   OBJ_dup(const ASN1_OBJECT *o);
ASN1_OBJECT *   OBJ_nid2obj(int n);
const char *    OBJ_nid2ln(int n);
const char *    OBJ_nid2sn(int n);
int             OBJ_obj2nid(const ASN1_OBJECT *o);
ASN1_OBJECT *   OBJ_txt2obj(const char *s, int no_name);
int     OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);
int             OBJ_txt2nid(const char *s);
int             OBJ_ln2nid(const char *s);
int             OBJ_sn2nid(const char *s);
int             OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);
const void *    OBJ_bsearch_(const void *key,const void *base,int num,int size,
                             int (*cmp)(const void *, const void *));
const void *    OBJ_bsearch_ex_(const void *key,const void *base,int num,
                                int size,
                                int (*cmp)(const void *, const void *),
                                int flags);











/*
 * Unsolved problem: if a type is actually a pointer type, like
 * nid_triple is, then its impossible to get a const where you need
 * it. Consider:
 *
 * typedef int nid_triple[3];
 * const void *a_;
 * const nid_triple const *a = a_;
 *
 * The assignement discards a const because what you really want is:
 *
 * const int const * const *a = a_;
 *
 * But if you do that, you lose the fact that a is an array of 3 ints,
 * which breaks comparison functions.
 *
 * Thus we end up having to cast, sadly, or unpack the
 * declarations. Or, as I finally did in this case, delcare nid_triple
 * to be a struct, which it should have been in the first place.
 *
 * Ben, August 2008.
 *
 * Also, strictly speaking not all types need be const, but handling
 * the non-constness means a lot of complication, and in practice
 * comparison routines do always not touch their arguments.
 */

# 1071 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

# 1085 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

# 1092 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

# 1099 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

int             OBJ_new_nid(int num);
int             OBJ_add_object(const ASN1_OBJECT *obj);
int             OBJ_create(const char *oid,const char *sn,const char *ln);
void            OBJ_cleanup(void );
int             OBJ_create_objects(BIO *in);

int OBJ_find_sigid_algs(int signid, int *pdig_nid, int *ppkey_nid);
int OBJ_find_sigid_by_algs(int *psignid, int dig_nid, int pkey_nid);
int OBJ_add_sigid(int signid, int dig_id, int pkey_id);
void OBJ_sigid_free(void);

extern int obj_cleanup_defer;
void check_defer(int nid);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_OBJ_strings(void);

/* Error codes for the OBJ functions. */

/* Function codes. */
# 1130 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/objects.h"

/* Reason codes. */



# 95 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h" 2

# 107 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

# 120 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"





/* Type needs to be a bit field
 * Sub-type needs to be for variations on the method, as in, can it do
 * arbitrary encryption.... */
struct evp_pkey_st
        {
        int type;
        int save_type;
        int references;
        const EVP_PKEY_ASN1_METHOD *ameth;
        ENGINE *engine;
        union   {
                char *ptr;

                struct rsa_st *rsa;     /* RSA */


                struct dsa_st *dsa;     /* DSA */


                struct dh_st *dh;       /* DH */


                struct ec_key_st *ec;   /* ECC */

                } pkey;
        int save_parameters;
        struct stack_st_X509_ATTRIBUTE *attributes; /* [ 0 ] */
        } /* EVP_PKEY */;







struct env_md_st
        {
        int type;
        int pkey_type;
        int md_size;
        unsigned long flags;
        int (*init)(EVP_MD_CTX *ctx);
        int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
        int (*final)(EVP_MD_CTX *ctx,unsigned char *md);
        int (*copy)(EVP_MD_CTX *to,const EVP_MD_CTX *from);
        int (*cleanup)(EVP_MD_CTX *ctx);

        /* FIXME: prototype these some day */
        int (*sign)(int type, const unsigned char *m, unsigned int m_length,
                    unsigned char *sigret, unsigned int *siglen, void *key);
        int (*verify)(int type, const unsigned char *m, unsigned int m_length,
                      const unsigned char *sigbuf, unsigned int siglen,
                      void *key);
        int required_pkey_type[5]; /*EVP_PKEY_xxx */
        int block_size;
        int ctx_size; /* how big does the ctx->md_data need to be */
        /* control function */
        int (*md_ctrl)(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
        } /* EVP_MD */;

typedef int evp_sign_method(int type,const unsigned char *m,
                            unsigned int m_length,unsigned char *sigret,
                            unsigned int *siglen, void *key);
typedef int evp_verify_method(int type,const unsigned char *m,
                            unsigned int m_length,const unsigned char *sigbuf,
                            unsigned int siglen, void *key);









/* Digest uses EVP_PKEY_METHOD for signing instead of MD specific signing */



/* DigestAlgorithmIdentifier flags... */



/* NULL or absent parameter accepted. Use NULL */



/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */



/* Custom handling via ctrl */





/* Digest ctrls */




/* Minimum Algorithm specific ctrl value */





# 241 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

# 249 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

# 262 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"



struct env_md_ctx_st
        {
        const EVP_MD *digest;
        ENGINE *engine; /* functional reference if 'digest' is ENGINE-provided */
        unsigned long flags;
        void *md_data;
        /* Public key context for sign/verify */
        EVP_PKEY_CTX *pctx;
        /* Update function: usually copied from EVP_MD */
        int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
        } /* EVP_MD_CTX */;

/* values for EVP_MD_CTX flags */

# 285 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"
/* FIPS and pad options are ignored in 1.0.0, definitions are here
 * so we don't accidentally reuse the values for other purposes.
 */




/* The following PAD options are also currently ignored in 1.0.0, digest
 * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()
 * instead.
 */







struct evp_cipher_st
        {
        int nid;
        int block_size;
        int key_len;            /* Default value for variable length ciphers */
        int iv_len;
        unsigned long flags;    /* Various flags */
        int (*init)(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                    const unsigned char *iv, int enc);  /* init key */
        int (*do_cipher)(EVP_CIPHER_CTX *ctx, unsigned char *out,
                         const unsigned char *in, size_t inl);/* encrypt/decrypt data */
        int (*cleanup)(EVP_CIPHER_CTX *); /* cleanup ctx */
        int ctx_size;           /* how big ctx->cipher_data needs to be */
        int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Populate a ASN1_TYPE with parameters */
        int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */
        int (*ctrl)(EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Miscellaneous operations */
        void *app_data;         /* Application data */
        } /* EVP_CIPHER */;

/* Values for cipher flags */

/* Modes for ciphers */

# 336 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"
/* Set if variable length cipher */

/* Set if the iv handling should be done by the cipher itself */

/* Set if the cipher's init() function should be called if key is NULL */

/* Call ctrl() to init cipher parameters */

/* Don't use standard key length function */

/* Don't use standard block padding */

/* cipher handles random key generation */

/* cipher has its own additional copying logic */

/* Allow use default ASN1 get/set iv */

/* Buffer length in bits not bytes: CFB1 mode only */

/* Note if suitable for use in FIPS mode */

/* Allow non FIPS cipher in FIPS mode */

/* Cipher handles any and all padding logic as well
 * as finalisation.
 */



/* ctrl() values */

# 387 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"
/* AEAD cipher deduces payload length and returns number of bytes
 * required to store MAC and eventual padding. Subsequent call to
 * EVP_Cipher even appends/verifies MAC.
 */

/* Used by composite AEAD ciphers, no-op in GCM, CCM... */

/* Set the GCM invocation field, decrypt only */


/* GCM TLS constants */
/* Length of fixed part of IV derived from PRF */

/* Length of explicit part of IV part of TLS records */

/* Length of tag for TLS */


typedef struct evp_cipher_info_st
        {
        const EVP_CIPHER *cipher;
        unsigned char iv[16];
        } EVP_CIPHER_INFO;

struct evp_cipher_ctx_st
        {
        const EVP_CIPHER *cipher;
        ENGINE *engine; /* functional reference if 'cipher' is ENGINE-provided */
        int encrypt;            /* encrypt or decrypt */
        int buf_len;            /* number we have left */

        unsigned char  oiv[16];  /* original iv */
        unsigned char  iv[16];   /* working iv */
        unsigned char buf[32];/* saved partial block */
        int num;                                /* used by cfb/ofb/ctr mode */

        void *app_data;         /* application stuff */
        int key_len;            /* May change for variable length cipher */
        unsigned long flags;    /* Various flags */
        void *cipher_data; /* per EVP data */
        int final_used;
        int block_mask;
        unsigned char final[32];/* possible final block */
        } /* EVP_CIPHER_CTX */;

typedef struct evp_Encode_Ctx_st
        {
        int num;        /* number saved in a partial encode/decode */
        int length;     /* The length is either the output line length
                         * (in input bytes) or the shortest input line
                         * length that is ok.  Once decoding begins,
                         * the length is adjusted up each time a longer
                         * line is decoded */
        unsigned char enc_data[80];     /* data to encode */
        int line_num;   /* number read on current line */
        int expect_nl;
        } EVP_ENCODE_CTX;

/* Password based encryption function */
typedef int (EVP_PBE_KEYGEN)(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                ASN1_TYPE *param, const EVP_CIPHER *cipher,
                const EVP_MD *md, int en_de);





















/* Add some extra combinations */





int EVP_MD_type(const EVP_MD *md);


int EVP_MD_pkey_type(const EVP_MD *md); 
int EVP_MD_size(const EVP_MD *md);
int EVP_MD_block_size(const EVP_MD *md);
unsigned long EVP_MD_flags(const EVP_MD *md);

const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);




int EVP_CIPHER_nid(const EVP_CIPHER *cipher);

int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);


const EVP_CIPHER * EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
void * EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);

unsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);





# 522 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

# 533 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

int EVP_Cipher(EVP_CIPHER_CTX *c,
                unsigned char *out,
                const unsigned char *in,
                unsigned int inl);

# 547 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

void    EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int     EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
EVP_MD_CTX *EVP_MD_CTX_create(void);
void    EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
int     EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
void    EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
void    EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
int     EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx,int flags);
int     EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
int     EVP_DigestUpdate(EVP_MD_CTX *ctx,const void *d,
                         size_t cnt);
int     EVP_DigestFinal_ex(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
int     EVP_Digest(const void *data, size_t count,
                unsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl);

int     EVP_MD_CTX_copy(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
int     EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
int     EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);

int     EVP_read_pw_string(char *buf,int length,const char *prompt,int verify);
int     EVP_read_pw_string_min(char *buf,int minlen,int maxlen,const char *prompt,int verify);
void    EVP_set_pw_prompt(const char *prompt);
char *  EVP_get_pw_prompt(void);

int     EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
                const unsigned char *salt, const unsigned char *data,
                int datal, int count, unsigned char *key,unsigned char *iv);

void    EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
void    EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
int     EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx,int flags);

int     EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
                const unsigned char *key, const unsigned char *iv);
int     EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
                const unsigned char *key, const unsigned char *iv);
int     EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, const unsigned char *in, int inl);
int     EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
int     EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int     EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
                const unsigned char *key, const unsigned char *iv);
int     EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
                const unsigned char *key, const unsigned char *iv);
int     EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, const unsigned char *in, int inl);
int     EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
int     EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

int     EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
                       const unsigned char *key,const unsigned char *iv,
                       int enc);
int     EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
                       const unsigned char *key,const unsigned char *iv,
                       int enc);
int     EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                int *outl, const unsigned char *in, int inl);
int     EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
int     EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

int     EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s,
                EVP_PKEY *pkey);

int     EVP_VerifyFinal(EVP_MD_CTX *ctx,const unsigned char *sigbuf,
                unsigned int siglen,EVP_PKEY *pkey);

int     EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                        const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int     EVP_DigestSignFinal(EVP_MD_CTX *ctx,
                        unsigned char *sigret, size_t *siglen);

int     EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                        const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int     EVP_DigestVerifyFinal(EVP_MD_CTX *ctx,
                        unsigned char *sig, size_t siglen);

int     EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
                const unsigned char *ek, int ekl, const unsigned char *iv,
                EVP_PKEY *priv);
int     EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int     EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                 unsigned char **ek, int *ekl, unsigned char *iv,
                EVP_PKEY **pubk, int npubk);
int     EVP_SealFinal(EVP_CIPHER_CTX *ctx,unsigned char *out,int *outl);

void    EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
void    EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
                const unsigned char *in,int inl);
void    EVP_EncodeFinal(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl);
int     EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);

void    EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
int     EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
                const unsigned char *in, int inl);
int     EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned
                char *out, int *outl);
int     EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);


BIO_METHOD *BIO_f_md(void);
BIO_METHOD *BIO_f_base64(void);
BIO_METHOD *BIO_f_cipher(void);
BIO_METHOD *BIO_f_reliable(void);
void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,const unsigned char *k,
                const unsigned char *i, int enc);


const EVP_MD *EVP_md_null(void);

const EVP_MD *EVP_md2(void);


const EVP_MD *EVP_md4(void);


const EVP_MD *EVP_md5(void);


const EVP_MD *EVP_sha(void);
const EVP_MD *EVP_sha1(void);
const EVP_MD *EVP_dss(void);
const EVP_MD *EVP_dss1(void);
const EVP_MD *EVP_ecdsa(void);


const EVP_MD *EVP_sha224(void);
const EVP_MD *EVP_sha256(void);


const EVP_MD *EVP_sha384(void);
const EVP_MD *EVP_sha512(void);


const EVP_MD *EVP_mdc2(void);


const EVP_MD *EVP_ripemd160(void);


const EVP_MD *EVP_whirlpool(void);

const EVP_CIPHER *EVP_enc_null(void);           /* does nothing :-) */

const EVP_CIPHER *EVP_des_ecb(void);
const EVP_CIPHER *EVP_des_ede(void);
const EVP_CIPHER *EVP_des_ede3(void);
const EVP_CIPHER *EVP_des_ede_ecb(void);
const EVP_CIPHER *EVP_des_ede3_ecb(void);
const EVP_CIPHER *EVP_des_cfb64(void);

const EVP_CIPHER *EVP_des_cfb1(void);
const EVP_CIPHER *EVP_des_cfb8(void);
const EVP_CIPHER *EVP_des_ede_cfb64(void);





const EVP_CIPHER *EVP_des_ede3_cfb64(void);

const EVP_CIPHER *EVP_des_ede3_cfb1(void);
const EVP_CIPHER *EVP_des_ede3_cfb8(void);
const EVP_CIPHER *EVP_des_ofb(void);
const EVP_CIPHER *EVP_des_ede_ofb(void);
const EVP_CIPHER *EVP_des_ede3_ofb(void);
const EVP_CIPHER *EVP_des_cbc(void);
const EVP_CIPHER *EVP_des_ede_cbc(void);
const EVP_CIPHER *EVP_des_ede3_cbc(void);
const EVP_CIPHER *EVP_desx_cbc(void);
/* This should now be supported through the dev_crypto ENGINE. But also, why are
 * rc4 and md5 declarations made here inside a "NO_DES" precompiler branch? */
# 739 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"
const EVP_CIPHER *EVP_rc4(void);
const EVP_CIPHER *EVP_rc4_40(void);

const EVP_CIPHER *EVP_rc4_hmac_md5(void);



const EVP_CIPHER *EVP_idea_ecb(void);
const EVP_CIPHER *EVP_idea_cfb64(void);

const EVP_CIPHER *EVP_idea_ofb(void);
const EVP_CIPHER *EVP_idea_cbc(void);


const EVP_CIPHER *EVP_rc2_ecb(void);
const EVP_CIPHER *EVP_rc2_cbc(void);
const EVP_CIPHER *EVP_rc2_40_cbc(void);
const EVP_CIPHER *EVP_rc2_64_cbc(void);
const EVP_CIPHER *EVP_rc2_cfb64(void);

const EVP_CIPHER *EVP_rc2_ofb(void);


const EVP_CIPHER *EVP_bf_ecb(void);
const EVP_CIPHER *EVP_bf_cbc(void);
const EVP_CIPHER *EVP_bf_cfb64(void);

const EVP_CIPHER *EVP_bf_ofb(void);


const EVP_CIPHER *EVP_cast5_ecb(void);
const EVP_CIPHER *EVP_cast5_cbc(void);
const EVP_CIPHER *EVP_cast5_cfb64(void);

const EVP_CIPHER *EVP_cast5_ofb(void);


const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);
const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);
const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);

const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);


const EVP_CIPHER *EVP_aes_128_ecb(void);
const EVP_CIPHER *EVP_aes_128_cbc(void);
const EVP_CIPHER *EVP_aes_128_cfb1(void);
const EVP_CIPHER *EVP_aes_128_cfb8(void);
const EVP_CIPHER *EVP_aes_128_cfb128(void);

const EVP_CIPHER *EVP_aes_128_ofb(void);
const EVP_CIPHER *EVP_aes_128_ctr(void);
const EVP_CIPHER *EVP_aes_128_ccm(void);
const EVP_CIPHER *EVP_aes_128_gcm(void);
const EVP_CIPHER *EVP_aes_128_xts(void);
const EVP_CIPHER *EVP_aes_192_ecb(void);
const EVP_CIPHER *EVP_aes_192_cbc(void);
const EVP_CIPHER *EVP_aes_192_cfb1(void);
const EVP_CIPHER *EVP_aes_192_cfb8(void);
const EVP_CIPHER *EVP_aes_192_cfb128(void);

const EVP_CIPHER *EVP_aes_192_ofb(void);
const EVP_CIPHER *EVP_aes_192_ctr(void);
const EVP_CIPHER *EVP_aes_192_ccm(void);
const EVP_CIPHER *EVP_aes_192_gcm(void);
const EVP_CIPHER *EVP_aes_256_ecb(void);
const EVP_CIPHER *EVP_aes_256_cbc(void);
const EVP_CIPHER *EVP_aes_256_cfb1(void);
const EVP_CIPHER *EVP_aes_256_cfb8(void);
const EVP_CIPHER *EVP_aes_256_cfb128(void);

const EVP_CIPHER *EVP_aes_256_ofb(void);
const EVP_CIPHER *EVP_aes_256_ctr(void);
const EVP_CIPHER *EVP_aes_256_ccm(void);
const EVP_CIPHER *EVP_aes_256_gcm(void);
const EVP_CIPHER *EVP_aes_256_xts(void);

const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);



const EVP_CIPHER *EVP_camellia_128_ecb(void);
const EVP_CIPHER *EVP_camellia_128_cbc(void);
const EVP_CIPHER *EVP_camellia_128_cfb1(void);
const EVP_CIPHER *EVP_camellia_128_cfb8(void);
const EVP_CIPHER *EVP_camellia_128_cfb128(void);

const EVP_CIPHER *EVP_camellia_128_ofb(void);
const EVP_CIPHER *EVP_camellia_192_ecb(void);
const EVP_CIPHER *EVP_camellia_192_cbc(void);
const EVP_CIPHER *EVP_camellia_192_cfb1(void);
const EVP_CIPHER *EVP_camellia_192_cfb8(void);
const EVP_CIPHER *EVP_camellia_192_cfb128(void);

const EVP_CIPHER *EVP_camellia_192_ofb(void);
const EVP_CIPHER *EVP_camellia_256_ecb(void);
const EVP_CIPHER *EVP_camellia_256_cbc(void);
const EVP_CIPHER *EVP_camellia_256_cfb1(void);
const EVP_CIPHER *EVP_camellia_256_cfb8(void);
const EVP_CIPHER *EVP_camellia_256_cfb128(void);

const EVP_CIPHER *EVP_camellia_256_ofb(void);



const EVP_CIPHER *EVP_seed_ecb(void);
const EVP_CIPHER *EVP_seed_cbc(void);
const EVP_CIPHER *EVP_seed_cfb128(void);

const EVP_CIPHER *EVP_seed_ofb(void);


void OPENSSL_add_all_algorithms_noconf(void);
void OPENSSL_add_all_algorithms_conf(void);

# 862 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

void OpenSSL_add_all_ciphers(void);
void OpenSSL_add_all_digests(void);




int EVP_add_cipher(const EVP_CIPHER *cipher);
int EVP_add_digest(const EVP_MD *digest);

const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
const EVP_MD *EVP_get_digestbyname(const char *name);
void EVP_cleanup(void);

void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph,
                const char *from, const char *to, void *x), void *arg);
void EVP_CIPHER_do_all_sorted(void (*fn)(const EVP_CIPHER *ciph,
                const char *from, const char *to, void *x), void *arg);

void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph,
                const char *from, const char *to, void *x), void *arg);
void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph,
                const char *from, const char *to, void *x), void *arg);

int             EVP_PKEY_decrypt_old(unsigned char *dec_key,
                        const unsigned char *enc_key,int enc_key_len,
                        EVP_PKEY *private_key);
int             EVP_PKEY_encrypt_old(unsigned char *enc_key,
                        const unsigned char *key,int key_len,
                        EVP_PKEY *pub_key);
int             EVP_PKEY_type(int type);
int             EVP_PKEY_id(const EVP_PKEY *pkey);
int             EVP_PKEY_base_id(const EVP_PKEY *pkey);
int             EVP_PKEY_bits(EVP_PKEY *pkey);
int             EVP_PKEY_size(EVP_PKEY *pkey);
int             EVP_PKEY_set_type(EVP_PKEY *pkey,int type);
int             EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
int             EVP_PKEY_assign(EVP_PKEY *pkey,int type,void *key);
void *          EVP_PKEY_get0(EVP_PKEY *pkey);


struct rsa_st;
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,struct rsa_st *key);
struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);


struct dsa_st;
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,struct dsa_st *key);
struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);


struct dh_st;
int EVP_PKEY_set1_DH(EVP_PKEY *pkey,struct dh_st *key);
struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);


struct ec_key_st;
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,struct ec_key_st *key);
struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);


EVP_PKEY *      EVP_PKEY_new(void);
void            EVP_PKEY_free(EVP_PKEY *pkey);

EVP_PKEY *      d2i_PublicKey(int type,EVP_PKEY **a, const unsigned char **pp,
                        long length);
int             i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);

EVP_PKEY *      d2i_PrivateKey(int type,EVP_PKEY **a, const unsigned char **pp,
                        long length);
EVP_PKEY *      d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
                        long length);
int             i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);

int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);
int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
int EVP_PKEY_save_parameters(EVP_PKEY *pkey,int mode);
int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);

int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
                                int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
                                int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
                                int indent, ASN1_PCTX *pctx);

int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);

int EVP_CIPHER_type(const EVP_CIPHER *ctx);

/* calls methods */
int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

/* These are used by EVP_CIPHER methods */
int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);
int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);

/* PKCS5 password based encryption */
int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
                         int en_de);
int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
                           const unsigned char *salt, int saltlen, int iter,
                           int keylen, unsigned char *out);
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
                           const unsigned char *salt, int saltlen, int iter,
                           const EVP_MD *digest,
                      int keylen, unsigned char *out);
int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
                         int en_de);

void PKCS5_PBE_add(void);

int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
             ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);

/* PBE type */

/* Can appear as the outermost AlgorithmIdentifier */

/* Is an PRF type OID */


int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid,
             EVP_PBE_KEYGEN *keygen);
int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
                    EVP_PBE_KEYGEN *keygen);
int EVP_PBE_find(int type, int pbe_nid,
                        int *pcnid, int *pmnid, EVP_PBE_KEYGEN **pkeygen);
void EVP_PBE_cleanup(void);











int EVP_PKEY_asn1_get_count(void);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,
                                        const char *str, int len);
int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);
int EVP_PKEY_asn1_add_alias(int to, int from);
int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id, int *ppkey_flags,
                                const char **pinfo, const char **ppem_str,
                                        const EVP_PKEY_ASN1_METHOD *ameth);

const EVP_PKEY_ASN1_METHOD* EVP_PKEY_get0_asn1(EVP_PKEY *pkey);
EVP_PKEY_ASN1_METHOD* EVP_PKEY_asn1_new(int id, int flags,
                                        const char *pem_str, const char *info);
void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst, 
                        const EVP_PKEY_ASN1_METHOD *src);
void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);
void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,
                int (*pub_decode)(EVP_PKEY *pk, X509_PUBKEY *pub),
                int (*pub_encode)(X509_PUBKEY *pub, const EVP_PKEY *pk),
                int (*pub_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
                int (*pub_print)(BIO *out, const EVP_PKEY *pkey, int indent,
                                                        ASN1_PCTX *pctx),
                int (*pkey_size)(const EVP_PKEY *pk),
                int (*pkey_bits)(const EVP_PKEY *pk));
void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,
                int (*priv_decode)(EVP_PKEY *pk, PKCS8_PRIV_KEY_INFO *p8inf),
                int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pk),
                int (*priv_print)(BIO *out, const EVP_PKEY *pkey, int indent,
                                                        ASN1_PCTX *pctx));
void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,
                int (*param_decode)(EVP_PKEY *pkey,
                                const unsigned char **pder, int derlen),
                int (*param_encode)(const EVP_PKEY *pkey, unsigned char **pder),
                int (*param_missing)(const EVP_PKEY *pk),
                int (*param_copy)(EVP_PKEY *to, const EVP_PKEY *from),
                int (*param_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
                int (*param_print)(BIO *out, const EVP_PKEY *pkey, int indent,
                                                        ASN1_PCTX *pctx));

void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,
                void (*pkey_free)(EVP_PKEY *pkey));
void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,
                int (*pkey_ctrl)(EVP_PKEY *pkey, int op,
                                                        long arg1, void *arg2));


# 1065 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"






























/* Used by GOST key encryption in TLS */












/* Method handles all operations: don't assume any digest related
 * defaults.
 */


const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
EVP_PKEY_METHOD* EVP_PKEY_meth_new(int id, int flags);
void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
                                const EVP_PKEY_METHOD *meth);
void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);

EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
                                int cmd, int p1, void *p2);
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                                                const char *value);

int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);

EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
                                const unsigned char *key, int keylen);

void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);
EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);

EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);

void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);

int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
                        unsigned char *sig, size_t *siglen,
                        const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
                        const unsigned char *sig, size_t siglen,
                        const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
                        unsigned char *rout, size_t *routlen,
                        const unsigned char *sig, size_t siglen);
int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
                        unsigned char *out, size_t *outlen,
                        const unsigned char *in, size_t inlen);
int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
                        unsigned char *out, size_t *outlen,
                        const unsigned char *in, size_t inlen);

int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);

typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);

void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);

void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
        int (*init)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
        int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src));

void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
        void (*cleanup)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
        int (*paramgen_init)(EVP_PKEY_CTX *ctx),
        int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
        int (*keygen_init)(EVP_PKEY_CTX *ctx),
        int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
        int (*sign_init)(EVP_PKEY_CTX *ctx),
        int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
                                        const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
        int (*verify_init)(EVP_PKEY_CTX *ctx),
        int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
                                        const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
        int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
        int (*verify_recover)(EVP_PKEY_CTX *ctx,
                                        unsigned char *sig, size_t *siglen,
                                        const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
        int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
        int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
                                        EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
        int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
        int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
                                        EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
        int (*encrypt_init)(EVP_PKEY_CTX *ctx),
        int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
                                        const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
        int (*decrypt_init)(EVP_PKEY_CTX *ctx),
        int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
                                        const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
        int (*derive_init)(EVP_PKEY_CTX *ctx),
        int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen));

void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
        int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
        int (*ctrl_str)(EVP_PKEY_CTX *ctx,
                                        const char *type, const char *value));

void EVP_add_alg_module(void);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_EVP_strings(void);

/* Error codes for the EVP functions. */

/* Function codes. */
# 1333 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

/* Reason codes. */
# 1405 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/evp.h"

# 74 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2
# 81 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h" 1
/* crypto/ec/ec.h */
/*
 * Originally written by Bodo Moeller for the OpenSSL project.
 */
/**
 * \file crypto/ec/ec.h Include file for the OpenSSL EC functions
 * \author Originally written by Bodo Moeller for the OpenSSL project
 */
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * The elliptic curve binary polynomial software is originally written by 
 * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
 *
 */
















# 98 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h"

  




/** Enum for the point conversion form as defined in X9.62 (ECDSA)
 *  for the encoding of a elliptic curve point (x,y) */
typedef enum {
        /** the point is encoded as z||x, where the octet z specifies 
         *  which solution of the quadratic equation y is  */
        POINT_CONVERSION_COMPRESSED = 2,
        /** the point is encoded as z||x||y, where z is the octet 0x02  */
        POINT_CONVERSION_UNCOMPRESSED = 4,
        /** the point is encoded as z||x||y, where the octet z specifies
         *  which solution of the quadratic equation y is  */
        POINT_CONVERSION_HYBRID = 6
} point_conversion_form_t;


typedef struct ec_method_st EC_METHOD;

typedef struct ec_group_st
        /*
         EC_METHOD *meth;
         -- field definition
         -- curve coefficients
         -- optional generator with associated information (order, cofactor)
         -- optional extra data (precomputed table for fast computation of multiples of generator)
         -- ASN1 stuff
        */
        EC_GROUP;

typedef struct ec_point_st EC_POINT;


/********************************************************************/
/*               EC_METHODs for curves over GF(p)                   */       
/********************************************************************/

/** Returns the basic GFp ec methods which provides the basis for the
 *  optimized methods. 
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_simple_method(void);

/** Returns GFp methods using montgomery multiplication.
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_mont_method(void);

/** Returns GFp methods using optimized methods for NIST recommended curves
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nist_method(void);


/** Returns 64-bit optimized methods for nistp224
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nistp224_method(void);

/** Returns 64-bit optimized methods for nistp256
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nistp256_method(void);

/** Returns 64-bit optimized methods for nistp521
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nistp521_method(void);



/********************************************************************/ 
/*           EC_METHOD for curves over GF(2^m)                      */
/********************************************************************/

/** Returns the basic GF2m ec method 
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GF2m_simple_method(void);




/********************************************************************/
/*                   EC_GROUP functions                             */
/********************************************************************/

/** Creates a new EC_GROUP object
 *  \param   meth  EC_METHOD to use
 *  \return  newly created EC_GROUP object or NULL in case of an error.
 */
EC_GROUP *EC_GROUP_new(const EC_METHOD *meth);

/** Frees a EC_GROUP object
 *  \param  group  EC_GROUP object to be freed.
 */
void EC_GROUP_free(EC_GROUP *group);

/** Clears and frees a EC_GROUP object
 *  \param  group  EC_GROUP object to be cleared and freed.
 */
void EC_GROUP_clear_free(EC_GROUP *group);

/** Copies EC_GROUP objects. Note: both EC_GROUPs must use the same EC_METHOD.
 *  \param  dst  destination EC_GROUP object
 *  \param  src  source EC_GROUP object
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);

/** Creates a new EC_GROUP object and copies the copies the content
 *  form src to the newly created EC_KEY object
 *  \param  src  source EC_GROUP object
 *  \return newly created EC_GROUP object or NULL in case of an error.
 */
EC_GROUP *EC_GROUP_dup(const EC_GROUP *src);

/** Returns the EC_METHOD of the EC_GROUP object.
 *  \param  group  EC_GROUP object 
 *  \return EC_METHOD used in this EC_GROUP object.
 */
const EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);

/** Returns the field type of the EC_METHOD.
 *  \param  meth  EC_METHOD object
 *  \return NID of the underlying field type OID.
 */
int EC_METHOD_get_field_type(const EC_METHOD *meth);

/** Sets the generator and it's order/cofactor of a EC_GROUP object.
 *  \param  group      EC_GROUP object 
 *  \param  generator  EC_POINT object with the generator.
 *  \param  order      the order of the group generated by the generator.
 *  \param  cofactor   the index of the sub-group generated by the generator
 *                     in the group of all points on the elliptic curve.
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor);

/** Returns the generator of a EC_GROUP object.
 *  \param  group  EC_GROUP object
 *  \return the currently used generator (possibly NULL).
 */
const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);

/** Gets the order of a EC_GROUP
 *  \param  group  EC_GROUP object
 *  \param  order  BIGNUM to which the order is copied
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);

/** Gets the cofactor of a EC_GROUP
 *  \param  group     EC_GROUP object
 *  \param  cofactor  BIGNUM to which the cofactor is copied
 *  \param  ctx       BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx);

/** Sets the name of a EC_GROUP object
 *  \param  group  EC_GROUP object
 *  \param  nid    NID of the curve name OID
 */
void EC_GROUP_set_curve_name(EC_GROUP *group, int nid);

/** Returns the curve name of a EC_GROUP object
 *  \param  group  EC_GROUP object
 *  \return NID of the curve name OID or 0 if not set.
 */
int EC_GROUP_get_curve_name(const EC_GROUP *group);

void EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);
int EC_GROUP_get_asn1_flag(const EC_GROUP *group);

void EC_GROUP_set_point_conversion_form(EC_GROUP *group, point_conversion_form_t form);
point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);

unsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);
size_t EC_GROUP_get_seed_len(const EC_GROUP *);
size_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);

/** Sets the parameter of a ec over GFp defined by y^2 = x^3 + a*x + b
 *  \param  group  EC_GROUP object
 *  \param  p      BIGNUM with the prime number
 *  \param  a      BIGNUM with parameter a of the equation
 *  \param  b      BIGNUM with parameter b of the equation
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);

/** Gets the parameter of the ec over GFp defined by y^2 = x^3 + a*x + b
 *  \param  group  EC_GROUP object
 *  \param  p      BIGNUM for the prime number
 *  \param  a      BIGNUM for parameter a of the equation
 *  \param  b      BIGNUM for parameter b of the equation
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);


/** Sets the parameter of a ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b
 *  \param  group  EC_GROUP object
 *  \param  p      BIGNUM with the polynomial defining the underlying field
 *  \param  a      BIGNUM with parameter a of the equation
 *  \param  b      BIGNUM with parameter b of the equation
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);

/** Gets the parameter of the ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b
 *  \param  group  EC_GROUP object
 *  \param  p      BIGNUM for the polynomial defining the underlying field
 *  \param  a      BIGNUM for parameter a of the equation
 *  \param  b      BIGNUM for parameter b of the equation
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);

/** Returns the number of bits needed to represent a field element 
 *  \param  group  EC_GROUP object
 *  \return number of bits needed to represent a field element
 */
int EC_GROUP_get_degree(const EC_GROUP *group);

/** Checks whether the parameter in the EC_GROUP define a valid ec group
 *  \param  group  EC_GROUP object
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 if group is a valid ec group and 0 otherwise
 */
int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);

/** Checks whether the discriminant of the elliptic curve is zero or not
 *  \param  group  EC_GROUP object
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 if the discriminant is not zero and 0 otherwise
 */
int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);

/** Compares two EC_GROUP objects
 *  \param  a    first EC_GROUP object
 *  \param  b    second EC_GROUP object
 *  \param  ctx  BN_CTX object (optional)
 *  \return 0 if both groups are equal and 1 otherwise
 */
int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);

/* EC_GROUP_new_GF*() calls EC_GROUP_new() and EC_GROUP_set_GF*()
 * after choosing an appropriate EC_METHOD */

/** Creates a new EC_GROUP object with the specified parameters defined
 *  over GFp (defined by the equation y^2 = x^3 + a*x + b)
 *  \param  p    BIGNUM with the prime number
 *  \param  a    BIGNUM with the parameter a of the equation
 *  \param  b    BIGNUM with the parameter b of the equation
 *  \param  ctx  BN_CTX object (optional)
 *  \return newly created EC_GROUP object with the specified parameters
 */
EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);

/** Creates a new EC_GROUP object with the specified parameters defined
 *  over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)
 *  \param  p    BIGNUM with the polynomial defining the underlying field
 *  \param  a    BIGNUM with the parameter a of the equation
 *  \param  b    BIGNUM with the parameter b of the equation
 *  \param  ctx  BN_CTX object (optional)
 *  \return newly created EC_GROUP object with the specified parameters
 */
EC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);

/** Creates a EC_GROUP object with a curve specified by a NID
 *  \param  nid  NID of the OID of the curve name
 *  \return newly created EC_GROUP object with specified curve or NULL
 *          if an error occurred
 */
EC_GROUP *EC_GROUP_new_by_curve_name(int nid);


/********************************************************************/
/*               handling of internal curves                        */
/********************************************************************/

typedef struct { 
        int nid;
        const char *comment;
        } EC_builtin_curve;

/* EC_builtin_curves(EC_builtin_curve *r, size_t size) returns number 
 * of all available curves or zero if a error occurred. 
 * In case r ist not zero nitems EC_builtin_curve structures 
 * are filled with the data of the first nitems internal groups */
size_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);


/********************************************************************/
/*                    EC_POINT functions                            */
/********************************************************************/

/** Creates a new EC_POINT object for the specified EC_GROUP
 *  \param  group  EC_GROUP the underlying EC_GROUP object
 *  \return newly created EC_POINT object or NULL if an error occurred
 */
EC_POINT *EC_POINT_new(const EC_GROUP *group);

/** Frees a EC_POINT object
 *  \param  point  EC_POINT object to be freed
 */
void EC_POINT_free(EC_POINT *point);

/** Clears and frees a EC_POINT object
 *  \param  point  EC_POINT object to be cleared and freed
 */
void EC_POINT_clear_free(EC_POINT *point);

/** Copies EC_POINT object
 *  \param  dst  destination EC_POINT object
 *  \param  src  source EC_POINT object
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);

/** Creates a new EC_POINT object and copies the content of the supplied
 *  EC_POINT
 *  \param  src    source EC_POINT object
 *  \param  group  underlying the EC_GROUP object
 *  \return newly created EC_POINT object or NULL if an error occurred 
 */
EC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);
 
/** Returns the EC_METHOD used in EC_POINT object 
 *  \param  point  EC_POINT object
 *  \return the EC_METHOD used
 */
const EC_METHOD *EC_POINT_method_of(const EC_POINT *point);

/** Sets a point to infinity (neutral element)
 *  \param  group  underlying EC_GROUP object
 *  \param  point  EC_POINT to set to infinity
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);

/** Sets the jacobian projective coordinates of a EC_POINT over GFp
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM with the x-coordinate
 *  \param  y      BIGNUM with the y-coordinate
 *  \param  z      BIGNUM with the z-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,
        const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx);

/** Gets the jacobian projective coordinates of a EC_POINT over GFp
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM for the x-coordinate
 *  \param  y      BIGNUM for the y-coordinate
 *  \param  z      BIGNUM for the z-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx);

/** Sets the affine coordinates of a EC_POINT over GFp
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM with the x-coordinate
 *  \param  y      BIGNUM with the y-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,
        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);

/** Gets the affine coordinates of a EC_POINT over GFp
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM for the x-coordinate
 *  \param  y      BIGNUM for the y-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);

/** Sets the x9.62 compressed coordinates of a EC_POINT over GFp
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM with x-coordinate
 *  \param  y_bit  integer with the y-Bit (either 0 or 1)
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,
        const BIGNUM *x, int y_bit, BN_CTX *ctx);

/** Sets the affine coordinates of a EC_POINT over GF2m
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM with the x-coordinate
 *  \param  y      BIGNUM with the y-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,
        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);

/** Gets the affine coordinates of a EC_POINT over GF2m
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM for the x-coordinate
 *  \param  y      BIGNUM for the y-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);

/** Sets the x9.62 compressed coordinates of a EC_POINT over GF2m
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM with x-coordinate
 *  \param  y_bit  integer with the y-Bit (either 0 or 1)
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,
        const BIGNUM *x, int y_bit, BN_CTX *ctx);

/** Encodes a EC_POINT object to a octet string
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  form   point conversion form
 *  \param  buf    memory buffer for the result. If NULL the function returns
 *                 required buffer size.
 *  \param  len    length of the memory buffer
 *  \param  ctx    BN_CTX object (optional)
 *  \return the length of the encoded octet string or 0 if an error occurred
 */
size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,
        point_conversion_form_t form,
        unsigned char *buf, size_t len, BN_CTX *ctx);

/** Decodes a EC_POINT from a octet string
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  buf    memory buffer with the encoded ec point
 *  \param  len    length of the encoded ec point
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,
        const unsigned char *buf, size_t len, BN_CTX *ctx);

/* other interfaces to point2oct/oct2point: */
BIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,
        point_conversion_form_t form, BIGNUM *, BN_CTX *);
EC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,
        EC_POINT *, BN_CTX *);
char *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,
        point_conversion_form_t form, BN_CTX *);
EC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,
        EC_POINT *, BN_CTX *);


/********************************************************************/
/*         functions for doing EC_POINT arithmetic                  */
/********************************************************************/

/** Computes the sum of two EC_POINT 
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result (r = a + b)
 *  \param  a      EC_POINT object with the first summand
 *  \param  b      EC_POINT object with the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);

/** Computes the double of a EC_POINT
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result (r = 2 * a)
 *  \param  a      EC_POINT object 
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx);

/** Computes the inverse of a EC_POINT
 *  \param  group  underlying EC_GROUP object
 *  \param  a      EC_POINT object to be inverted (it's used for the result as well)
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);

/** Checks whether the point is the neutral element of the group
 *  \param  group  the underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \return 1 if the point is the neutral element and 0 otherwise
 */
int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);

/** Checks whether the point is on the curve 
 *  \param  group  underlying EC_GROUP object
 *  \param  point  EC_POINT object to check
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 if point if on the curve and 0 otherwise
 */
int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx);

/** Compares two EC_POINTs 
 *  \param  group  underlying EC_GROUP object
 *  \param  a      first EC_POINT object
 *  \param  b      second EC_POINT object
 *  \param  ctx    BN_CTX object (optional)
 *  \return 0 if both points are equal and a value != 0 otherwise
 */
int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);

int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);
int EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx);

/** Computes r = generator * n sum_{i=0}^{num-1} p[i] * m[i]
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  num    number futher summands
 *  \param  p      array of size num of EC_POINT objects
 *  \param  m      array of size num of BIGNUM objects
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, size_t num, const EC_POINT *p[], const BIGNUM *m[], BN_CTX *ctx);

/** Computes r = generator * n + q * m
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  q      EC_POINT object with the first factor of the second summand
 *  \param  m      BIGNUM with the second factor of the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);

/** Stores multiples of generator for faster point multiplication
 *  \param  group  EC_GROUP object
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occured
 */
int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);

/** Reports whether a precomputation has been done
 *  \param  group  EC_GROUP object
 *  \return 1 if a pre-computation has been done and 0 otherwise
 */
int EC_GROUP_have_precompute_mult(const EC_GROUP *group);


/********************************************************************/
/*                       ASN1 stuff                                 */
/********************************************************************/

/* EC_GROUP_get_basis_type() returns the NID of the basis type
 * used to represent the field elements */
int EC_GROUP_get_basis_type(const EC_GROUP *);

int EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);
int EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1, 
        unsigned int *k2, unsigned int *k3);




typedef struct ecpk_parameters_st ECPKPARAMETERS;

EC_GROUP *d2i_ECPKParameters(EC_GROUP **, const unsigned char **in, long len);
int i2d_ECPKParameters(const EC_GROUP *, unsigned char **out);

# 695 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h"


int     ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);


int     ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);



/********************************************************************/
/*                      EC_KEY functions                            */
/********************************************************************/

typedef struct ec_key_st EC_KEY;

/* some values for the encoding_flag */



/* some values for the flags field */



/** Creates a new EC_KEY object.
 *  \return EC_KEY object or NULL if an error occurred.
 */
EC_KEY *EC_KEY_new(void);

int EC_KEY_get_flags(const EC_KEY *key);

void EC_KEY_set_flags(EC_KEY *key, int flags);

void EC_KEY_clear_flags(EC_KEY *key, int flags);

/** Creates a new EC_KEY object using a named curve as underlying
 *  EC_GROUP object.
 *  \param  nid  NID of the named curve.
 *  \return EC_KEY object or NULL if an error occurred. 
 */
EC_KEY *EC_KEY_new_by_curve_name(int nid);

/** Frees a EC_KEY object.
 *  \param  key  EC_KEY object to be freed.
 */
void EC_KEY_free(EC_KEY *key);

/** Copies a EC_KEY object.
 *  \param  dst  destination EC_KEY object
 *  \param  src  src EC_KEY object
 *  \return dst or NULL if an error occurred.
 */
EC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);

/** Creates a new EC_KEY object and copies the content from src to it.
 *  \param  src  the source EC_KEY object
 *  \return newly created EC_KEY object or NULL if an error occurred.
 */
EC_KEY *EC_KEY_dup(const EC_KEY *src);

/** Increases the internal reference count of a EC_KEY object.
 *  \param  key  EC_KEY object
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_up_ref(EC_KEY *key);

/** Returns the EC_GROUP object of a EC_KEY object
 *  \param  key  EC_KEY object
 *  \return the EC_GROUP object (possibly NULL).
 */
const EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);

/** Sets the EC_GROUP of a EC_KEY object.
 *  \param  key    EC_KEY object
 *  \param  group  EC_GROUP to use in the EC_KEY object (note: the EC_KEY
 *                 object will use an own copy of the EC_GROUP).
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);

/** Returns the private key of a EC_KEY object.
 *  \param  key  EC_KEY object
 *  \return a BIGNUM with the private key (possibly NULL).
 */
const BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);

/** Sets the private key of a EC_KEY object.
 *  \param  key  EC_KEY object
 *  \param  prv  BIGNUM with the private key (note: the EC_KEY object
 *               will use an own copy of the BIGNUM).
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);

/** Returns the public key of a EC_KEY object.
 *  \param  key  the EC_KEY object
 *  \return a EC_POINT object with the public key (possibly NULL)
 */
const EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);

/** Sets the public key of a EC_KEY object.
 *  \param  key  EC_KEY object
 *  \param  pub  EC_POINT object with the public key (note: the EC_KEY object
 *               will use an own copy of the EC_POINT object).
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);

unsigned EC_KEY_get_enc_flags(const EC_KEY *key);
void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);
point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);
void EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);
/* functions to set/get method specific data  */
void *EC_KEY_get_key_method_data(EC_KEY *key, 
        void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));
/** Sets the key method data of an EC_KEY object, if none has yet been set.
 *  \param  key              EC_KEY object
 *  \param  data             opaque data to install.
 *  \param  dup_func         a function that duplicates |data|.
 *  \param  free_func        a function that frees |data|.
 *  \param  clear_free_func  a function that wipes and frees |data|.
 *  \return the previously set data pointer, or NULL if |data| was inserted.
 */
void *EC_KEY_insert_key_method_data(EC_KEY *key, void *data,
        void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *));
/* wrapper functions for the underlying EC_GROUP object */
void EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);

/** Creates a table of pre-computed multiples of the generator to 
 *  accelerate further EC_KEY operations.
 *  \param  key  EC_KEY object
 *  \param  ctx  BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);

/** Creates a new ec private (and optional a new public) key.
 *  \param  key  EC_KEY object
 *  \return 1 on success and 0 if an error occurred.
 */
int EC_KEY_generate_key(EC_KEY *key);

/** Verifies that a private and/or public key is valid.
 *  \param  key  the EC_KEY object
 *  \return 1 on success and 0 otherwise.
 */
int EC_KEY_check_key(const EC_KEY *key);

/** Sets a public key from affine coordindates performing
 *  neccessary NIST PKV tests.
 *  \param  key  the EC_KEY object
 *  \param  x    public key x coordinate
 *  \param  y    public key y coordinate
 *  \return 1 on success and 0 otherwise.
 */
int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x, BIGNUM *y);


/********************************************************************/
/*        de- and encoding functions for SEC1 ECPrivateKey          */
/********************************************************************/

/** Decodes a private key from a memory buffer.
 *  \param  key  a pointer to a EC_KEY object which should be used (or NULL)
 *  \param  in   pointer to memory with the DER encoded private key
 *  \param  len  length of the DER encoded private key
 *  \return the decoded private key or NULL if an error occurred.
 */
EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);

/** Encodes a private key object and stores the result in a buffer.
 *  \param  key  the EC_KEY object to encode
 *  \param  out  the buffer for the result (if NULL the function returns number
 *               of bytes needed).
 *  \return 1 on success and 0 if an error occurred.
 */
int i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);


/********************************************************************/
/*        de- and encoding functions for EC parameters              */
/********************************************************************/

/** Decodes ec parameter from a memory buffer.
 *  \param  key  a pointer to a EC_KEY object which should be used (or NULL)
 *  \param  in   pointer to memory with the DER encoded ec parameters
 *  \param  len  length of the DER encoded ec parameters
 *  \return a EC_KEY object with the decoded parameters or NULL if an error
 *          occurred.
 */
EC_KEY *d2i_ECParameters(EC_KEY **key, const unsigned char **in, long len);

/** Encodes ec parameter and stores the result in a buffer.
 *  \param  key  the EC_KEY object with ec paramters to encode
 *  \param  out  the buffer for the result (if NULL the function returns number
 *               of bytes needed).
 *  \return 1 on success and 0 if an error occurred.
 */
int i2d_ECParameters(EC_KEY *key, unsigned char **out);


/********************************************************************/
/*         de- and encoding functions for EC public key             */
/*         (octet string, not DER -- hence 'o2i' and 'i2o')         */
/********************************************************************/

/** Decodes a ec public key from a octet string.
 *  \param  key  a pointer to a EC_KEY object which should be used
 *  \param  in   memory buffer with the encoded public key
 *  \param  len  length of the encoded public key
 *  \return EC_KEY object with decoded public key or NULL if an error
 *          occurred.
 */
EC_KEY *o2i_ECPublicKey(EC_KEY **key, const unsigned char **in, long len);

/** Encodes a ec public key in an octet string.
 *  \param  key  the EC_KEY object with the public key
 *  \param  out  the buffer for the result (if NULL the function returns number
 *               of bytes needed).
 *  \return 1 on success and 0 if an error occurred
 */
int i2o_ECPublicKey(EC_KEY *key, unsigned char **out);


/** Prints out the ec parameters on human readable form.
 *  \param  bp   BIO object to which the information is printed
 *  \param  key  EC_KEY object
 *  \return 1 on success and 0 if an error occurred
 */
int     ECParameters_print(BIO *bp, const EC_KEY *key);

/** Prints out the contents of a EC_KEY object
 *  \param  bp   BIO object to which the information is printed
 *  \param  key  EC_KEY object
 *  \param  off  line offset 
 *  \return 1 on success and 0 if an error occurred
 */
int     EC_KEY_print(BIO *bp, const EC_KEY *key, int off);



/** Prints out the ec parameters on human readable form.
 *  \param  fp   file descriptor to which the information is printed
 *  \param  key  EC_KEY object
 *  \return 1 on success and 0 if an error occurred
 */
int     ECParameters_print_fp(FILE *fp, const EC_KEY *key);

/** Prints out the contents of a EC_KEY object
 *  \param  fp   file descriptor to which the information is printed
 *  \param  key  EC_KEY object
 *  \param  off  line offset 
 *  \return 1 on success and 0 if an error occurred
 */
int     EC_KEY_print_fp(FILE *fp, const EC_KEY *key, int off);





# 961 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h"








/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_EC_strings(void);

/* Error codes for the EC functions. */

/* Function codes. */
# 1114 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h"

/* Reason codes. */
# 1163 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ec.h"

# 84 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2


# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ecdsa.h" 1
/* crypto/ecdsa/ecdsa.h */
/**
 * \file   crypto/ecdsa/ecdsa.h Include file for the OpenSSL ECDSA functions
 * \author Written by Nils Larsch for the OpenSSL project
 */
/* ====================================================================
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



















typedef struct ECDSA_SIG_st
        {
        BIGNUM *r;
        BIGNUM *s;
        } ECDSA_SIG;

/** Allocates and initialize a ECDSA_SIG structure
 *  \return pointer to a ECDSA_SIG structure or NULL if an error occurred
 */
ECDSA_SIG *ECDSA_SIG_new(void);

/** frees a ECDSA_SIG structure
 *  \param  sig  pointer to the ECDSA_SIG structure
 */
void      ECDSA_SIG_free(ECDSA_SIG *sig);

/** DER encode content of ECDSA_SIG object (note: this function modifies *pp
 *  (*pp += length of the DER encoded signature)).
 *  \param  sig  pointer to the ECDSA_SIG object
 *  \param  pp   pointer to a unsigned char pointer for the output or NULL
 *  \return the length of the DER encoded ECDSA_SIG object or 0 
 */
int       i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);

/** Decodes a DER encoded ECDSA signature (note: this function changes *pp
 *  (*pp += len)). 
 *  \param  sig  pointer to ECDSA_SIG pointer (may be NULL)
 *  \param  pp   memory buffer with the DER encoded signature
 *  \param  len  length of the buffer
 *  \return pointer to the decoded ECDSA_SIG structure (or NULL)
 */
ECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);

/** Computes the ECDSA signature of the given hash value using
 *  the supplied private key and returns the created signature.
 *  \param  dgst      pointer to the hash value
 *  \param  dgst_len  length of the hash value
 *  \param  eckey     EC_KEY object containing a private EC key
 *  \return pointer to a ECDSA_SIG structure or NULL if an error occurred
 */
ECDSA_SIG *ECDSA_do_sign(const unsigned char *dgst,int dgst_len,EC_KEY *eckey);

/** Computes ECDSA signature of a given hash value using the supplied
 *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).
 *  \param  dgst     pointer to the hash value to sign
 *  \param  dgstlen  length of the hash value
 *  \param  kinv     BIGNUM with a pre-computed inverse k (optional)
 *  \param  rp       BIGNUM with a pre-computed rp value (optioanl), 
 *                   see ECDSA_sign_setup
 *  \param  eckey    EC_KEY object containing a private EC key
 *  \return pointer to a ECDSA_SIG structure or NULL if an error occurred
 */
ECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, 
                const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey);

/** Verifies that the supplied signature is a valid ECDSA
 *  signature of the supplied hash value using the supplied public key.
 *  \param  dgst      pointer to the hash value
 *  \param  dgst_len  length of the hash value
 *  \param  sig       ECDSA_SIG structure
 *  \param  eckey     EC_KEY object containing a public EC key
 *  \return 1 if the signature is valid, 0 if the signature is invalid
 *          and -1 on error
 */
int       ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
                const ECDSA_SIG *sig, EC_KEY* eckey);

const ECDSA_METHOD *ECDSA_OpenSSL(void);

/** Sets the default ECDSA method
 *  \param  meth  new default ECDSA_METHOD
 */
void      ECDSA_set_default_method(const ECDSA_METHOD *meth);

/** Returns the default ECDSA method
 *  \return pointer to ECDSA_METHOD structure containing the default method
 */
const ECDSA_METHOD *ECDSA_get_default_method(void);

/** Sets method to be used for the ECDSA operations
 *  \param  eckey  EC_KEY object
 *  \param  meth   new method
 *  \return 1 on success and 0 otherwise 
 */
int       ECDSA_set_method(EC_KEY *eckey, const ECDSA_METHOD *meth);

/** Returns the maximum length of the DER encoded signature
 *  \param  eckey  EC_KEY object
 *  \return numbers of bytes required for the DER encoded signature
 */
int       ECDSA_size(const EC_KEY *eckey);

/** Precompute parts of the signing operation
 *  \param  eckey  EC_KEY object containing a private EC key
 *  \param  ctx    BN_CTX object (optional)
 *  \param  kinv   BIGNUM pointer for the inverse of k
 *  \param  rp     BIGNUM pointer for x coordinate of k * generator
 *  \return 1 on success and 0 otherwise
 */
int       ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, 
                BIGNUM **rp);

/** Computes ECDSA signature of a given hash value using the supplied
 *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).
 *  \param  type     this parameter is ignored
 *  \param  dgst     pointer to the hash value to sign
 *  \param  dgstlen  length of the hash value
 *  \param  sig      memory for the DER encoded created signature
 *  \param  siglen   pointer to the length of the returned signature
 *  \param  eckey    EC_KEY object containing a private EC key
 *  \return 1 on success and 0 otherwise
 */
int       ECDSA_sign(int type, const unsigned char *dgst, int dgstlen, 
                unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);


/** Computes ECDSA signature of a given hash value using the supplied
 *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).
 *  \param  type     this parameter is ignored
 *  \param  dgst     pointer to the hash value to sign
 *  \param  dgstlen  length of the hash value
 *  \param  sig      buffer to hold the DER encoded signature
 *  \param  siglen   pointer to the length of the returned signature
 *  \param  kinv     BIGNUM with a pre-computed inverse k (optional)
 *  \param  rp       BIGNUM with a pre-computed rp value (optioanl), 
 *                   see ECDSA_sign_setup
 *  \param  eckey    EC_KEY object containing a private EC key
 *  \return 1 on success and 0 otherwise
 */
int       ECDSA_sign_ex(int type, const unsigned char *dgst, int dgstlen, 
                unsigned char *sig, unsigned int *siglen, const BIGNUM *kinv,
                const BIGNUM *rp, EC_KEY *eckey);

/** Verifies that the given signature is valid ECDSA signature
 *  of the supplied hash value using the specified public key.
 *  \param  type     this parameter is ignored
 *  \param  dgst     pointer to the hash value 
 *  \param  dgstlen  length of the hash value
 *  \param  sig      pointer to the DER encoded signature
 *  \param  siglen   length of the DER encoded signature
 *  \param  eckey    EC_KEY object containing a public EC key
 *  \return 1 if the signature is valid, 0 if the signature is invalid
 *          and -1 on error
 */
int       ECDSA_verify(int type, const unsigned char *dgst, int dgstlen, 
                const unsigned char *sig, int siglen, EC_KEY *eckey);

/* the standard ex_data functions */
int       ECDSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new 
                *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int       ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);
void      *ECDSA_get_ex_data(EC_KEY *d, int idx);


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_ECDSA_strings(void);

/* Error codes for the ECDSA functions. */

/* Function codes. */






/* Reason codes. */
# 256 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ecdsa.h"

# 88 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2


# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ecdh.h" 1
/* crypto/ecdh/ecdh.h */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * The Elliptic Curve Public-Key Crypto Library (ECC Code) included
 * herein is developed by SUN MICROSYSTEMS, INC., and is contributed
 * to the OpenSSL project.
 *
 * The ECC Code is licensed pursuant to the OpenSSL open source
 * license provided below.
 *
 * The ECDH software is originally written by Douglas Stebila of
 * Sun Microsystems Laboratories.
 *
 */
/* ====================================================================
 * Copyright (c) 2000-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



















const ECDH_METHOD *ECDH_OpenSSL(void);

void      ECDH_set_default_method(const ECDH_METHOD *);
const ECDH_METHOD *ECDH_get_default_method(void);
int       ECDH_set_method(EC_KEY *, const ECDH_METHOD *);

int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh,
                     void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen));

int       ECDH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new 
                *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int       ECDH_set_ex_data(EC_KEY *d, int idx, void *arg);
void      *ECDH_get_ex_data(EC_KEY *d, int idx);


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_ECDH_strings(void);

/* Error codes for the ECDH functions. */

/* Function codes. */




/* Reason codes. */





# 92 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2


# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h" 1
/* crypto/rsa/rsa.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */






# 72 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h"









/* Declared already in ossl_typ.h */
/* typedef struct rsa_st RSA; */
/* typedef struct rsa_meth_st RSA_METHOD; */

struct rsa_meth_st
        {
        const char *name;
        int (*rsa_pub_enc)(int flen,const unsigned char *from,
                           unsigned char *to,
                           RSA *rsa,int padding);
        int (*rsa_pub_dec)(int flen,const unsigned char *from,
                           unsigned char *to,
                           RSA *rsa,int padding);
        int (*rsa_priv_enc)(int flen,const unsigned char *from,
                            unsigned char *to,
                            RSA *rsa,int padding);
        int (*rsa_priv_dec)(int flen,const unsigned char *from,
                            unsigned char *to,
                            RSA *rsa,int padding);
        int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa,BN_CTX *ctx); /* Can be null */
        int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                          const BIGNUM *m, BN_CTX *ctx,
                          BN_MONT_CTX *m_ctx); /* Can be null */
        int (*init)(RSA *rsa);          /* called at new */
        int (*finish)(RSA *rsa);        /* called at free */
        int flags;                      /* RSA_METHOD_FLAG_* things */
        char *app_data;                 /* may be needed! */
/* New sign and verify functions: some libraries don't allow arbitrary data
 * to be signed/verified: this allows them to be used. Note: for this to work
 * the RSA_public_decrypt() and RSA_private_encrypt() should *NOT* be used
 * RSA_sign(), RSA_verify() should be used instead. Note: for backwards
 * compatibility this functionality is only enabled if the RSA_FLAG_SIGN_VER
 * option is set in 'flags'.
 */
        int (*rsa_sign)(int type,
                const unsigned char *m, unsigned int m_length,
                unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
        int (*rsa_verify)(int dtype,
                const unsigned char *m, unsigned int m_length,
                const unsigned char *sigbuf, unsigned int siglen,
                                                                const RSA *rsa);
/* If this callback is NULL, the builtin software RSA key-gen will be used. This
 * is for behavioural compatibility whilst the code gets rewired, but one day
 * it would be nice to assume there are no such things as "builtin software"
 * implementations. */
        int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
        };

struct rsa_st
        {
        /* The first parameter is used to pickup errors where
         * this is passed instead of aEVP_PKEY, it is set to 0 */
        int pad;
        long version;
        const RSA_METHOD *meth;
        /* functional reference if 'meth' is ENGINE-provided */
        ENGINE *engine;
        BIGNUM *n;
        BIGNUM *e;
        BIGNUM *d;
        BIGNUM *p;
        BIGNUM *q;
        BIGNUM *dmp1;
        BIGNUM *dmq1;
        BIGNUM *iqmp;
        /* be careful using this if the RSA structure is shared */
        CRYPTO_EX_DATA ex_data;
        int references;
        int flags;

        /* Used to cache montgomery values */
        BN_MONT_CTX *_method_mod_n;
        BN_MONT_CTX *_method_mod_p;
        BN_MONT_CTX *_method_mod_q;

        /* all BIGNUM values are actually in the following data, if it is not
         * NULL */
        char *bignum_data;
        BN_BLINDING *blinding;
        BN_BLINDING *mt_blinding;
        };





# 173 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h"










/* This flag means the private key operations will be handled by rsa_mod_exp
 * and that they do not depend on the private key components being present:
 * for example a key stored in external hardware. Without this flag bn_mod_exp
 * gets called when private key components are absent.
 */


/* This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
 */


# 211 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h"
                                                /* new with 0.9.7h; the built-in RSA
                                                * implementation now uses constant time
                                                * modular exponentiation for secret exponents
                                                * by default. This flag causes the
                                                * faster variable sliding window method to
                                                * be used for all exponents.
                                                */























































/* EVP_PKEY_ only */







RSA *   RSA_new(void);
RSA *   RSA_new_method(ENGINE *engine);
int     RSA_size(const RSA *rsa);

/* Deprecated version */

RSA *   RSA_generate_key(int bits, unsigned long e,void
                (*callback)(int,int,void *),void *cb_arg);


/* New version */
int     RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

int     RSA_check_key(const RSA *);
        /* next 4 return -1 on error */
int     RSA_public_encrypt(int flen, const unsigned char *from,
                unsigned char *to, RSA *rsa,int padding);
int     RSA_private_encrypt(int flen, const unsigned char *from,
                unsigned char *to, RSA *rsa,int padding);
int     RSA_public_decrypt(int flen, const unsigned char *from, 
                unsigned char *to, RSA *rsa,int padding);
int     RSA_private_decrypt(int flen, const unsigned char *from, 
                unsigned char *to, RSA *rsa,int padding);
void    RSA_free (RSA *r);
/* "up" the RSA object's reference count */
int     RSA_up_ref(RSA *r);

int     RSA_flags(const RSA *r);

void RSA_set_default_method(const RSA_METHOD *meth);
const RSA_METHOD *RSA_get_default_method(void);
const RSA_METHOD *RSA_get_method(const RSA *rsa);
int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);

/* This function needs the memory locking malloc callbacks to be installed */
int RSA_memory_lock(RSA *r);

/* these are the actual SSLeay RSA functions */
const RSA_METHOD *RSA_PKCS1_SSLeay(void);

const RSA_METHOD *RSA_null_method(void);

RSA *d2i_RSAPublicKey(RSA * *a, const unsigned char * *in, long len); int i2d_RSAPublicKey(const RSA *a, unsigned char * *out); extern const ASN1_ITEM RSAPublicKey_it;
RSA *d2i_RSAPrivateKey(RSA * *a, const unsigned char * *in, long len); int i2d_RSAPrivateKey(const RSA *a, unsigned char * *out); extern const ASN1_ITEM RSAPrivateKey_it;

typedef struct rsa_pss_params_st
        {
        X509_ALGOR *hashAlgorithm;
        X509_ALGOR *maskGenAlgorithm;
        ASN1_INTEGER *saltLength;
        ASN1_INTEGER *trailerField;
        } RSA_PSS_PARAMS;

RSA_PSS_PARAMS *RSA_PSS_PARAMS_new(void); void RSA_PSS_PARAMS_free(RSA_PSS_PARAMS *a); RSA_PSS_PARAMS *d2i_RSA_PSS_PARAMS(RSA_PSS_PARAMS * *a, const unsigned char * *in, long len); int i2d_RSA_PSS_PARAMS(RSA_PSS_PARAMS *a, unsigned char * *out); extern const ASN1_ITEM RSA_PSS_PARAMS_it;


int     RSA_print_fp(FILE *fp, const RSA *r,int offset);



int     RSA_print(BIO *bp, const RSA *r,int offset);



int i2d_RSA_NET(const RSA *a, unsigned char **pp,
                int (*cb)(char *buf, int len, const char *prompt, int verify),
                int sgckey);
RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,
                 int (*cb)(char *buf, int len, const char *prompt, int verify),
                 int sgckey);

int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,
                     int (*cb)(char *buf, int len, const char *prompt,
                               int verify));
RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,
                      int (*cb)(char *buf, int len, const char *prompt,
                                int verify));


/* The following 2 functions sign and verify a X509_SIG ASN1 object
 * inside PKCS#1 padded RSA encryption */
int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
        unsigned char *sigret, unsigned int *siglen, RSA *rsa);
int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
        const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);

/* The following 2 function sign and verify a ASN1_OCTET_STRING
 * object inside PKCS#1 padded RSA encryption */
int RSA_sign_ASN1_OCTET_STRING(int type,
        const unsigned char *m, unsigned int m_length,
        unsigned char *sigret, unsigned int *siglen, RSA *rsa);
int RSA_verify_ASN1_OCTET_STRING(int type,
        const unsigned char *m, unsigned int m_length,
        unsigned char *sigbuf, unsigned int siglen, RSA *rsa);

int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
void RSA_blinding_off(RSA *rsa);
BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);

int RSA_padding_add_PKCS1_type_1(unsigned char *to,int tlen,
        const unsigned char *f,int fl);
int RSA_padding_check_PKCS1_type_1(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_PKCS1_type_2(unsigned char *to,int tlen,
        const unsigned char *f,int fl);
int RSA_padding_check_PKCS1_type_2(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len);
int PKCS1_MGF1(unsigned char *mask, long len,
        const unsigned char *seed, long seedlen, const EVP_MD *dgst);
int RSA_padding_add_PKCS1_OAEP(unsigned char *to,int tlen,
        const unsigned char *f,int fl,
        const unsigned char *p,int pl);
int RSA_padding_check_PKCS1_OAEP(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len,
        const unsigned char *p,int pl);
int RSA_padding_add_SSLv23(unsigned char *to,int tlen,
        const unsigned char *f,int fl);
int RSA_padding_check_SSLv23(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_none(unsigned char *to,int tlen,
        const unsigned char *f,int fl);
int RSA_padding_check_none(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_X931(unsigned char *to,int tlen,
        const unsigned char *f,int fl);
int RSA_padding_check_X931(unsigned char *to,int tlen,
        const unsigned char *f,int fl,int rsa_len);
int RSA_X931_hash_id(int nid);

int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
                        const EVP_MD *Hash, const unsigned char *EM, int sLen);
int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
                        const unsigned char *mHash,
                        const EVP_MD *Hash, int sLen);

int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
                        const EVP_MD *Hash, const EVP_MD *mgf1Hash, 
                        const unsigned char *EM, int sLen);

int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
                        const unsigned char *mHash,
                        const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen);

int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int RSA_set_ex_data(RSA *r,int idx,void *arg);
void *RSA_get_ex_data(const RSA *r, int idx);

RSA *RSAPublicKey_dup(RSA *rsa);
RSA *RSAPrivateKey_dup(RSA *rsa);

/* If this flag is set the RSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its responsibility
 * to ensure the result is compliant.
 */



/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */


/* Application has decided PRNG is good enough to generate a key: don't
 * check.
 */


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_RSA_strings(void);

/* Error codes for the RSA functions. */

/* Function codes. */
# 517 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h"

/* Reason codes. */
# 579 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/rsa.h"

# 97 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h" 1
/* crypto/dsa/dsa.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/*
 * The DSS routines are based on patches supplied by
 * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the
 * work and I have just tweaked them a little to fit into my
 * stylistic vision for SSLeay :-) */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 69 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h" 2











# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h" 1
/* crypto/dh/dh.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 63 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h" 2





# 75 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h"
        




# 88 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h"

/* If this flag is set the DH method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its reposibility
 * to ensure the result is compliant.
 */



/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */







/* Already defined in ossl_typ.h */
/* typedef struct dh_st DH; */
/* typedef struct dh_method DH_METHOD; */

struct dh_method
        {
        const char *name;
        /* Methods here */
        int (*generate_key)(DH *dh);
        int (*compute_key)(unsigned char *key,const BIGNUM *pub_key,DH *dh);
        int (*bn_mod_exp)(const DH *dh, BIGNUM *r, const BIGNUM *a,
                                const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
                                BN_MONT_CTX *m_ctx); /* Can be null */

        int (*init)(DH *dh);
        int (*finish)(DH *dh);
        int flags;
        char *app_data;
        /* If this is non-NULL, it will be used to generate parameters */
        int (*generate_params)(DH *dh, int prime_len, int generator, BN_GENCB *cb);
        };

struct dh_st
        {
        /* This first argument is used to pick up errors when
         * a DH is passed instead of a EVP_PKEY */
        int pad;
        int version;
        BIGNUM *p;
        BIGNUM *g;
        long length; /* optional */
        BIGNUM *pub_key;        /* g^x */
        BIGNUM *priv_key;       /* x */

        int flags;
        BN_MONT_CTX *method_mont_p;
        /* Place holders if we want to do X9.42 DH */
        BIGNUM *q;
        BIGNUM *j;
        unsigned char *seed;
        int seedlen;
        BIGNUM *counter;

        int references;
        CRYPTO_EX_DATA ex_data;
        const DH_METHOD *meth;
        ENGINE *engine;
        };


/* #define DH_GENERATOR_3       3 */


/* DH_check error codes */





/* DH_check_pub_key error codes */



/* primes p where (p-1)/2 is prime too are called "safe"; we define
   this for backward compatibility: */


# 181 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h"

DH *DHparams_dup(DH *);

const DH_METHOD *DH_OpenSSL(void);

void DH_set_default_method(const DH_METHOD *meth);
const DH_METHOD *DH_get_default_method(void);
int DH_set_method(DH *dh, const DH_METHOD *meth);
DH *DH_new_method(ENGINE *engine);

DH *    DH_new(void);
void    DH_free(DH *dh);
int     DH_up_ref(DH *dh);
int     DH_size(const DH *dh);
int DH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
             CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int DH_set_ex_data(DH *d, int idx, void *arg);
void *DH_get_ex_data(DH *d, int idx);

/* Deprecated version */

DH *    DH_generate_parameters(int prime_len,int generator,
                void (*callback)(int,int,void *),void *cb_arg);


/* New version */
int     DH_generate_parameters_ex(DH *dh, int prime_len,int generator, BN_GENCB *cb);

int     DH_check(const DH *dh,int *codes);
int     DH_check_pub_key(const DH *dh,const BIGNUM *pub_key, int *codes);
int     DH_generate_key(DH *dh);
int     DH_compute_key(unsigned char *key,const BIGNUM *pub_key,DH *dh);
DH *    d2i_DHparams(DH **a,const unsigned char **pp, long length);
int     i2d_DHparams(const DH *a,unsigned char **pp);

int     DHparams_print_fp(FILE *fp, const DH *x);


int     DHparams_print(BIO *bp, const DH *x);














                

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_DH_strings(void);

/* Error codes for the DH functions. */

/* Function codes. */
# 262 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h"

/* Reason codes. */
# 276 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dh.h"

# 84 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h" 2







# 99 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h"

/* If this flag is set the DSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its reposibility
 * to ensure the result is compliant.
 */



/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */







/* Already defined in ossl_typ.h */
/* typedef struct dsa_st DSA; */
/* typedef struct dsa_method DSA_METHOD; */

typedef struct DSA_SIG_st
        {
        BIGNUM *r;
        BIGNUM *s;
        } DSA_SIG;

struct dsa_method
        {
        const char *name;
        DSA_SIG * (*dsa_do_sign)(const unsigned char *dgst, int dlen, DSA *dsa);
        int (*dsa_sign_setup)(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,
                                                                BIGNUM **rp);
        int (*dsa_do_verify)(const unsigned char *dgst, int dgst_len,
                             DSA_SIG *sig, DSA *dsa);
        int (*dsa_mod_exp)(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
                        BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,
                        BN_MONT_CTX *in_mont);
        int (*bn_mod_exp)(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
                                const BIGNUM *m, BN_CTX *ctx,
                                BN_MONT_CTX *m_ctx); /* Can be null */
        int (*init)(DSA *dsa);
        int (*finish)(DSA *dsa);
        int flags;
        char *app_data;
        /* If this is non-NULL, it is used to generate DSA parameters */
        int (*dsa_paramgen)(DSA *dsa, int bits,
                        const unsigned char *seed, int seed_len,
                        int *counter_ret, unsigned long *h_ret,
                        BN_GENCB *cb);
        /* If this is non-NULL, it is used to generate DSA keys */
        int (*dsa_keygen)(DSA *dsa);
        };

struct dsa_st
        {
        /* This first variable is used to pick up errors where
         * a DSA is passed instead of of a EVP_PKEY */
        int pad;
        long version;
        int write_params;
        BIGNUM *p;
        BIGNUM *q;      /* == 20 */
        BIGNUM *g;

        BIGNUM *pub_key;  /* y public key */
        BIGNUM *priv_key; /* x private key */

        BIGNUM *kinv;   /* Signing pre-calc */
        BIGNUM *r;      /* Signing pre-calc */

        int flags;
        /* Normally used to cache montgomery values */
        BN_MONT_CTX *method_mont_p;
        int references;
        CRYPTO_EX_DATA ex_data;
        const DSA_METHOD *meth;
        /* functional reference if 'meth' is ENGINE-provided */
        ENGINE *engine;
        };

# 189 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h"


DSA *DSAparams_dup(DSA *x);
DSA_SIG * DSA_SIG_new(void);
void    DSA_SIG_free(DSA_SIG *a);
int     i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);
DSA_SIG * d2i_DSA_SIG(DSA_SIG **v, const unsigned char **pp, long length);

DSA_SIG * DSA_do_sign(const unsigned char *dgst,int dlen,DSA *dsa);
int     DSA_do_verify(const unsigned char *dgst,int dgst_len,
                      DSA_SIG *sig,DSA *dsa);

const DSA_METHOD *DSA_OpenSSL(void);

void    DSA_set_default_method(const DSA_METHOD *);
const DSA_METHOD *DSA_get_default_method(void);
int     DSA_set_method(DSA *dsa, const DSA_METHOD *);

DSA *   DSA_new(void);
DSA *   DSA_new_method(ENGINE *engine);
void    DSA_free (DSA *r);
/* "up" the DSA object's reference count */
int     DSA_up_ref(DSA *r);
int     DSA_size(const DSA *);
        /* next 4 return -1 on error */
int     DSA_sign_setup( DSA *dsa,BN_CTX *ctx_in,BIGNUM **kinvp,BIGNUM **rp);
int     DSA_sign(int type,const unsigned char *dgst,int dlen,
                unsigned char *sig, unsigned int *siglen, DSA *dsa);
int     DSA_verify(int type,const unsigned char *dgst,int dgst_len,
                const unsigned char *sigbuf, int siglen, DSA *dsa);
int DSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
             CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int DSA_set_ex_data(DSA *d, int idx, void *arg);
void *DSA_get_ex_data(DSA *d, int idx);

DSA *   d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);
DSA *   d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);
DSA *   d2i_DSAparams(DSA **a, const unsigned char **pp, long length);

/* Deprecated version */

DSA *   DSA_generate_parameters(int bits,
                unsigned char *seed,int seed_len,
                int *counter_ret, unsigned long *h_ret,void
                (*callback)(int, int, void *),void *cb_arg);


/* New version */
int     DSA_generate_parameters_ex(DSA *dsa, int bits,
                const unsigned char *seed,int seed_len,
                int *counter_ret, unsigned long *h_ret, BN_GENCB *cb);

int     DSA_generate_key(DSA *a);
int     i2d_DSAPublicKey(const DSA *a, unsigned char **pp);
int     i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);
int     i2d_DSAparams(const DSA *a,unsigned char **pp);


int     DSAparams_print(BIO *bp, const DSA *x);
int     DSA_print(BIO *bp, const DSA *x, int off);


int     DSAparams_print_fp(FILE *fp, const DSA *x);
int     DSA_print_fp(FILE *bp, const DSA *x, int off);



/* Primality test according to FIPS PUB 186[-1], Appendix 2.1:
 * 50 rounds of Rabin-Miller */




/* Convert DSA structure (key or just parameters) into DH structure
 * (be careful to avoid small subgroup attacks when using this!) */
DH *DSA_dup_DH(const DSA *r);










/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_DSA_strings(void);

/* Error codes for the DSA functions. */

/* Function codes. */
# 309 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h"

/* Reason codes. */
# 323 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dsa.h"

# 100 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2






# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/sha.h" 1
/* crypto/sha/sha.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 64 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/sha.h" 2














/*
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * ! SHA_LONG has to be at least 32 bits wide. If it's wider, then !
 * ! SHA_LONG_LOG2 has to be defined along.                        !
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */

# 93 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/sha.h"

# 100 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/sha.h"

typedef struct SHAstate_st
        {
        unsigned int h0,h1,h2,h3,h4;
        unsigned int Nl,Nh;
        unsigned int data[16];
        unsigned int num;
        } SHA_CTX;





int SHA_Init(SHA_CTX *c);
int SHA_Update(SHA_CTX *c, const void *data, size_t len);
int SHA_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md);
void SHA_Transform(SHA_CTX *c, const unsigned char *data);





int SHA1_Init(SHA_CTX *c);
int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
int SHA1_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
void SHA1_Transform(SHA_CTX *c, const unsigned char *data);








typedef struct SHA256state_st
        {
        unsigned int h[8];
        unsigned int Nl,Nh;
        unsigned int data[16];
        unsigned int num,md_len;
        } SHA256_CTX;






int SHA224_Init(SHA256_CTX *c);
int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA224_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA224(const unsigned char *d, size_t n,unsigned char *md);
int SHA256_Init(SHA256_CTX *c);
int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA256_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA256(const unsigned char *d, size_t n,unsigned char *md);
void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);






/*
 * Unlike 32-bit digest algorithms, SHA-512 *relies* on SHA_LONG64
 * being exactly 64-bit wide. See Implementation Notes in sha512.c
 * for further details.
 */
# 182 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/sha.h"

typedef struct SHA512state_st
        {
        unsigned long long h[8];
        unsigned long long Nl,Nh;
        union {
                unsigned long long      d[16];
                unsigned char   p[(16*8)];
        } u;
        unsigned int num,md_len;
        } SHA512_CTX;







int SHA384_Init(SHA512_CTX *c);
int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA384_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA384(const unsigned char *d, size_t n,unsigned char *md);
int SHA512_Init(SHA512_CTX *c);
int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA512_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA512(const unsigned char *d, size_t n,unsigned char *md);
void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);






# 108 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2







# 121 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"





# 136 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

typedef struct X509_objects_st
        {
        int nid;
        int (*a2i)(void);
        int (*i2a)(void);
        } X509_OBJECTS;

struct X509_algor_st
        {
        ASN1_OBJECT *algorithm;
        ASN1_TYPE *parameter;
        } /* X509_ALGOR */;



typedef struct stack_st_X509_ALGOR X509_ALGORS;

typedef struct X509_val_st
        {
        ASN1_TIME *notBefore;
        ASN1_TIME *notAfter;
        } X509_VAL;

struct X509_pubkey_st
        {
        X509_ALGOR *algor;
        ASN1_BIT_STRING *public_key;
        EVP_PKEY *pkey;
        };

typedef struct X509_sig_st
        {
        X509_ALGOR *algor;
        ASN1_OCTET_STRING *digest;
        } X509_SIG;

typedef struct X509_name_entry_st
        {
        ASN1_OBJECT *object;
        ASN1_STRING *value;
        int set;
        int size;       /* temp variable */
        } X509_NAME_ENTRY;

struct stack_st_X509_NAME_ENTRY { _STACK stack; };


/* we always keep X509_NAMEs in 2 forms. */
struct X509_name_st
        {
        struct stack_st_X509_NAME_ENTRY *entries;
        int modified;   /* true if 'bytes' needs to be built */

        BUF_MEM *bytes;



/*      unsigned long hash; Keep the hash around for lookups */
        unsigned char *canon_enc;
        int canon_enclen;
        } /* X509_NAME */;

struct stack_st_X509_NAME { _STACK stack; };



typedef struct X509_extension_st
        {
        ASN1_OBJECT *object;
        ASN1_BOOLEAN critical;
        ASN1_OCTET_STRING *value;
        } X509_EXTENSION;

typedef struct stack_st_X509_EXTENSION X509_EXTENSIONS;

struct stack_st_X509_EXTENSION { _STACK stack; };


/* a sequence of these are used */
typedef struct x509_attributes_st
        {
        ASN1_OBJECT *object;
        int single; /* 0 for a set, 1 for a single item (which is wrong) */
        union   {
                char            *ptr;
/* 0 */         struct stack_st_ASN1_TYPE *set;
/* 1 */         ASN1_TYPE       *single;
                } value;
        } X509_ATTRIBUTE;

struct stack_st_X509_ATTRIBUTE { _STACK stack; };



typedef struct X509_req_info_st
        {
        ASN1_ENCODING enc;
        ASN1_INTEGER *version;
        X509_NAME *subject;
        X509_PUBKEY *pubkey;
        /*  d=2 hl=2 l=  0 cons: cont: 00 */
        struct stack_st_X509_ATTRIBUTE *attributes; /* [ 0 ] */
        } X509_REQ_INFO;

typedef struct X509_req_st
        {
        X509_REQ_INFO *req_info;
        X509_ALGOR *sig_alg;
        ASN1_BIT_STRING *signature;
        int references;
        } X509_REQ;

typedef struct x509_cinf_st
        {
        ASN1_INTEGER *version;          /* [ 0 ] default of v1 */
        ASN1_INTEGER *serialNumber;
        X509_ALGOR *signature;
        X509_NAME *issuer;
        X509_VAL *validity;
        X509_NAME *subject;
        X509_PUBKEY *key;
        ASN1_BIT_STRING *issuerUID;             /* [ 1 ] optional in v2 */
        ASN1_BIT_STRING *subjectUID;            /* [ 2 ] optional in v2 */
        struct stack_st_X509_EXTENSION *extensions;   /* [ 3 ] optional in v3 */
        ASN1_ENCODING enc;
        } X509_CINF;

/* This stuff is certificate "auxiliary info"
 * it contains details which are useful in certificate
 * stores and databases. When used this is tagged onto
 * the end of the certificate itself
 */

typedef struct x509_cert_aux_st
        {
        struct stack_st_ASN1_OBJECT *trust;           /* trusted uses */
        struct stack_st_ASN1_OBJECT *reject;          /* rejected uses */
        ASN1_UTF8STRING *alias;                 /* "friendly name" */
        ASN1_OCTET_STRING *keyid;               /* key id of private key */
        struct stack_st_X509_ALGOR *other;            /* other unspecified info */
        } X509_CERT_AUX;

struct x509_st
        {
        X509_CINF *cert_info;
        X509_ALGOR *sig_alg;
        ASN1_BIT_STRING *signature;
        int valid;
        int references;
        char *name;
        CRYPTO_EX_DATA ex_data;
        /* These contain copies of various extension values */
        long ex_pathlen;
        long ex_pcpathlen;
        unsigned long ex_flags;
        unsigned long ex_kusage;
        unsigned long ex_xkusage;
        unsigned long ex_nscert;
        ASN1_OCTET_STRING *skid;
        AUTHORITY_KEYID *akid;
        X509_POLICY_CACHE *policy_cache;
        struct stack_st_DIST_POINT *crldp;
        struct stack_st_GENERAL_NAME *altname;
        NAME_CONSTRAINTS *nc;

        struct stack_st_IPAddressFamily *rfc3779_addr;
        struct ASIdentifiers_st *rfc3779_asid;


        unsigned char sha1_hash[20];

        X509_CERT_AUX *aux;
        } /* X509 */;

struct stack_st_X509 { _STACK stack; };


/* This is used for a table of trust checking functions */

typedef struct x509_trust_st {
        int trust;
        int flags;
        int (*check_trust)(struct x509_trust_st *, X509 *, int);
        char *name;
        int arg1;
        void *arg2;
} X509_TRUST;

struct stack_st_X509_TRUST { _STACK stack; };

typedef struct x509_cert_pair_st {
        X509 *forward;
        X509 *reverse;
} X509_CERT_PAIR;

/* standard trust ids */



# 344 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

/* Keep these up to date! */




/* trust_flags values */



/* check_trust return codes */





/* Flags for X509_print_ex() */

# 375 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

/* Flags specific to X509_NAME_print_ex() */    

/* The field separator information */











/* How the field name is shown */










/* This determines if we dump fields we don't recognise:
 * RFC2253 requires this.
 */





/* Complete set of RFC2253 flags */







/* readable oneline form */







/* readable multiline form */

# 433 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

struct x509_revoked_st
        {
        ASN1_INTEGER *serialNumber;
        ASN1_TIME *revocationDate;
        struct stack_st_X509_EXTENSION /* optional */ *extensions;
        /* Set up if indirect CRL */
        struct stack_st_GENERAL_NAME *issuer;
        /* Revocation reason */
        int reason;
        int sequence; /* load sequence */
        };

struct stack_st_X509_REVOKED { _STACK stack; };


typedef struct X509_crl_info_st
        {
        ASN1_INTEGER *version;
        X509_ALGOR *sig_alg;
        X509_NAME *issuer;
        ASN1_TIME *lastUpdate;
        ASN1_TIME *nextUpdate;
        struct stack_st_X509_REVOKED *revoked;
        struct stack_st_X509_EXTENSION /* [0] */ *extensions;
        ASN1_ENCODING enc;
        } X509_CRL_INFO;

struct X509_crl_st
        {
        /* actual signature */
        X509_CRL_INFO *crl;
        X509_ALGOR *sig_alg;
        ASN1_BIT_STRING *signature;
        int references;
        int flags;
        /* Copies of various extensions */
        AUTHORITY_KEYID *akid;
        ISSUING_DIST_POINT *idp;
        /* Convenient breakdown of IDP */
        int idp_flags;
        int idp_reasons;
        /* CRL and base CRL numbers for delta processing */
        ASN1_INTEGER *crl_number;
        ASN1_INTEGER *base_crl_number;

        unsigned char sha1_hash[20];

        struct stack_st_GENERAL_NAMES *issuers;
        const X509_CRL_METHOD *meth;
        void *meth_data;
        } /* X509_CRL */;

struct stack_st_X509_CRL { _STACK stack; };


typedef struct private_key_st
        {
        int version;
        /* The PKCS#8 data types */
        X509_ALGOR *enc_algor;
        ASN1_OCTET_STRING *enc_pkey;    /* encrypted pub key */

        /* When decrypted, the following will not be NULL */
        EVP_PKEY *dec_pkey;

        /* used to encrypt and decrypt */
        int key_length;
        char *key_data;
        int key_free;   /* true if we should auto free key_data */

        /* expanded version of 'enc_algor' */
        EVP_CIPHER_INFO cipher;

        int references;
        } X509_PKEY;


typedef struct X509_info_st
        {
        X509 *x509;
        X509_CRL *crl;
        X509_PKEY *x_pkey;

        EVP_CIPHER_INFO enc_cipher;
        int enc_len;
        char *enc_data;

        int references;
        } X509_INFO;

struct stack_st_X509_INFO { _STACK stack; };


/* The next 2 structures and their 8 routines were sent to me by
 * Pat Richard <patr@x509.com> and are used to manipulate
 * Netscapes spki structures - useful if you are writing a CA web page
 */
typedef struct Netscape_spkac_st
        {
        X509_PUBKEY *pubkey;
        ASN1_IA5STRING *challenge;      /* challenge sent in atlas >= PR2 */
        } NETSCAPE_SPKAC;

typedef struct Netscape_spki_st
        {
        NETSCAPE_SPKAC *spkac;  /* signed public key and challenge */
        X509_ALGOR *sig_algor;
        ASN1_BIT_STRING *signature;
        } NETSCAPE_SPKI;

/* Netscape certificate sequence structure */
typedef struct Netscape_certificate_sequence
        {
        ASN1_OBJECT *type;
        struct stack_st_X509 *certs;
        } NETSCAPE_CERT_SEQUENCE;

/* Unused (and iv length is wrong)
typedef struct CBCParameter_st
        {
        unsigned char iv[8];
        } CBC_PARAM;
*/

/* Password based encryption structure */

typedef struct PBEPARAM_st {
ASN1_OCTET_STRING *salt;
ASN1_INTEGER *iter;
} PBEPARAM;

/* Password based encryption V2 structures */

typedef struct PBE2PARAM_st {
X509_ALGOR *keyfunc;
X509_ALGOR *encryption;
} PBE2PARAM;

typedef struct PBKDF2PARAM_st {
ASN1_TYPE *salt;        /* Usually OCTET STRING but could be anything */
ASN1_INTEGER *iter;
ASN1_INTEGER *keylength;
X509_ALGOR *prf;
} PBKDF2PARAM;


/* PKCS#8 private key info structure */

struct pkcs8_priv_key_info_st
        {
        int broken;     /* Flag for various broken formats */





        ASN1_INTEGER *version;
        X509_ALGOR *pkeyalg;
        ASN1_TYPE *pkey; /* Should be OCTET STRING but some are broken */
        struct stack_st_X509_ATTRIBUTE *attributes;
        };





# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h" 1
/* crypto/x509/x509_vfy.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */










# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h" 1
/* crypto/lhash/lhash.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* Header for dynamic hash table routines
 * Author - Eric Young
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 67 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h" 2












typedef struct lhash_node_st
        {
        void *data;
        struct lhash_node_st *next;

        unsigned long hash;

        } LHASH_NODE;

typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
typedef void (*LHASH_DOALL_FN_TYPE)(void *);
typedef void (*LHASH_DOALL_ARG_FN_TYPE)(void *, void *);

/* Macros for declaring and implementing type-safe wrappers for LHASH callbacks.
 * This way, callbacks can be provided to LHASH structures without function
 * pointer casting and the macro-defined callbacks provide per-variable casting
 * before deferring to the underlying type-specific callbacks. NB: It is
 * possible to place a "static" in front of both the DECLARE and IMPLEMENT
 * macros if the functions are strictly internal. */

/* First: "hash" functions */
# 108 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h"

/* Second: "compare" functions */
# 118 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h"

/* Third: "doall" functions */
# 127 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h"

/* Fourth: "doall_arg" functions */
# 137 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h"

typedef struct lhash_st
        {
        LHASH_NODE **b;
        LHASH_COMP_FN_TYPE comp;
        LHASH_HASH_FN_TYPE hash;
        unsigned int num_nodes;
        unsigned int num_alloc_nodes;
        unsigned int p;
        unsigned int pmax;
        unsigned long up_load; /* load times 256 */
        unsigned long down_load; /* load times 256 */
        unsigned long num_items;

        unsigned long num_expands;
        unsigned long num_expand_reallocs;
        unsigned long num_contracts;
        unsigned long num_contract_reallocs;
        unsigned long num_hash_calls;
        unsigned long num_comp_calls;
        unsigned long num_insert;
        unsigned long num_replace;
        unsigned long num_delete;
        unsigned long num_no_delete;
        unsigned long num_retrieve;
        unsigned long num_retrieve_miss;
        unsigned long num_hash_comps;

        int error;
        } _LHASH;       /* Do not use _LHASH directly, use LHASH_OF
                         * and friends */



/* Indicates a malloc() error in the last call, this is only bad
 * in lh_insert(). */


_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c);
void lh_free(_LHASH *lh);
void *lh_insert(_LHASH *lh, void *data);
void *lh_delete(_LHASH *lh, const void *data);
void *lh_retrieve(_LHASH *lh, const void *data);
void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func);
void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg);
unsigned long lh_strhash(const char *c);
unsigned long lh_num_items(const _LHASH *lh);


void lh_stats(const _LHASH *lh, FILE *out);
void lh_node_stats(const _LHASH *lh, FILE *out);
void lh_node_usage_stats(const _LHASH *lh, FILE *out);



void lh_stats_bio(const _LHASH *lh, BIO *out);
void lh_node_stats_bio(const _LHASH *lh, BIO *out);
void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);


/* Type checking... */








/* Define wrapper functions. */
# 232 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/lhash.h"

struct lhash_st_OPENSSL_STRING { int dummy; };
struct lhash_st_OPENSSL_CSTRING { int dummy; };







# 71 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h" 2









# 90 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h"

typedef struct x509_file_st
        {
        int num_paths;  /* number of paths to files or directories */
        int num_alloced;
        char **paths;   /* the list of paths or directories */
        int *path_type;
        } X509_CERT_FILE_CTX;

/*******************************/
/*
SSL_CTX -> X509_STORE    
                -> X509_LOOKUP
                        ->X509_LOOKUP_METHOD
                -> X509_LOOKUP
                        ->X509_LOOKUP_METHOD
 
SSL     -> X509_STORE_CTX
                ->X509_STORE    

The X509_STORE holds the tables etc for verification stuff.
A X509_STORE_CTX is used while validating a single certificate.
The X509_STORE has X509_LOOKUPs for looking up certs.
The X509_STORE then calls a function to actually verify the
certificate chain.
*/







typedef struct x509_object_st
        {
        /* one of the above types */
        int type;
        union   {
                char *ptr;
                X509 *x509;
                X509_CRL *crl;
                EVP_PKEY *pkey;
                } data;
        } X509_OBJECT;

typedef struct x509_lookup_st X509_LOOKUP;

struct stack_st_X509_LOOKUP { _STACK stack; };
struct stack_st_X509_OBJECT { _STACK stack; };

/* This is a static that defines the function interface */
typedef struct x509_lookup_method_st
        {
        const char *name;
        int (*new_item)(X509_LOOKUP *ctx);
        void (*free)(X509_LOOKUP *ctx);
        int (*init)(X509_LOOKUP *ctx);
        int (*shutdown)(X509_LOOKUP *ctx);
        int (*ctrl)(X509_LOOKUP *ctx,int cmd,const char *argc,long argl,
                        char **ret);
        int (*get_by_subject)(X509_LOOKUP *ctx,int type,X509_NAME *name,
                              X509_OBJECT *ret);
        int (*get_by_issuer_serial)(X509_LOOKUP *ctx,int type,X509_NAME *name,
                                    ASN1_INTEGER *serial,X509_OBJECT *ret);
        int (*get_by_fingerprint)(X509_LOOKUP *ctx,int type,
                                  unsigned char *bytes,int len,
                                  X509_OBJECT *ret);
        int (*get_by_alias)(X509_LOOKUP *ctx,int type,char *str,int len,
                            X509_OBJECT *ret);
        } X509_LOOKUP_METHOD;

/* This structure hold all parameters associated with a verify operation
 * by including an X509_VERIFY_PARAM structure in related structures the
 * parameters used can be customized
 */

typedef struct X509_VERIFY_PARAM_st
        {
        char *name;
        time_t check_time;      /* Time to use */
        unsigned long inh_flags; /* Inheritance flags */
        unsigned long flags;    /* Various verify flags */
        int purpose;            /* purpose to check untrusted certificates */
        int trust;              /* trust setting to check */
        int depth;              /* Verify depth */
        struct stack_st_ASN1_OBJECT *policies;        /* Permissible policies */
        } X509_VERIFY_PARAM;

struct stack_st_X509_VERIFY_PARAM { _STACK stack; };

/* This is used to hold everything.  It is used for all certificate
 * validation.  Once we have a certificate chain, the 'verify'
 * function is then called to actually check the cert chain. */
struct x509_store_st
        {
        /* The following is a cache of trusted certs */
        int cache;      /* if true, stash any hits */
        struct stack_st_X509_OBJECT *objs;    /* Cache of all objects */

        /* These are external lookup methods */
        struct stack_st_X509_LOOKUP *get_cert_methods;

        X509_VERIFY_PARAM *param;

        /* Callbacks for various operations */
        int (*verify)(X509_STORE_CTX *ctx);     /* called to verify a certificate */
        int (*verify_cb)(int ok,X509_STORE_CTX *ctx);   /* error callback */
        int (*get_issuer)(X509 **issuer, X509_STORE_CTX *ctx, X509 *x); /* get issuers cert from ctx */
        int (*check_issued)(X509_STORE_CTX *ctx, X509 *x, X509 *issuer); /* check issued */
        int (*check_revocation)(X509_STORE_CTX *ctx); /* Check revocation status of chain */
        int (*get_crl)(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x); /* retrieve CRL */
        int (*check_crl)(X509_STORE_CTX *ctx, X509_CRL *crl); /* Check CRL validity */
        int (*cert_crl)(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x); /* Check certificate against CRL */
        struct stack_st_X509 * (*lookup_certs)(X509_STORE_CTX *ctx, X509_NAME *nm);
        struct stack_st_X509_CRL * (*lookup_crls)(X509_STORE_CTX *ctx, X509_NAME *nm);
        int (*cleanup)(X509_STORE_CTX *ctx);

        CRYPTO_EX_DATA ex_data;
        int references;
        } /* X509_STORE */;

int X509_STORE_set_depth(X509_STORE *store, int depth);




/* This is the functions plus an instance of the local variables. */
struct x509_lookup_st
        {
        int init;                       /* have we been started */
        int skip;                       /* don't use us. */
        X509_LOOKUP_METHOD *method;     /* the functions */
        char *method_data;              /* method data */

        X509_STORE *store_ctx;  /* who owns us */
        } /* X509_LOOKUP */;

/* This is a used when verifying cert chains.  Since the
 * gathering of the cert chain can take some time (and have to be
 * 'retried', this needs to be kept and passed around. */
struct x509_store_ctx_st      /* X509_STORE_CTX */
        {
        X509_STORE *ctx;
        int current_method;     /* used when looking up certs */

        /* The following are set by the caller */
        X509 *cert;             /* The cert to check */
        struct stack_st_X509 *untrusted;      /* chain of X509s - untrusted - passed in */
        struct stack_st_X509_CRL *crls;       /* set of CRLs passed in */

        X509_VERIFY_PARAM *param;
        void *other_ctx;        /* Other info for use with get_issuer() */

        /* Callbacks for various operations */
        int (*verify)(X509_STORE_CTX *ctx);     /* called to verify a certificate */
        int (*verify_cb)(int ok,X509_STORE_CTX *ctx);           /* error callback */
        int (*get_issuer)(X509 **issuer, X509_STORE_CTX *ctx, X509 *x); /* get issuers cert from ctx */
        int (*check_issued)(X509_STORE_CTX *ctx, X509 *x, X509 *issuer); /* check issued */
        int (*check_revocation)(X509_STORE_CTX *ctx); /* Check revocation status of chain */
        int (*get_crl)(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x); /* retrieve CRL */
        int (*check_crl)(X509_STORE_CTX *ctx, X509_CRL *crl); /* Check CRL validity */
        int (*cert_crl)(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x); /* Check certificate against CRL */
        int (*check_policy)(X509_STORE_CTX *ctx);
        struct stack_st_X509 * (*lookup_certs)(X509_STORE_CTX *ctx, X509_NAME *nm);
        struct stack_st_X509_CRL * (*lookup_crls)(X509_STORE_CTX *ctx, X509_NAME *nm);
        int (*cleanup)(X509_STORE_CTX *ctx);

        /* The following is built up */
        int valid;              /* if 0, rebuild chain */
        int last_untrusted;     /* index of last untrusted cert */
        struct stack_st_X509 *chain;          /* chain of X509s - built up and trusted */
        X509_POLICY_TREE *tree; /* Valid policy tree */

        int explicit_policy;    /* Require explicit policy value */

        /* When something goes wrong, this is why */
        int error_depth;
        int error;
        X509 *current_cert;
        X509 *current_issuer;   /* cert currently being tested as valid issuer */
        X509_CRL *current_crl;  /* current CRL */

        int current_crl_score;  /* score of current CRL */
        unsigned int current_reasons;  /* Reason mask */

        X509_STORE_CTX *parent; /* For CRL path validation: parent context */

        CRYPTO_EX_DATA ex_data;
        } /* X509_STORE_CTX */;

void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth);
















/* illegal error (for uninitialized values, to avoid X509_V_OK): 1 */

# 326 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h"
/* These are 'informational' when looking for issuer cert */





# 340 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h"









# 356 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h"

/* The application is not happy */


/* Certificate verify flags */

/* Send issuer+subject checks to verify_cb */

/* Use check time instead of current time */

/* Lookup CRLs */

/* Lookup CRLs for whole chain */

/* Ignore unhandled critical extensions */

/* Disable workarounds for broken certificates */

/* Enable proxy certificate validation */

/* Enable policy checking */

/* Policy variable require-explicit-policy */

/* Policy variable inhibit-any-policy */

/* Policy variable inhibit-policy-mapping */

/* Notify callback that policy is OK */

/* Extended CRL features such as indirect CRLs, alternate CRL signing keys */

/* Delta CRL support */

/* Check selfsigned CA signature */









/* Internal use: mask of policy related options */





int X509_OBJECT_idx_by_subject(struct stack_st_X509_OBJECT *h, int type,
             X509_NAME *name);
X509_OBJECT *X509_OBJECT_retrieve_by_subject(struct stack_st_X509_OBJECT *h,int type,X509_NAME *name);
X509_OBJECT *X509_OBJECT_retrieve_match(struct stack_st_X509_OBJECT *h, X509_OBJECT *x);
void X509_OBJECT_up_ref_count(X509_OBJECT *a);
void X509_OBJECT_free_contents(X509_OBJECT *a);
X509_STORE *X509_STORE_new(void );
void X509_STORE_free(X509_STORE *v);

struct stack_st_X509* X509_STORE_get1_certs(X509_STORE_CTX *st, X509_NAME *nm);
struct stack_st_X509_CRL* X509_STORE_get1_crls(X509_STORE_CTX *st, X509_NAME *nm);
int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags);
int X509_STORE_set_purpose(X509_STORE *ctx, int purpose);
int X509_STORE_set_trust(X509_STORE *ctx, int trust);
int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm);

void X509_STORE_set_verify_cb(X509_STORE *ctx,
                                  int (*verify_cb)(int, X509_STORE_CTX *));

X509_STORE_CTX *X509_STORE_CTX_new(void);

int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);

void X509_STORE_CTX_free(X509_STORE_CTX *ctx);
int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
                         X509 *x509, struct stack_st_X509 *chain);
void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, struct stack_st_X509 *sk);
void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);

X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m);

X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void);
X509_LOOKUP_METHOD *X509_LOOKUP_file(void);

int X509_STORE_add_cert(X509_STORE *ctx, X509 *x);
int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x);

int X509_STORE_get_by_subject(X509_STORE_CTX *vs,int type,X509_NAME *name,
        X509_OBJECT *ret);

int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc,
        long argl, char **ret);


int X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type);
int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type);
int X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type);



X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method);
void X509_LOOKUP_free(X509_LOOKUP *ctx);
int X509_LOOKUP_init(X509_LOOKUP *ctx);
int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
        X509_OBJECT *ret);
int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,
        ASN1_INTEGER *serial, X509_OBJECT *ret);
int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,
        unsigned char *bytes, int len, X509_OBJECT *ret);
int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str,
        int len, X509_OBJECT *ret);
int X509_LOOKUP_shutdown(X509_LOOKUP *ctx);


int     X509_STORE_load_locations (X509_STORE *ctx,
                const char *file, const char *dir);
int     X509_STORE_set_default_paths(X509_STORE *ctx);


int X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int     X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx,int idx,void *data);
void *  X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx,int idx);
int     X509_STORE_CTX_get_error(X509_STORE_CTX *ctx);
void    X509_STORE_CTX_set_error(X509_STORE_CTX *ctx,int s);
int     X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx);
X509 *  X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx);
X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx);
X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx);
X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx);
struct stack_st_X509 *X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx);
struct stack_st_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx);
void    X509_STORE_CTX_set_cert(X509_STORE_CTX *c,X509 *x);
void    X509_STORE_CTX_set_chain(X509_STORE_CTX *c,struct stack_st_X509 *sk);
void    X509_STORE_CTX_set0_crls(X509_STORE_CTX *c,struct stack_st_X509_CRL *sk);
int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose);
int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust);
int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
                                int purpose, int trust);
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags);
void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags,
                                                                time_t t);
void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
                                  int (*verify_cb)(int, X509_STORE_CTX *));
  
X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx);
int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx);

X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);
void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);
int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);

/* X509_VERIFY_PARAM functions */

X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);
void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param);
int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to,
                                                const X509_VERIFY_PARAM *from);
int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to, 
                                                const X509_VERIFY_PARAM *from);
int X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name);
int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags);
int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,
                                                        unsigned long flags);
unsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param);
int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose);
int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust);
void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth);
void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t);
int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,
                                                ASN1_OBJECT *policy);
int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param, 
                                        struct stack_st_ASN1_OBJECT *policies);
int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param);

int X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param);
const X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name);
void X509_VERIFY_PARAM_table_cleanup(void);

int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy,
                        struct stack_st_X509 *certs,
                        struct stack_st_ASN1_OBJECT *policy_oids,
                        unsigned int flags);

void X509_policy_tree_free(X509_POLICY_TREE *tree);

int X509_policy_tree_level_count(const X509_POLICY_TREE *tree);
X509_POLICY_LEVEL *
        X509_policy_tree_get0_level(const X509_POLICY_TREE *tree, int i);

struct stack_st_X509_POLICY_NODE *
        X509_policy_tree_get0_policies(const X509_POLICY_TREE *tree);

struct stack_st_X509_POLICY_NODE *
        X509_policy_tree_get0_user_policies(const X509_POLICY_TREE *tree);

int X509_policy_level_node_count(X509_POLICY_LEVEL *level);

X509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level, int i);

const ASN1_OBJECT *X509_policy_node_get0_policy(const X509_POLICY_NODE *node);

struct stack_st_POLICYQUALINFO *
        X509_policy_node_get0_qualifiers(const X509_POLICY_NODE *node);
const X509_POLICY_NODE *
        X509_policy_node_get0_parent(const X509_POLICY_NODE *node);






# 601 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h" 1
/* crypto/pkcs7/pkcs7.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 65 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h" 2














/*
Encryption_ID           DES-CBC
Digest_ID               MD5
Digest_Encryption_ID    rsaEncryption
Key_Encryption_ID       rsaEncryption
*/

typedef struct pkcs7_issuer_and_serial_st
        {
        X509_NAME *issuer;
        ASN1_INTEGER *serial;
        } PKCS7_ISSUER_AND_SERIAL;

typedef struct pkcs7_signer_info_st
        {
        ASN1_INTEGER                    *version;       /* version 1 */
        PKCS7_ISSUER_AND_SERIAL         *issuer_and_serial;
        X509_ALGOR                      *digest_alg;
        struct stack_st_X509_ATTRIBUTE        *auth_attr;     /* [ 0 ] */
        X509_ALGOR                      *digest_enc_alg;
        ASN1_OCTET_STRING               *enc_digest;
        struct stack_st_X509_ATTRIBUTE        *unauth_attr;   /* [ 1 ] */

        /* The private key to sign with */
        EVP_PKEY                        *pkey;
        } PKCS7_SIGNER_INFO;

struct stack_st_PKCS7_SIGNER_INFO { _STACK stack; };


typedef struct pkcs7_recip_info_st
        {
        ASN1_INTEGER                    *version;       /* version 0 */
        PKCS7_ISSUER_AND_SERIAL         *issuer_and_serial;
        X509_ALGOR                      *key_enc_algor;
        ASN1_OCTET_STRING               *enc_key;
        X509                            *cert; /* get the pub-key from this */
        } PKCS7_RECIP_INFO;

struct stack_st_PKCS7_RECIP_INFO { _STACK stack; };


typedef struct pkcs7_signed_st
        {
        ASN1_INTEGER                    *version;       /* version 1 */
        struct stack_st_X509_ALGOR            *md_algs;       /* md used */
        struct stack_st_X509                  *cert;          /* [ 0 ] */
        struct stack_st_X509_CRL              *crl;           /* [ 1 ] */
        struct stack_st_PKCS7_SIGNER_INFO     *signer_info;

        struct pkcs7_st                 *contents;
        } PKCS7_SIGNED;
/* The above structure is very very similar to PKCS7_SIGN_ENVELOPE.
 * How about merging the two */

typedef struct pkcs7_enc_content_st
        {
        ASN1_OBJECT                     *content_type;
        X509_ALGOR                      *algorithm;
        ASN1_OCTET_STRING               *enc_data;      /* [ 0 ] */
        const EVP_CIPHER                *cipher;
        } PKCS7_ENC_CONTENT;

typedef struct pkcs7_enveloped_st
        {
        ASN1_INTEGER                    *version;       /* version 0 */
        struct stack_st_PKCS7_RECIP_INFO      *recipientinfo;
        PKCS7_ENC_CONTENT               *enc_data;
        } PKCS7_ENVELOPE;

typedef struct pkcs7_signedandenveloped_st
        {
        ASN1_INTEGER                    *version;       /* version 1 */
        struct stack_st_X509_ALGOR            *md_algs;       /* md used */
        struct stack_st_X509                  *cert;          /* [ 0 ] */
        struct stack_st_X509_CRL              *crl;           /* [ 1 ] */
        struct stack_st_PKCS7_SIGNER_INFO     *signer_info;

        PKCS7_ENC_CONTENT               *enc_data;
        struct stack_st_PKCS7_RECIP_INFO      *recipientinfo;
        } PKCS7_SIGN_ENVELOPE;

typedef struct pkcs7_digest_st
        {
        ASN1_INTEGER                    *version;       /* version 0 */
        X509_ALGOR                      *md;            /* md used */
        struct pkcs7_st                 *contents;
        ASN1_OCTET_STRING               *digest;
        } PKCS7_DIGEST;

typedef struct pkcs7_encrypted_st
        {
        ASN1_INTEGER                    *version;       /* version 0 */
        PKCS7_ENC_CONTENT               *enc_data;
        } PKCS7_ENCRYPT;

typedef struct pkcs7_st
        {
        /* The following is non NULL if it contains ASN1 encoding of
         * this structure */
        unsigned char *asn1;
        long length;




        int state; /* used during processing */

        int detached;

        ASN1_OBJECT *type;
        /* content as defined by the type */
        /* all encryption/message digests are applied to the 'contents',
         * leaving out the 'type' field. */
        union   {
                char *ptr;

                /* NID_pkcs7_data */
                ASN1_OCTET_STRING *data;

                /* NID_pkcs7_signed */
                PKCS7_SIGNED *sign;

                /* NID_pkcs7_enveloped */
                PKCS7_ENVELOPE *enveloped;

                /* NID_pkcs7_signedAndEnveloped */
                PKCS7_SIGN_ENVELOPE *signed_and_enveloped;

                /* NID_pkcs7_digest */
                PKCS7_DIGEST *digest;

                /* NID_pkcs7_encrypted */
                PKCS7_ENCRYPT *encrypted;

                /* Anything else */
                ASN1_TYPE *other;
                } d;
        } PKCS7;

struct stack_st_PKCS7 { _STACK stack; };









# 236 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h"








/* S/MIME related flags */

# 262 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h"

/* Flags: for compatibility with older code */

# 274 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h"

PKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void); void PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a); PKCS7_ISSUER_AND_SERIAL *d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL * *a, const unsigned char * *in, long len); int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_ISSUER_AND_SERIAL_it;

int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data,const EVP_MD *type,
        unsigned char *md,unsigned int *len);

PKCS7 *d2i_PKCS7_fp(FILE *fp,PKCS7 **p7);
int i2d_PKCS7_fp(FILE *fp,PKCS7 *p7);

PKCS7 *PKCS7_dup(PKCS7 *p7);
PKCS7 *d2i_PKCS7_bio(BIO *bp,PKCS7 **p7);
int i2d_PKCS7_bio(BIO *bp,PKCS7 *p7);
int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);
int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);

PKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void); void PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a); PKCS7_SIGNER_INFO *d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO * *a, const unsigned char * *in, long len); int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_SIGNER_INFO_it;
PKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void); void PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a); PKCS7_RECIP_INFO *d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO * *a, const unsigned char * *in, long len); int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_RECIP_INFO_it;
PKCS7_SIGNED *PKCS7_SIGNED_new(void); void PKCS7_SIGNED_free(PKCS7_SIGNED *a); PKCS7_SIGNED *d2i_PKCS7_SIGNED(PKCS7_SIGNED * *a, const unsigned char * *in, long len); int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_SIGNED_it;
PKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void); void PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a); PKCS7_ENC_CONTENT *d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT * *a, const unsigned char * *in, long len); int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_ENC_CONTENT_it;
PKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void); void PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a); PKCS7_ENVELOPE *d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE * *a, const unsigned char * *in, long len); int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_ENVELOPE_it;
PKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void); void PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a); PKCS7_SIGN_ENVELOPE *d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE * *a, const unsigned char * *in, long len); int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_SIGN_ENVELOPE_it;
PKCS7_DIGEST *PKCS7_DIGEST_new(void); void PKCS7_DIGEST_free(PKCS7_DIGEST *a); PKCS7_DIGEST *d2i_PKCS7_DIGEST(PKCS7_DIGEST * *a, const unsigned char * *in, long len); int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_DIGEST_it;
PKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void); void PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a); PKCS7_ENCRYPT *d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT * *a, const unsigned char * *in, long len); int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_ENCRYPT_it;
PKCS7 *PKCS7_new(void); void PKCS7_free(PKCS7 *a); PKCS7 *d2i_PKCS7(PKCS7 * *a, const unsigned char * *in, long len); int i2d_PKCS7(PKCS7 *a, unsigned char * *out); extern const ASN1_ITEM PKCS7_it;

extern const ASN1_ITEM PKCS7_ATTR_SIGN_it;
extern const ASN1_ITEM PKCS7_ATTR_VERIFY_it;

int i2d_PKCS7_NDEF(PKCS7 *a, unsigned char * *out);
int PKCS7_print_ctx(BIO *out, PKCS7 *x, int indent, const ASN1_PCTX *pctx);

long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg);

int PKCS7_set_type(PKCS7 *p7, int type);
int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other);
int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data);
int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
        const EVP_MD *dgst);
int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si);
int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i);
int PKCS7_add_certificate(PKCS7 *p7, X509 *x509);
int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509);
int PKCS7_content_new(PKCS7 *p7, int nid);
int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,
        BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si); 
int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
                                                                X509 *x509);

BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio);
int PKCS7_dataFinal(PKCS7 *p7, BIO *bio);
BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert);


PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509,
        EVP_PKEY *pkey, const EVP_MD *dgst);
X509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si);
int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md);
struct stack_st_PKCS7_SIGNER_INFO *PKCS7_get_signer_info(PKCS7 *p7);

PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509);
void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,
                                        X509_ALGOR **pdig, X509_ALGOR **psig);
void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc);
int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri);
int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509);
int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher);
int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7);

PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx);
ASN1_OCTET_STRING *PKCS7_digest_from_attributes(struct stack_st_X509_ATTRIBUTE *sk);
int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si,int nid,int type,
        void *data);
int PKCS7_add_attribute (PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
        void *value);
ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid);
ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid);
int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,
                                struct stack_st_X509_ATTRIBUTE *sk);
int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si,struct stack_st_X509_ATTRIBUTE *sk);


PKCS7 *PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, struct stack_st_X509 *certs,
                                                        BIO *data, int flags);

PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7,
                        X509 *signcert, EVP_PKEY *pkey, const EVP_MD *md,
                        int flags);

int PKCS7_final(PKCS7 *p7, BIO *data, int flags);
int PKCS7_verify(PKCS7 *p7, struct stack_st_X509 *certs, X509_STORE *store,
                                        BIO *indata, BIO *out, int flags);
struct stack_st_X509 *PKCS7_get0_signers(PKCS7 *p7, struct stack_st_X509 *certs, int flags);
PKCS7 *PKCS7_encrypt(struct stack_st_X509 *certs, BIO *in, const EVP_CIPHER *cipher,
                                                                int flags);
int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags);

int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si,
                              struct stack_st_X509_ALGOR *cap);
struct stack_st_X509_ALGOR *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si);
int PKCS7_simple_smimecap(struct stack_st_X509_ALGOR *sk, int nid, int arg);

int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid);
int PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t);
int PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si,
                                const unsigned char *md, int mdlen);

int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags);
PKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont);

BIO *BIO_new_PKCS7(BIO *out, PKCS7 *p7);


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_PKCS7_strings(void);

/* Error codes for the PKCS7 functions. */

/* Function codes. */
# 435 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h"

/* Reason codes. */
# 492 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pkcs7.h"

# 602 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h" 2









/* #define      X509_get_serialNumber(x) ((x)->cert_info->serialNumber) */
# 620 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"







void X509_CRL_set_default_method(const X509_CRL_METHOD *meth);
X509_CRL_METHOD *X509_CRL_METHOD_new(
        int (*crl_init)(X509_CRL *crl),
        int (*crl_free)(X509_CRL *crl),
        int (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,
                                ASN1_INTEGER *ser, X509_NAME *issuer),
        int (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk));
void X509_CRL_METHOD_free(X509_CRL_METHOD *m);

void X509_CRL_set_meth_data(X509_CRL *crl, void *dat);
void *X509_CRL_get_meth_data(X509_CRL *crl);

/* This one is only used so that a binary form can output, as in
 * i2d_X509_NAME(X509_get_X509_PUBKEY(x),&buf) */



const char *X509_verify_cert_error_string(long n);


int X509_verify(X509 *a, EVP_PKEY *r);

int X509_REQ_verify(X509_REQ *a, EVP_PKEY *r);
int X509_CRL_verify(X509_CRL *a, EVP_PKEY *r);
int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r);

NETSCAPE_SPKI * NETSCAPE_SPKI_b64_decode(const char *str, int len);
char * NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *x);
EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x);
int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey);

int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki);

int X509_signature_dump(BIO *bp,const ASN1_STRING *sig, int indent);
int X509_signature_print(BIO *bp,X509_ALGOR *alg, ASN1_STRING *sig);

int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
int X509_sign_ctx(X509 *x, EVP_MD_CTX *ctx);
int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md);
int X509_REQ_sign_ctx(X509_REQ *x, EVP_MD_CTX *ctx);
int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md);
int X509_CRL_sign_ctx(X509_CRL *x, EVP_MD_CTX *ctx);
int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md);

int X509_pubkey_digest(const X509 *data,const EVP_MD *type,
                unsigned char *md, unsigned int *len);
int X509_digest(const X509 *data,const EVP_MD *type,
                unsigned char *md, unsigned int *len);
int X509_CRL_digest(const X509_CRL *data,const EVP_MD *type,
                unsigned char *md, unsigned int *len);
int X509_REQ_digest(const X509_REQ *data,const EVP_MD *type,
                unsigned char *md, unsigned int *len);
int X509_NAME_digest(const X509_NAME *data,const EVP_MD *type,
                unsigned char *md, unsigned int *len);



X509 *d2i_X509_fp(FILE *fp, X509 **x509);
int i2d_X509_fp(FILE *fp,X509 *x509);
X509_CRL *d2i_X509_CRL_fp(FILE *fp,X509_CRL **crl);
int i2d_X509_CRL_fp(FILE *fp,X509_CRL *crl);
X509_REQ *d2i_X509_REQ_fp(FILE *fp,X509_REQ **req);
int i2d_X509_REQ_fp(FILE *fp,X509_REQ *req);

RSA *d2i_RSAPrivateKey_fp(FILE *fp,RSA **rsa);
int i2d_RSAPrivateKey_fp(FILE *fp,RSA *rsa);
RSA *d2i_RSAPublicKey_fp(FILE *fp,RSA **rsa);
int i2d_RSAPublicKey_fp(FILE *fp,RSA *rsa);
RSA *d2i_RSA_PUBKEY_fp(FILE *fp,RSA **rsa);
int i2d_RSA_PUBKEY_fp(FILE *fp,RSA *rsa);


DSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa);
int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);
DSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);
int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);


EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);
int   i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);
EC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey);
int   i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey);

X509_SIG *d2i_PKCS8_fp(FILE *fp,X509_SIG **p8);
int i2d_PKCS8_fp(FILE *fp,X509_SIG *p8);
PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,
                                                PKCS8_PRIV_KEY_INFO **p8inf);
int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,PKCS8_PRIV_KEY_INFO *p8inf);
int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key);
int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey);
EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);
int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey);
EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);



X509 *d2i_X509_bio(BIO *bp,X509 **x509);
int i2d_X509_bio(BIO *bp,X509 *x509);
X509_CRL *d2i_X509_CRL_bio(BIO *bp,X509_CRL **crl);
int i2d_X509_CRL_bio(BIO *bp,X509_CRL *crl);
X509_REQ *d2i_X509_REQ_bio(BIO *bp,X509_REQ **req);
int i2d_X509_REQ_bio(BIO *bp,X509_REQ *req);

RSA *d2i_RSAPrivateKey_bio(BIO *bp,RSA **rsa);
int i2d_RSAPrivateKey_bio(BIO *bp,RSA *rsa);
RSA *d2i_RSAPublicKey_bio(BIO *bp,RSA **rsa);
int i2d_RSAPublicKey_bio(BIO *bp,RSA *rsa);
RSA *d2i_RSA_PUBKEY_bio(BIO *bp,RSA **rsa);
int i2d_RSA_PUBKEY_bio(BIO *bp,RSA *rsa);


DSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa);
int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);
DSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);
int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);


EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);
int   i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);
EC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);
int   i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);

X509_SIG *d2i_PKCS8_bio(BIO *bp,X509_SIG **p8);
int i2d_PKCS8_bio(BIO *bp,X509_SIG *p8);
PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
                                                PKCS8_PRIV_KEY_INFO **p8inf);
int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,PKCS8_PRIV_KEY_INFO *p8inf);
int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key);
int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey);
EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);
int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);
EVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);


X509 *X509_dup(X509 *x509);
X509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa);
X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *ex);
X509_CRL *X509_CRL_dup(X509_CRL *crl);
X509_REQ *X509_REQ_dup(X509_REQ *req);
X509_ALGOR *X509_ALGOR_dup(X509_ALGOR *xn);
int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype, void *pval);
void X509_ALGOR_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval,
                                                X509_ALGOR *algor);
void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md);
int X509_ALGOR_cmp(const X509_ALGOR *a, const X509_ALGOR *b);

X509_NAME *X509_NAME_dup(X509_NAME *xn);
X509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne);

int             X509_cmp_time(const ASN1_TIME *s, time_t *t);
int             X509_cmp_current_time(const ASN1_TIME *s);
ASN1_TIME *     X509_time_adj(ASN1_TIME *s, long adj, time_t *t);
ASN1_TIME *     X509_time_adj_ex(ASN1_TIME *s,
                                int offset_day, long offset_sec, time_t *t);
ASN1_TIME *     X509_gmtime_adj(ASN1_TIME *s, long adj);

const char *    X509_get_default_cert_area(void );
const char *    X509_get_default_cert_dir(void );
const char *    X509_get_default_cert_file(void );
const char *    X509_get_default_cert_dir_env(void );
const char *    X509_get_default_cert_file_env(void );
const char *    X509_get_default_private_dir(void );

X509_REQ *      X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
X509 *          X509_REQ_to_X509(X509_REQ *r, int days,EVP_PKEY *pkey);

X509_ALGOR *X509_ALGOR_new(void); void X509_ALGOR_free(X509_ALGOR *a); X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR * *a, const unsigned char * *in, long len); int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char * *out); extern const ASN1_ITEM X509_ALGOR_it;
X509_ALGORS *d2i_X509_ALGORS(X509_ALGORS * *a, const unsigned char * *in, long len); int i2d_X509_ALGORS(X509_ALGORS *a, unsigned char * *out); extern const ASN1_ITEM X509_ALGORS_it;
X509_VAL *X509_VAL_new(void); void X509_VAL_free(X509_VAL *a); X509_VAL *d2i_X509_VAL(X509_VAL * *a, const unsigned char * *in, long len); int i2d_X509_VAL(X509_VAL *a, unsigned char * *out); extern const ASN1_ITEM X509_VAL_it;

X509_PUBKEY *X509_PUBKEY_new(void); void X509_PUBKEY_free(X509_PUBKEY *a); X509_PUBKEY *d2i_X509_PUBKEY(X509_PUBKEY * *a, const unsigned char * *in, long len); int i2d_X509_PUBKEY(X509_PUBKEY *a, unsigned char * *out); extern const ASN1_ITEM X509_PUBKEY_it;

int             X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey);
EVP_PKEY *      X509_PUBKEY_get(X509_PUBKEY *key);
int             X509_get_pubkey_parameters(EVP_PKEY *pkey,
                                           struct stack_st_X509 *chain);
int             i2d_PUBKEY(EVP_PKEY *a,unsigned char **pp);
EVP_PKEY *      d2i_PUBKEY(EVP_PKEY **a,const unsigned char **pp,
                        long length);

int             i2d_RSA_PUBKEY(RSA *a,unsigned char **pp);
RSA *           d2i_RSA_PUBKEY(RSA **a,const unsigned char **pp,
                        long length);


int             i2d_DSA_PUBKEY(DSA *a,unsigned char **pp);
DSA *           d2i_DSA_PUBKEY(DSA **a,const unsigned char **pp,
                        long length);


int             i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp);
EC_KEY          *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp,
                        long length);


X509_SIG *X509_SIG_new(void); void X509_SIG_free(X509_SIG *a); X509_SIG *d2i_X509_SIG(X509_SIG * *a, const unsigned char * *in, long len); int i2d_X509_SIG(X509_SIG *a, unsigned char * *out); extern const ASN1_ITEM X509_SIG_it;
X509_REQ_INFO *X509_REQ_INFO_new(void); void X509_REQ_INFO_free(X509_REQ_INFO *a); X509_REQ_INFO *d2i_X509_REQ_INFO(X509_REQ_INFO * *a, const unsigned char * *in, long len); int i2d_X509_REQ_INFO(X509_REQ_INFO *a, unsigned char * *out); extern const ASN1_ITEM X509_REQ_INFO_it;
X509_REQ *X509_REQ_new(void); void X509_REQ_free(X509_REQ *a); X509_REQ *d2i_X509_REQ(X509_REQ * *a, const unsigned char * *in, long len); int i2d_X509_REQ(X509_REQ *a, unsigned char * *out); extern const ASN1_ITEM X509_REQ_it;

X509_ATTRIBUTE *X509_ATTRIBUTE_new(void); void X509_ATTRIBUTE_free(X509_ATTRIBUTE *a); X509_ATTRIBUTE *d2i_X509_ATTRIBUTE(X509_ATTRIBUTE * *a, const unsigned char * *in, long len); int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a, unsigned char * *out); extern const ASN1_ITEM X509_ATTRIBUTE_it;
X509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int atrtype, void *value);

X509_EXTENSION *X509_EXTENSION_new(void); void X509_EXTENSION_free(X509_EXTENSION *a); X509_EXTENSION *d2i_X509_EXTENSION(X509_EXTENSION * *a, const unsigned char * *in, long len); int i2d_X509_EXTENSION(X509_EXTENSION *a, unsigned char * *out); extern const ASN1_ITEM X509_EXTENSION_it;
X509_EXTENSIONS *d2i_X509_EXTENSIONS(X509_EXTENSIONS * *a, const unsigned char * *in, long len); int i2d_X509_EXTENSIONS(X509_EXTENSIONS *a, unsigned char * *out); extern const ASN1_ITEM X509_EXTENSIONS_it;

X509_NAME_ENTRY *X509_NAME_ENTRY_new(void); void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a); X509_NAME_ENTRY *d2i_X509_NAME_ENTRY(X509_NAME_ENTRY * *a, const unsigned char * *in, long len); int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned char * *out); extern const ASN1_ITEM X509_NAME_ENTRY_it;

X509_NAME *X509_NAME_new(void); void X509_NAME_free(X509_NAME *a); X509_NAME *d2i_X509_NAME(X509_NAME * *a, const unsigned char * *in, long len); int i2d_X509_NAME(X509_NAME *a, unsigned char * *out); extern const ASN1_ITEM X509_NAME_it;

int             X509_NAME_set(X509_NAME **xn, X509_NAME *name);

X509_CINF *X509_CINF_new(void); void X509_CINF_free(X509_CINF *a); X509_CINF *d2i_X509_CINF(X509_CINF * *a, const unsigned char * *in, long len); int i2d_X509_CINF(X509_CINF *a, unsigned char * *out); extern const ASN1_ITEM X509_CINF_it;

X509 *X509_new(void); void X509_free(X509 *a); X509 *d2i_X509(X509 * *a, const unsigned char * *in, long len); int i2d_X509(X509 *a, unsigned char * *out); extern const ASN1_ITEM X509_it;
X509_CERT_AUX *X509_CERT_AUX_new(void); void X509_CERT_AUX_free(X509_CERT_AUX *a); X509_CERT_AUX *d2i_X509_CERT_AUX(X509_CERT_AUX * *a, const unsigned char * *in, long len); int i2d_X509_CERT_AUX(X509_CERT_AUX *a, unsigned char * *out); extern const ASN1_ITEM X509_CERT_AUX_it;

X509_CERT_PAIR *X509_CERT_PAIR_new(void); void X509_CERT_PAIR_free(X509_CERT_PAIR *a); X509_CERT_PAIR *d2i_X509_CERT_PAIR(X509_CERT_PAIR * *a, const unsigned char * *in, long len); int i2d_X509_CERT_PAIR(X509_CERT_PAIR *a, unsigned char * *out); extern const ASN1_ITEM X509_CERT_PAIR_it;

int X509_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
             CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int X509_set_ex_data(X509 *r, int idx, void *arg);
void *X509_get_ex_data(X509 *r, int idx);
int             i2d_X509_AUX(X509 *a,unsigned char **pp);
X509 *          d2i_X509_AUX(X509 **a,const unsigned char **pp,long length);

int X509_alias_set1(X509 *x, unsigned char *name, int len);
int X509_keyid_set1(X509 *x, unsigned char *id, int len);
unsigned char * X509_alias_get0(X509 *x, int *len);
unsigned char * X509_keyid_get0(X509 *x, int *len);
int (*X509_TRUST_set_default(int (*trust)(int , X509 *, int)))(int, X509 *, int);
int X509_TRUST_set(int *t, int trust);
int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj);
int X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj);
void X509_trust_clear(X509 *x);
void X509_reject_clear(X509 *x);

X509_REVOKED *X509_REVOKED_new(void); void X509_REVOKED_free(X509_REVOKED *a); X509_REVOKED *d2i_X509_REVOKED(X509_REVOKED * *a, const unsigned char * *in, long len); int i2d_X509_REVOKED(X509_REVOKED *a, unsigned char * *out); extern const ASN1_ITEM X509_REVOKED_it;
X509_CRL_INFO *X509_CRL_INFO_new(void); void X509_CRL_INFO_free(X509_CRL_INFO *a); X509_CRL_INFO *d2i_X509_CRL_INFO(X509_CRL_INFO * *a, const unsigned char * *in, long len); int i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned char * *out); extern const ASN1_ITEM X509_CRL_INFO_it;
X509_CRL *X509_CRL_new(void); void X509_CRL_free(X509_CRL *a); X509_CRL *d2i_X509_CRL(X509_CRL * *a, const unsigned char * *in, long len); int i2d_X509_CRL(X509_CRL *a, unsigned char * *out); extern const ASN1_ITEM X509_CRL_it;

int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
int X509_CRL_get0_by_serial(X509_CRL *crl,
                X509_REVOKED **ret, ASN1_INTEGER *serial);
int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x);

X509_PKEY *     X509_PKEY_new(void );
void            X509_PKEY_free(X509_PKEY *a);
int             i2d_X509_PKEY(X509_PKEY *a,unsigned char **pp);
X509_PKEY *     d2i_X509_PKEY(X509_PKEY **a,const unsigned char **pp,long length);

NETSCAPE_SPKI *NETSCAPE_SPKI_new(void); void NETSCAPE_SPKI_free(NETSCAPE_SPKI *a); NETSCAPE_SPKI *d2i_NETSCAPE_SPKI(NETSCAPE_SPKI * *a, const unsigned char * *in, long len); int i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a, unsigned char * *out); extern const ASN1_ITEM NETSCAPE_SPKI_it;
NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void); void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a); NETSCAPE_SPKAC *d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC * *a, const unsigned char * *in, long len); int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a, unsigned char * *out); extern const ASN1_ITEM NETSCAPE_SPKAC_it;
NETSCAPE_CERT_SEQUENCE *NETSCAPE_CERT_SEQUENCE_new(void); void NETSCAPE_CERT_SEQUENCE_free(NETSCAPE_CERT_SEQUENCE *a); NETSCAPE_CERT_SEQUENCE *d2i_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE * *a, const unsigned char * *in, long len); int i2d_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE *a, unsigned char * *out); extern const ASN1_ITEM NETSCAPE_CERT_SEQUENCE_it;


X509_INFO *     X509_INFO_new(void);
void            X509_INFO_free(X509_INFO *a);
char *          X509_NAME_oneline(X509_NAME *a,char *buf,int size);

int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *algor1,
                ASN1_BIT_STRING *signature,char *data,EVP_PKEY *pkey);

int ASN1_digest(i2d_of_void *i2d,const EVP_MD *type,char *data,
                unsigned char *md,unsigned int *len);

int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1,
              X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
              char *data,EVP_PKEY *pkey, const EVP_MD *type);

int ASN1_item_digest(const ASN1_ITEM *it,const EVP_MD *type,void *data,
        unsigned char *md,unsigned int *len);

int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1,
        ASN1_BIT_STRING *signature,void *data,EVP_PKEY *pkey);

int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2,
        ASN1_BIT_STRING *signature,
        void *data, EVP_PKEY *pkey, const EVP_MD *type);
int ASN1_item_sign_ctx(const ASN1_ITEM *it,
                X509_ALGOR *algor1, X509_ALGOR *algor2,
                ASN1_BIT_STRING *signature, void *asn, EVP_MD_CTX *ctx);


int             X509_set_version(X509 *x,long version);
int             X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial);
ASN1_INTEGER *  X509_get_serialNumber(X509 *x);
int             X509_set_issuer_name(X509 *x, X509_NAME *name);
X509_NAME *     X509_get_issuer_name(X509 *a);
int             X509_set_subject_name(X509 *x, X509_NAME *name);
X509_NAME *     X509_get_subject_name(X509 *a);
int             X509_set_notBefore(X509 *x, const ASN1_TIME *tm);
int             X509_set_notAfter(X509 *x, const ASN1_TIME *tm);
int             X509_set_pubkey(X509 *x, EVP_PKEY *pkey);
EVP_PKEY *      X509_get_pubkey(X509 *x);
ASN1_BIT_STRING * X509_get0_pubkey_bitstr(const X509 *x);
int             X509_certificate_type(X509 *x,EVP_PKEY *pubkey /* optional */);

int             X509_REQ_set_version(X509_REQ *x,long version);
int             X509_REQ_set_subject_name(X509_REQ *req,X509_NAME *name);
int             X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey);
EVP_PKEY *      X509_REQ_get_pubkey(X509_REQ *req);
int             X509_REQ_extension_nid(int nid);
int *           X509_REQ_get_extension_nids(void);
void            X509_REQ_set_extension_nids(int *nids);
struct stack_st_X509_EXTENSION *X509_REQ_get_extensions(X509_REQ *req);
int X509_REQ_add_extensions_nid(X509_REQ *req, struct stack_st_X509_EXTENSION *exts,
                                int nid);
int X509_REQ_add_extensions(X509_REQ *req, struct stack_st_X509_EXTENSION *exts);
int X509_REQ_get_attr_count(const X509_REQ *req);
int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid,
                          int lastpos);
int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj,
                          int lastpos);
X509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc);
X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc);
int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr);
int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,
                        const ASN1_OBJECT *obj, int type,
                        const unsigned char *bytes, int len);
int X509_REQ_add1_attr_by_NID(X509_REQ *req,
                        int nid, int type,
                        const unsigned char *bytes, int len);
int X509_REQ_add1_attr_by_txt(X509_REQ *req,
                        const char *attrname, int type,
                        const unsigned char *bytes, int len);

int X509_CRL_set_version(X509_CRL *x, long version);
int X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name);
int X509_CRL_set_lastUpdate(X509_CRL *x, const ASN1_TIME *tm);
int X509_CRL_set_nextUpdate(X509_CRL *x, const ASN1_TIME *tm);
int X509_CRL_sort(X509_CRL *crl);

int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial);
int X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm);

int             X509_REQ_check_private_key(X509_REQ *x509,EVP_PKEY *pkey);

int             X509_check_private_key(X509 *x509,EVP_PKEY *pkey);

int             X509_issuer_and_serial_cmp(const X509 *a, const X509 *b);
unsigned long   X509_issuer_and_serial_hash(X509 *a);

int             X509_issuer_name_cmp(const X509 *a, const X509 *b);
unsigned long   X509_issuer_name_hash(X509 *a);

int             X509_subject_name_cmp(const X509 *a, const X509 *b);
unsigned long   X509_subject_name_hash(X509 *x);


unsigned long   X509_issuer_name_hash_old(X509 *a);
unsigned long   X509_subject_name_hash_old(X509 *x);


int             X509_cmp(const X509 *a, const X509 *b);
int             X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b);
unsigned long   X509_NAME_hash(X509_NAME *x);
unsigned long   X509_NAME_hash_old(X509_NAME *x);

int             X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b);
int             X509_CRL_match(const X509_CRL *a, const X509_CRL *b);

int             X509_print_ex_fp(FILE *bp,X509 *x, unsigned long nmflag, unsigned long cflag);
int             X509_print_fp(FILE *bp,X509 *x);
int             X509_CRL_print_fp(FILE *bp,X509_CRL *x);
int             X509_REQ_print_fp(FILE *bp,X509_REQ *req);
int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags);



int             X509_NAME_print(BIO *bp, X509_NAME *name, int obase);
int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags);
int             X509_print_ex(BIO *bp,X509 *x, unsigned long nmflag, unsigned long cflag);
int             X509_print(BIO *bp,X509 *x);
int             X509_ocspid_print(BIO *bp,X509 *x);
int             X509_CERT_AUX_print(BIO *bp,X509_CERT_AUX *x, int indent);
int             X509_CRL_print(BIO *bp,X509_CRL *x);
int             X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflag, unsigned long cflag);
int             X509_REQ_print(BIO *bp,X509_REQ *req);


int             X509_NAME_entry_count(X509_NAME *name);
int             X509_NAME_get_text_by_NID(X509_NAME *name, int nid,
                        char *buf,int len);
int             X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj,
                        char *buf,int len);

/* NOTE: you should be passsing -1, not 0 as lastpos.  The functions that use
 * lastpos, search after that position on. */
int             X509_NAME_get_index_by_NID(X509_NAME *name,int nid,int lastpos);
int             X509_NAME_get_index_by_OBJ(X509_NAME *name,ASN1_OBJECT *obj,
                        int lastpos);
X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc);
X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);
int             X509_NAME_add_entry(X509_NAME *name,X509_NAME_ENTRY *ne,
                        int loc, int set);
int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type,
                        unsigned char *bytes, int len, int loc, int set);
int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,
                        unsigned char *bytes, int len, int loc, int set);
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,
                const char *field, int type, const unsigned char *bytes, int len);
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,
                        int type,unsigned char *bytes, int len);
int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,
                        const unsigned char *bytes, int len, int loc, int set);
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,
                        ASN1_OBJECT *obj, int type,const unsigned char *bytes,
                        int len);
int             X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne,
                        ASN1_OBJECT *obj);
int             X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,
                        const unsigned char *bytes, int len);
ASN1_OBJECT *   X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne);
ASN1_STRING *   X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne);

int             X509v3_get_ext_count(const struct stack_st_X509_EXTENSION *x);
int             X509v3_get_ext_by_NID(const struct stack_st_X509_EXTENSION *x,
                                      int nid, int lastpos);
int             X509v3_get_ext_by_OBJ(const struct stack_st_X509_EXTENSION *x,
                                      ASN1_OBJECT *obj,int lastpos);
int             X509v3_get_ext_by_critical(const struct stack_st_X509_EXTENSION *x,
                                           int crit, int lastpos);
X509_EXTENSION *X509v3_get_ext(const struct stack_st_X509_EXTENSION *x, int loc);
X509_EXTENSION *X509v3_delete_ext(struct stack_st_X509_EXTENSION *x, int loc);
struct stack_st_X509_EXTENSION *X509v3_add_ext(struct stack_st_X509_EXTENSION **x,
                                         X509_EXTENSION *ex, int loc);

int             X509_get_ext_count(X509 *x);
int             X509_get_ext_by_NID(X509 *x, int nid, int lastpos);
int             X509_get_ext_by_OBJ(X509 *x,ASN1_OBJECT *obj,int lastpos);
int             X509_get_ext_by_critical(X509 *x, int crit, int lastpos);
X509_EXTENSION *X509_get_ext(X509 *x, int loc);
X509_EXTENSION *X509_delete_ext(X509 *x, int loc);
int             X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc);
void    *       X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx);
int             X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,
                                                        unsigned long flags);

int             X509_CRL_get_ext_count(X509_CRL *x);
int             X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos);
int             X509_CRL_get_ext_by_OBJ(X509_CRL *x,ASN1_OBJECT *obj,int lastpos);
int             X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos);
X509_EXTENSION *X509_CRL_get_ext(X509_CRL *x, int loc);
X509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc);
int             X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc);
void    *       X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx);
int             X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,
                                                        unsigned long flags);

int             X509_REVOKED_get_ext_count(X509_REVOKED *x);
int             X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos);
int             X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x,ASN1_OBJECT *obj,int lastpos);
int             X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos);
X509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x, int loc);
X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc);
int             X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc);
void    *       X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx);
int             X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,
                                                        unsigned long flags);

X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex,
                        int nid, int crit, ASN1_OCTET_STRING *data);
X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex,
                        ASN1_OBJECT *obj,int crit,ASN1_OCTET_STRING *data);
int             X509_EXTENSION_set_object(X509_EXTENSION *ex,ASN1_OBJECT *obj);
int             X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit);
int             X509_EXTENSION_set_data(X509_EXTENSION *ex,
                        ASN1_OCTET_STRING *data);
ASN1_OBJECT *   X509_EXTENSION_get_object(X509_EXTENSION *ex);
ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ne);
int             X509_EXTENSION_get_critical(X509_EXTENSION *ex);

int X509at_get_attr_count(const struct stack_st_X509_ATTRIBUTE *x);
int X509at_get_attr_by_NID(const struct stack_st_X509_ATTRIBUTE *x, int nid,
                          int lastpos);
int X509at_get_attr_by_OBJ(const struct stack_st_X509_ATTRIBUTE *sk, ASN1_OBJECT *obj,
                          int lastpos);
X509_ATTRIBUTE *X509at_get_attr(const struct stack_st_X509_ATTRIBUTE *x, int loc);
X509_ATTRIBUTE *X509at_delete_attr(struct stack_st_X509_ATTRIBUTE *x, int loc);
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr(struct stack_st_X509_ATTRIBUTE **x,
                                         X509_ATTRIBUTE *attr);
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_OBJ(struct stack_st_X509_ATTRIBUTE **x,
                        const ASN1_OBJECT *obj, int type,
                        const unsigned char *bytes, int len);
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_NID(struct stack_st_X509_ATTRIBUTE **x,
                        int nid, int type,
                        const unsigned char *bytes, int len);
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_txt(struct stack_st_X509_ATTRIBUTE **x,
                        const char *attrname, int type,
                        const unsigned char *bytes, int len);
void *X509at_get0_data_by_OBJ(struct stack_st_X509_ATTRIBUTE *x,
                                ASN1_OBJECT *obj, int lastpos, int type);
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,
             int atrtype, const void *data, int len);
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,
             const ASN1_OBJECT *obj, int atrtype, const void *data, int len);
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr,
                const char *atrname, int type, const unsigned char *bytes, int len);
int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj);
int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype, const void *data, int len);
void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,
                                        int atrtype, void *data);
int X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr);
ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);
ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx);

int EVP_PKEY_get_attr_count(const EVP_PKEY *key);
int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid,
                          int lastpos);
int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,
                          int lastpos);
X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc);
X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc);
int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr);
int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,
                        const ASN1_OBJECT *obj, int type,
                        const unsigned char *bytes, int len);
int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,
                        int nid, int type,
                        const unsigned char *bytes, int len);
int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,
                        const char *attrname, int type,
                        const unsigned char *bytes, int len);

int             X509_verify_cert(X509_STORE_CTX *ctx);

/* lookup a cert from a X509 STACK */
X509 *X509_find_by_issuer_and_serial(struct stack_st_X509 *sk,X509_NAME *name,
                                     ASN1_INTEGER *serial);
X509 *X509_find_by_subject(struct stack_st_X509 *sk,X509_NAME *name);

PBEPARAM *PBEPARAM_new(void); void PBEPARAM_free(PBEPARAM *a); PBEPARAM *d2i_PBEPARAM(PBEPARAM * *a, const unsigned char * *in, long len); int i2d_PBEPARAM(PBEPARAM *a, unsigned char * *out); extern const ASN1_ITEM PBEPARAM_it;
PBE2PARAM *PBE2PARAM_new(void); void PBE2PARAM_free(PBE2PARAM *a); PBE2PARAM *d2i_PBE2PARAM(PBE2PARAM * *a, const unsigned char * *in, long len); int i2d_PBE2PARAM(PBE2PARAM *a, unsigned char * *out); extern const ASN1_ITEM PBE2PARAM_it;
PBKDF2PARAM *PBKDF2PARAM_new(void); void PBKDF2PARAM_free(PBKDF2PARAM *a); PBKDF2PARAM *d2i_PBKDF2PARAM(PBKDF2PARAM * *a, const unsigned char * *in, long len); int i2d_PBKDF2PARAM(PBKDF2PARAM *a, unsigned char * *out); extern const ASN1_ITEM PBKDF2PARAM_it;

int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
                                const unsigned char *salt, int saltlen);

X509_ALGOR *PKCS5_pbe_set(int alg, int iter,
                                const unsigned char *salt, int saltlen);
X509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter,
                                         unsigned char *salt, int saltlen);
X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
                                 unsigned char *salt, int saltlen,
                                 unsigned char *aiv, int prf_nid);

X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
                                int prf_nid, int keylen);

/* PKCS#8 utilities */

PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void); void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a); PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO * *a, const unsigned char * *in, long len); int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a, unsigned char * *out); extern const ASN1_ITEM PKCS8_PRIV_KEY_INFO_it;

EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8);
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey);
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken);
PKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken);

int PKCS8_pkey_set0(PKCS8_PRIV_KEY_INFO *priv, ASN1_OBJECT *aobj,
                        int version, int ptype, void *pval,
                                unsigned char *penc, int penclen);
int PKCS8_pkey_get0(ASN1_OBJECT **ppkalg,
                const unsigned char **pk, int *ppklen,
                X509_ALGOR **pa,
                PKCS8_PRIV_KEY_INFO *p8);

int X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,
                                        int ptype, void *pval,
                                        unsigned char *penc, int penclen);
int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,
                const unsigned char **pk, int *ppklen,
                X509_ALGOR **pa,
                X509_PUBKEY *pub);

int X509_check_trust(X509 *x, int id, int flags);
int X509_TRUST_get_count(void);
X509_TRUST * X509_TRUST_get0(int idx);
int X509_TRUST_get_by_id(int id);
int X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),
                                        char *name, int arg1, void *arg2);
void X509_TRUST_cleanup(void);
int X509_TRUST_get_flags(X509_TRUST *xp);
char *X509_TRUST_get0_name(X509_TRUST *xp);
int X509_TRUST_get_trust(X509_TRUST *xp);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_X509_strings(void);

/* Error codes for the X509 functions. */

/* Function codes. */
# 1266 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

/* Reason codes. */
# 1294 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509.h"

# 157 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h" 1
/* crypto/pem/pem.h */
/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 63 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem2.h" 1
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

/*
 * This header only exists to break a circular dependency between pem and err
 * Ben 30 Jan 1999.
 */









# 72 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h" 2







# 97 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 106 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 113 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 139 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

  /* Note that this structure is initialised by PEM_SealInit and cleaned up
     by PEM_SealFinal (at least for now) */
typedef struct PEM_Encode_Seal_st
        {
        EVP_ENCODE_CTX encode;
        EVP_MD_CTX md;
        EVP_CIPHER_CTX cipher;
        } PEM_ENCODE_SEAL_CTX;

/* enc_type is one off */





typedef struct pem_recip_st
        {
        char *name;
        X509_NAME *dn;

        int cipher;
        int key_enc;
        /*      char iv[8]; unused and wrong size */
        } PEM_USER;

typedef struct pem_ctx_st
        {
        int type;               /* what type of object */

        struct  {
                int version;    
                int mode;               
                } proc_type;

        char *domain;

        struct  {
                int cipher;
        /* unused, and wrong size
           unsigned char iv[8]; */
                } DEK_info;
                
        PEM_USER *originator;

        int num_recipient;
        PEM_USER **recipient;

        /* XXX(ben): don#t think this is used! 
                STACK *x509_chain;      / * certificate chain */
        EVP_MD *md;             /* signature type */

        int md_enc;             /* is the md encrypted or not? */
        int md_len;             /* length of md_data */
        char *md_data;          /* message digest, could be pkey encrypted */

        EVP_CIPHER *dec;        /* date encryption cipher */
        int key_len;            /* key length */
        unsigned char *key;     /* key */
        /* unused, and wrong size
           unsigned char iv[8]; */

        
        int  data_enc;          /* is the data encrypted */
        int data_len;
        unsigned char *data;
        } PEM_CTX;

/* These macros make the PEM_read/PEM_write functions easier to maintain and
 * write. Now they are all implemented with either:
 * IMPLEMENT_PEM_rw(...) or IMPLEMENT_PEM_rw_cb(...)
 */

# 221 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"



















# 247 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 255 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"





















# 282 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 289 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

































/* These are the same except they are for the declarations */

# 331 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"






























# 369 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"






























/* "userdata": new with OpenSSL 0.9.4 */
typedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);





int     PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
int     PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data,long *len,
        pem_password_cb *callback,void *u);


int     PEM_read_bio(BIO *bp, char **name, char **header,
                unsigned char **data,long *len);
int     PEM_write_bio(BIO *bp,const char *name,char *hdr,unsigned char *data,
                long len);
int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
             pem_password_cb *cb, void *u);
void *  PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp,
                          void **x, pem_password_cb *cb, void *u);
int     PEM_ASN1_write_bio(i2d_of_void *i2d,const char *name,BIO *bp, void *x,
                           const EVP_CIPHER *enc,unsigned char *kstr,int klen,
                           pem_password_cb *cb, void *u);

struct stack_st_X509_INFO *   PEM_X509_INFO_read_bio(BIO *bp, struct stack_st_X509_INFO *sk, pem_password_cb *cb, void *u);
int     PEM_X509_INFO_write_bio(BIO *bp,X509_INFO *xi, EVP_CIPHER *enc,
                unsigned char *kstr, int klen, pem_password_cb *cd, void *u);


int     PEM_read(FILE *fp, char **name, char **header,
                unsigned char **data,long *len);
int     PEM_write(FILE *fp,char *name,char *hdr,unsigned char *data,long len);
void *  PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
                      pem_password_cb *cb, void *u);
int     PEM_ASN1_write(i2d_of_void *i2d,const char *name,FILE *fp,
                       void *x,const EVP_CIPHER *enc,unsigned char *kstr,
                       int klen,pem_password_cb *callback, void *u);
struct stack_st_X509_INFO *   PEM_X509_INFO_read(FILE *fp, struct stack_st_X509_INFO *sk,
        pem_password_cb *cb, void *u);

int     PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type,
                EVP_MD *md_type, unsigned char **ek, int *ekl,
                unsigned char *iv, EVP_PKEY **pubk, int npubk);
void    PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
                unsigned char *in, int inl);
int     PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig,int *sigl,
                unsigned char *out, int *outl, EVP_PKEY *priv);

void    PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);
void    PEM_SignUpdate(EVP_MD_CTX *ctx,unsigned char *d,unsigned int cnt);
int     PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
                unsigned int *siglen, EVP_PKEY *pkey);

int     PEM_def_callback(char *buf, int num, int w, void *key);
void    PEM_proc_type(char *buf, int type);
void    PEM_dek_info(char *buf, const char *type, int len, char *str);




X509 *PEM_read_bio_X509(BIO *bp, X509 * *x, pem_password_cb *cb, void *u); X509 *PEM_read_X509(FILE *fp, X509 * *x, pem_password_cb *cb, void *u); int PEM_write_bio_X509(BIO *bp, X509 *x); int PEM_write_X509(FILE *fp, X509 *x);

X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 * *x, pem_password_cb *cb, void *u); X509 *PEM_read_X509_AUX(FILE *fp, X509 * *x, pem_password_cb *cb, void *u); int PEM_write_bio_X509_AUX(BIO *bp, X509 *x); int PEM_write_X509_AUX(FILE *fp, X509 *x);

X509_CERT_PAIR *PEM_read_bio_X509_CERT_PAIR(BIO *bp, X509_CERT_PAIR * *x, pem_password_cb *cb, void *u); X509_CERT_PAIR *PEM_read_X509_CERT_PAIR(FILE *fp, X509_CERT_PAIR * *x, pem_password_cb *cb, void *u); int PEM_write_bio_X509_CERT_PAIR(BIO *bp, X509_CERT_PAIR *x); int PEM_write_X509_CERT_PAIR(FILE *fp, X509_CERT_PAIR *x);

X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ * *x, pem_password_cb *cb, void *u); X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ * *x, pem_password_cb *cb, void *u); int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x); int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);
int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x); int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);

X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL * *x, pem_password_cb *cb, void *u); X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL * *x, pem_password_cb *cb, void *u); int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x); int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);

PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 * *x, pem_password_cb *cb, void *u); PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 * *x, pem_password_cb *cb, void *u); int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x); int PEM_write_PKCS7(FILE *fp, PKCS7 *x);

NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE * *x, pem_password_cb *cb, void *u); NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE * *x, pem_password_cb *cb, void *u); int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x); int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);

X509_SIG *PEM_read_bio_PKCS8(BIO *bp, X509_SIG * *x, pem_password_cb *cb, void *u); X509_SIG *PEM_read_PKCS8(FILE *fp, X509_SIG * *x, pem_password_cb *cb, void *u); int PEM_write_bio_PKCS8(BIO *bp, X509_SIG *x); int PEM_write_PKCS8(FILE *fp, X509_SIG *x);

PKCS8_PRIV_KEY_INFO *PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO * *x, pem_password_cb *cb, void *u); PKCS8_PRIV_KEY_INFO *PEM_read_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO * *x, pem_password_cb *cb, void *u); int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO *x); int PEM_write_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO *x);



RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA * *x, pem_password_cb *cb, void *u); RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u); int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);

RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA * *x, pem_password_cb *cb, void *u); RSA *PEM_read_RSAPublicKey(FILE *fp, RSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_RSAPublicKey(BIO *bp, const RSA *x); int PEM_write_RSAPublicKey(FILE *fp, const RSA *x);
RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA * *x, pem_password_cb *cb, void *u); RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x); int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);





DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA * *x, pem_password_cb *cb, void *u); DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u); int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);

DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA * *x, pem_password_cb *cb, void *u); DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x); int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);

DSA *PEM_read_bio_DSAparams(BIO *bp, DSA * *x, pem_password_cb *cb, void *u); DSA *PEM_read_DSAparams(FILE *fp, DSA * *x, pem_password_cb *cb, void *u); int PEM_write_bio_DSAparams(BIO *bp, const DSA *x); int PEM_write_DSAparams(FILE *fp, const DSA *x);




EC_GROUP *PEM_read_bio_ECPKParameters(BIO *bp, EC_GROUP * *x, pem_password_cb *cb, void *u); EC_GROUP *PEM_read_ECPKParameters(FILE *fp, EC_GROUP * *x, pem_password_cb *cb, void *u); int PEM_write_bio_ECPKParameters(BIO *bp, const EC_GROUP *x); int PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x);
EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY * *x, pem_password_cb *cb, void *u); EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY * *x, pem_password_cb *cb, void *u); int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u); int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
EC_KEY *PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY * *x, pem_password_cb *cb, void *u); EC_KEY *PEM_read_EC_PUBKEY(FILE *fp, EC_KEY * *x, pem_password_cb *cb, void *u); int PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x); int PEM_write_EC_PUBKEY(FILE *fp, EC_KEY *x);




DH *PEM_read_bio_DHparams(BIO *bp, DH * *x, pem_password_cb *cb, void *u); DH *PEM_read_DHparams(FILE *fp, DH * *x, pem_password_cb *cb, void *u); int PEM_write_bio_DHparams(BIO *bp, const DH *x); int PEM_write_DHparams(FILE *fp, const DH *x);



EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY * *x, pem_password_cb *cb, void *u); EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY * *x, pem_password_cb *cb, void *u); int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u); int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);

EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY * *x, pem_password_cb *cb, void *u); EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY * *x, pem_password_cb *cb, void *u); int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x); int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);

int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                                  char *, int, pem_password_cb *, void *);
int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);

int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);

EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);

int PEM_write_PKCS8PrivateKey(FILE *fp,EVP_PKEY *x,const EVP_CIPHER *enc,
                              char *kstr,int klen, pem_password_cb *cd, void *u);

EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);


EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length);
EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length);
EVP_PKEY *b2i_PrivateKey_bio(BIO *in);
EVP_PKEY *b2i_PublicKey_bio(BIO *in);
int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);
int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);

EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);
int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
                pem_password_cb *cb, void *u);



/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_PEM_strings(void);

/* Error codes for the PEM functions. */

/* Function codes. */
# 607 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

/* Reason codes. */
# 637 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pem.h"

# 163 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/hmac.h" 1
/* crypto/hmac/hmac.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

















typedef struct hmac_ctx_st
        {
        const EVP_MD *md;
        EVP_MD_CTX md_ctx;
        EVP_MD_CTX i_ctx;
        EVP_MD_CTX o_ctx;
        unsigned int key_length;
        unsigned char key[128];
        } HMAC_CTX;




void HMAC_CTX_init(HMAC_CTX *ctx);
void HMAC_CTX_cleanup(HMAC_CTX *ctx);



int HMAC_Init(HMAC_CTX *ctx, const void *key, int len,
               const EVP_MD *md); /* deprecated */
int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
                  const EVP_MD *md, ENGINE *impl);
int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len);
int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);
unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
                    const unsigned char *d, size_t n, unsigned char *md,
                    unsigned int *md_len);
int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx);

void HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags);





# 164 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2

# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/kssl.h" 1
/* ssl/kssl.h -*- mode: C; c-file-style: "eay" -*- */
/* Written by Vern Staats <staatsvr@asc.hpc.mil> for the OpenSSL project 2000.
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

/*
**      19990701        VRS     Started.
*/






# 166 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2







/* SSLeay version number for ASN.1 encoding of the session information */
/* Version 0 - initial version
 * Version 1 - added the optional peer certificate
 */


/* text strings for the ciphers */
# 190 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/*    VRS Additional Kerberos5 entries
 */
# 201 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 208 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 216 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"









/* These are used to specify which ciphers to use and not to use */

# 233 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"










# 256 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 268 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 281 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 295 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 303 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"












/*
 * COMPLEMENTOF* definitions. These identifiers are used to (de-select)
 * ciphers normally not being used.
 * Example: "RC4" will activate all ciphers using RC4 including ciphers
 * without authentication, which would normally disabled by DEFAULT (due
 * the "!ADH" being part of default). Therefore "RC4:!COMPLEMENTOFDEFAULT"
 * will make sure that it is also disabled in the specific selection.
 * COMPLEMENTOF* identifiers are portable between version, as adjustments
 * to the default cipher setup will also be included here.
 *
 * COMPLEMENTOFDEFAULT does not experience the same special treatment that
 * DEFAULT gets, as only selection is being done and no sorting as needed
 * for DEFAULT.
 */



/* The following cipher list is used by default.
 * It also is substituted when an application-defined cipher list string
 * starts with 'DEFAULT'. */

/* As of OpenSSL 1.0.0, ssl_create_cipher_list() in ssl/ssl_ciph.c always
 * starts with a reasonable order, and all we have to do for DEFAULT is
 * throwing out anonymous and unencrypted ciphersuites!
 * (The latter are not actually enabled by ALL, but "ALL:RSA" would enable
 * some of them.)
 */

/* Used in SSL_set_shutdown()/SSL_get_shutdown(); */


















/* This is needed to stop compilers complaining about the
 * 'struct ssl_st *' function parameters used to prototype callbacks
 * in SSL_CTX. */
typedef struct ssl_st *ssl_crock_st;
typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
typedef struct ssl_method_st SSL_METHOD;
typedef struct ssl_cipher_st SSL_CIPHER;
typedef struct ssl_session_st SSL_SESSION;

struct stack_st_SSL_CIPHER { _STACK stack; };

/* SRTP protection profiles for use with the use_srtp extension (RFC 5764)*/
typedef struct srtp_protection_profile_st
       {
       const char *name;
       unsigned long id;
       } SRTP_PROTECTION_PROFILE;

struct stack_st_SRTP_PROTECTION_PROFILE { _STACK stack; };

typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data, int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, struct stack_st_SSL_CIPHER *peer_ciphers, SSL_CIPHER **cipher, void *arg);




/* used to hold info on the particular ciphers used */
struct ssl_cipher_st
        {
        int valid;
        const char *name;               /* text name */
        unsigned long id;               /* id, 4 bytes, first is version */

        /* changed in 0.9.9: these four used to be portions of a single value 'algorithms' */
        unsigned long algorithm_mkey;   /* key exchange algorithm */
        unsigned long algorithm_auth;   /* server authentication */
        unsigned long algorithm_enc;    /* symmetric encryption */
        unsigned long algorithm_mac;    /* symmetric authentication */
        unsigned long algorithm_ssl;    /* (major) protocol version */

        unsigned long algo_strength;    /* strength and export flags */
        unsigned long algorithm2;       /* Extra flags */
        int strength_bits;              /* Number of bits really used */
        int alg_bits;                   /* Number of bits for algorithm */
        };


/* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
struct ssl_method_st
        {
        int version;
        int (*ssl_new)(SSL *s);
        void (*ssl_clear)(SSL *s);
        void (*ssl_free)(SSL *s);
        int (*ssl_accept)(SSL *s);
        int (*ssl_connect)(SSL *s);
        int (*ssl_read)(SSL *s,void *buf,int len);
        int (*ssl_peek)(SSL *s,void *buf,int len);
        int (*ssl_write)(SSL *s,const void *buf,int len);
        int (*ssl_shutdown)(SSL *s);
        int (*ssl_renegotiate)(SSL *s);
        int (*ssl_renegotiate_check)(SSL *s);
        long (*ssl_get_message)(SSL *s, int st1, int stn, int mt, long
                max, int *ok);
        int (*ssl_read_bytes)(SSL *s, int type, unsigned char *buf, int len, 
                int peek);
        int (*ssl_write_bytes)(SSL *s, int type, const void *buf_, int len);
        int (*ssl_dispatch_alert)(SSL *s);
        long (*ssl_ctrl)(SSL *s,int cmd,long larg,void *parg);
        long (*ssl_ctx_ctrl)(SSL_CTX *ctx,int cmd,long larg,void *parg);
        const SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
        int (*put_cipher_by_char)(const SSL_CIPHER *cipher,unsigned char *ptr);
        int (*ssl_pending)(const SSL *s);
        int (*num_ciphers)(void);
        const SSL_CIPHER *(*get_cipher)(unsigned ncipher);
        const struct ssl_method_st *(*get_ssl_method)(int version);
        long (*get_timeout)(void);
        struct ssl3_enc_method *ssl3_enc; /* Extra SSLv3/TLS stuff */
        int (*ssl_version)(void);
        long (*ssl_callback_ctrl)(SSL *s, int cb_id, void (*fp)(void));
        long (*ssl_ctx_callback_ctrl)(SSL_CTX *s, int cb_id, void (*fp)(void));
        };

/* Lets make this into an ASN.1 type structure as follows
 * SSL_SESSION_ID ::= SEQUENCE {
 *      version                 INTEGER,        -- structure version number
 *      SSLversion              INTEGER,        -- SSL version number
 *      Cipher                  OCTET STRING,   -- the 3 byte cipher ID
 *      Session_ID              OCTET STRING,   -- the Session ID
 *      Master_key              OCTET STRING,   -- the master key
 *      KRB5_principal          OCTET STRING    -- optional Kerberos principal
 *      Key_Arg [ 0 ] IMPLICIT  OCTET STRING,   -- the optional Key argument
 *      Time [ 1 ] EXPLICIT     INTEGER,        -- optional Start Time
 *      Timeout [ 2 ] EXPLICIT  INTEGER,        -- optional Timeout ins seconds
 *      Peer [ 3 ] EXPLICIT     X509,           -- optional Peer Certificate
 *      Session_ID_context [ 4 ] EXPLICIT OCTET STRING,   -- the Session ID context
 *      Verify_result [ 5 ] EXPLICIT INTEGER,   -- X509_V_... code for `Peer'
 *      HostName [ 6 ] EXPLICIT OCTET STRING,   -- optional HostName from servername TLS extension 
 *      PSK_identity_hint [ 7 ] EXPLICIT OCTET STRING, -- optional PSK identity hint
 *      PSK_identity [ 8 ] EXPLICIT OCTET STRING,  -- optional PSK identity
 *      Ticket_lifetime_hint [9] EXPLICIT INTEGER, -- server's lifetime hint for session ticket
 *      Ticket [10]             EXPLICIT OCTET STRING, -- session ticket (clients only)
 *      Compression_meth [11]   EXPLICIT OCTET STRING, -- optional compression method
 *      SRP_username [ 12 ] EXPLICIT OCTET STRING -- optional SRP username
 *      }
 * Look in ssl/ssl_asn1.c for more details
 * I'm using EXPLICIT tags so I can read the damn things using asn1parse :-).
 */
struct ssl_session_st
        {
        int ssl_version;        /* what ssl version session info is
                                 * being kept in here? */

        /* only really used in SSLv2 */
        unsigned int key_arg_length;
        unsigned char key_arg[8];
        int master_key_length;
        unsigned char master_key[48];
        /* session_id - valid? */
        unsigned int session_id_length;
        unsigned char session_id[32];
        /* this is used to determine whether the session is being reused in
         * the appropriate context. It is up to the application to set this,
         * via SSL_new */
        unsigned int sid_ctx_length;
        unsigned char sid_ctx[32];






        char *psk_identity_hint;
        char *psk_identity;

        /* Used to indicate that session resumption is not allowed.
         * Applications can also set this bit for a new session via
         * not_resumable_session_cb to disable session caching and tickets. */
        int not_resumable;

        /* The cert is the certificate used to establish this connection */
        struct sess_cert_st /* SESS_CERT */ *sess_cert;

        /* This is the cert for the other end.
         * On clients, it will be the same as sess_cert->peer_key->x509
         * (the latter is not enough as sess_cert is not retained
         * in the external representation of sessions, see ssl_asn1.c). */
        X509 *peer;
        /* when app_verify_callback accepts a session where the peer's certificate
         * is not ok, we must remember the error for session reuse: */
        long verify_result; /* only for servers */

        int references;
        long timeout;
        long time;

        unsigned int compress_meth;     /* Need to lookup the method */

        const SSL_CIPHER *cipher;
        unsigned long cipher_id;        /* when ASN.1 loaded, this
                                         * needs to be used to load
                                         * the 'cipher' structure */

        struct stack_st_SSL_CIPHER *ciphers; /* shared ciphers? */

        CRYPTO_EX_DATA ex_data; /* application specific data */

        /* These are used to make removal of session-ids more
         * efficient and to implement a maximum cache size. */
        struct ssl_session_st *prev,*next;

        char *tlsext_hostname;

        size_t tlsext_ecpointformatlist_length;
        unsigned char *tlsext_ecpointformatlist; /* peer's list */
        size_t tlsext_ellipticcurvelist_length;
        unsigned char *tlsext_ellipticcurvelist; /* peer's list */

        /* RFC4507 info */
        unsigned char *tlsext_tick;     /* Session ticket */
        size_t tlsext_ticklen;          /* Session ticket length */
        long tlsext_tick_lifetime_hint; /* Session lifetime hint in seconds */


        char *srp_username;

        };





/* Allow initial connection to servers that don't support RI */
# 563 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* Hasn't done anything since OpenSSL 0.9.7h, retained for compatibility */

/* Refers to ancient SSLREF and SSLv2, retained for compatibility */


/* Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
 * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
 * the workaround is not needed.  Unfortunately some broken SSL/TLS
 * implementations cannot handle it at all, which is why we include
 * it in SSL_OP_ALL. */


/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
 *             This used to be 0x000FFFFFL before 0.9.7. */


/* DTLS options */

/* Turn on Cookie Exchange (on relevant for servers) */

/* Don't use RFC4507 ticket extension */

/* Use Cisco's "speshul" version of DTLS_BAD_VER (as client)  */


/* As server, disallow session resumption on renegotiation */

/* Don't use compression even if supported */

/* Permit unsafe legacy renegotiation */

/* If set, always create a new key when using tmp_ecdh parameters */

/* If set, always create a new key when using tmp_dh parameters */

/* Does nothing: retained for compatibiity */

/* Set on servers to choose the cipher according to the server's
 * preferences */

/* If set, a server will allow a client to issue a SSLv3.0 version number
 * as latest version supported in the premaster secret, even when TLSv1.0
 * (version 3.1) was announced in the client hello. Normally this is
 * forbidden to prevent version rollback attacks. */








/* These next two were never actually used for anything since SSLeay
 * zap so we have some more flags.
 */
/* The next flag deliberately changes the ciphertest, this is a check
 * for the PKCS#1 attack */





/* Make server add server-hello extension from early version of
 * cryptopro draft, when GOST ciphersuite is negotiated. 
 * Required for interoperability with CryptoPro CSP 3.x 
 */


/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
 * when just a single record has been written): */

/* Make it possible to retry SSL_write() with changed buffer location
 * (buffer contents must stay the same!); this is not the default to avoid
 * the misconception that non-blocking SSL_write() behaves like
 * non-blocking write(): */

/* Never bother the application with retries if the transport
 * is blocking: */

/* Don't attempt to automatically build certificate chain */

/* Save RAM by releasing read and write buffers when they're empty. (SSL3 and
 * TLS only.)  "Released" buffers are put onto a free-list in the context
 * or just freed (depending on the context's setting for freelist_max_len). */

/* Send the current time in the Random fields of the ClientHello and
 * ServerHello records for compatibility with hypothetical implementations
 * that require it.
 */


/* Send TLS_FALLBACK_SCSV in the ClientHello.
 * To be set only by applications that reconnect with a downgraded protocol
 * version; see draft-ietf-tls-downgrade-scsv-00 for details.
 *
 * DO NOT ENABLE THIS if your application attempts a normal handshake.
 * Only use this in explicit fallback retries, following the guidance
 * in draft-ietf-tls-downgrade-scsv-00.
 */


/* Note: SSL[_CTX]_set_{options,mode} use |= op on the previous value,
 * they cannot be used to clear bits. */

# 680 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 699 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"









void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));







typedef struct srp_ctx_st
        {
        /* param for all the callbacks */
        void *SRP_cb_arg;
        /* set client Hello login callback */
        int (*TLS_ext_srp_username_callback)(SSL *, int *, void *);
        /* set SRP N/g param callback for verification */
        int (*SRP_verify_param_callback)(SSL *, void *);
        /* set SRP client passwd callback */
        char *(*SRP_give_srp_client_pwd_callback)(SSL *, void *);

        char *login;
        BIGNUM *N,*g,*s,*B,*A;
        BIGNUM *a,*b,*v;
        char *info;
        int strength;

        unsigned long srp_Mask;
        } SRP_CTX;



/* see tls_srp.c */
int SSL_SRP_CTX_init(SSL *s);
int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);
int SSL_SRP_CTX_free(SSL *ctx);
int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);
int SSL_srp_server_param_with_username(SSL *s, int *ad);
int SRP_generate_server_master_secret(SSL *s,unsigned char *master_key);
int SRP_Calc_A_param(SSL *s);
int SRP_generate_client_master_secret(SSL *s,unsigned char *master_key);











/* This callback type is used inside SSL_CTX, SSL, and in the functions that set
 * them. It is used to override the generation of SSL/TLS session IDs in a
 * server. Return value should be zero on an error, non-zero to proceed. Also,
 * callbacks should themselves check if the id they generate is unique otherwise
 * the SSL handshake will fail with an error - callbacks can do this using the
 * 'ssl' value they're passed by;
 *      SSL_has_matching_session_id(ssl, id, *id_len)
 * The length value passed in is set at the maximum size the session ID can be.
 * In SSLv2 this is 16 bytes, whereas SSLv3/TLSv1 it is 32 bytes. The callback
 * can alter this length to be less if desired, but under SSLv2 session IDs are
 * supposed to be fixed at 16 bytes so the id will be padded after the callback
 * returns in this case. It is also an error for the callback to set the size to
 * zero. */
typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,
                                unsigned int *id_len);

typedef struct ssl_comp_st SSL_COMP;



struct ssl_comp_st
        {
        int id;
        const char *name;

        COMP_METHOD *method;



        };

struct stack_st_SSL_COMP { _STACK stack; };
struct lhash_st_SSL_SESSION { int dummy; };

struct ssl_ctx_st
        {
        const SSL_METHOD *method;

        struct stack_st_SSL_CIPHER *cipher_list;
        /* same as above but sorted for lookup */
        struct stack_st_SSL_CIPHER *cipher_list_by_id;

        struct x509_store_st /* X509_STORE */ *cert_store;
        struct lhash_st_SSL_SESSION *sessions;
        /* Most session-ids that will be cached, default is
         * SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited. */
        unsigned long session_cache_size;
        struct ssl_session_st *session_cache_head;
        struct ssl_session_st *session_cache_tail;

        /* This can have one of 2 values, ored together,
         * SSL_SESS_CACHE_CLIENT,
         * SSL_SESS_CACHE_SERVER,
         * Default is SSL_SESSION_CACHE_SERVER, which means only
         * SSL_accept which cache SSL_SESSIONS. */
        int session_cache_mode;

        /* If timeout is not 0, it is the default timeout value set
         * when SSL_new() is called.  This has been put in to make
         * life easier to set things up */
        long session_timeout;

        /* If this callback is not null, it will be called each
         * time a session id is added to the cache.  If this function
         * returns 1, it means that the callback will do a
         * SSL_SESSION_free() when it has finished using it.  Otherwise,
         * on 0, it means the callback has finished with it.
         * If remove_session_cb is not null, it will be called when
         * a session-id is removed from the cache.  After the call,
         * OpenSSL will SSL_SESSION_free() it. */
        int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess);
        void (*remove_session_cb)(struct ssl_ctx_st *ctx,SSL_SESSION *sess);
        SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl,
                unsigned char *data,int len,int *copy);

        struct
                {
                int sess_connect;       /* SSL new conn - started */
                int sess_connect_renegotiate;/* SSL reneg - requested */
                int sess_connect_good;  /* SSL new conne/reneg - finished */
                int sess_accept;        /* SSL new accept - started */
                int sess_accept_renegotiate;/* SSL reneg - requested */
                int sess_accept_good;   /* SSL accept/reneg - finished */
                int sess_miss;          /* session lookup misses  */
                int sess_timeout;       /* reuse attempt on timeouted session */
                int sess_cache_full;    /* session removed due to full cache */
                int sess_hit;           /* session reuse actually done */
                int sess_cb_hit;        /* session-id that was not
                                         * in the cache was
                                         * passed back via the callback.  This
                                         * indicates that the application is
                                         * supplying session-id's from other
                                         * processes - spooky :-) */
                } stats;

        int references;

        /* if defined, these override the X509_verify_cert() calls */
        int (*app_verify_callback)(X509_STORE_CTX *, void *);
        void *app_verify_arg;
        /* before OpenSSL 0.9.7, 'app_verify_arg' was ignored
         * ('app_verify_callback' was called with just one argument) */

        /* Default password callback. */
        pem_password_cb *default_passwd_callback;

        /* Default password callback user data. */
        void *default_passwd_callback_userdata;

        /* get client cert callback */
        int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);

    /* cookie generate callback */
    int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int *cookie_len);

    /* verify cookie callback */
    int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int cookie_len);

        CRYPTO_EX_DATA ex_data;

        const EVP_MD *rsa_md5;/* For SSLv2 - name is 'ssl2-md5' */
        const EVP_MD *md5;      /* For SSLv3/TLSv1 'ssl3-md5' */
        const EVP_MD *sha1;   /* For SSLv3/TLSv1 'ssl3->sha1' */

        struct stack_st_X509 *extra_certs;
        struct stack_st_SSL_COMP *comp_methods; /* stack of SSL_COMP, SSLv3/TLSv1 */


        /* Default values used when no per-SSL value is defined follow */

        void (*info_callback)(const SSL *ssl,int type,int val); /* used if SSL's info_callback is NULL */

        /* what we put in client cert requests */
        struct stack_st_X509_NAME *client_CA;


        /* Default values to use in SSL structures follow (these are copied by SSL_new) */

        unsigned long options;
        unsigned long mode;
        long max_cert_list;

        struct cert_st /* CERT */ *cert;
        int read_ahead;

        /* callback that allows applications to peek at protocol messages */
        void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
        void *msg_callback_arg;

        int verify_mode;
        unsigned int sid_ctx_length;
        unsigned char sid_ctx[32];
        int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx); /* called 'verify_callback' in the SSL */

        /* Default generate session ID callback. */
        GEN_SESSION_CB generate_session_id;

        X509_VERIFY_PARAM *param;






        int quiet_shutdown;

        /* Maximum amount of data to send in one fragment.
         * actual record size can be more than this due to
         * padding and MAC overheads.
         */
        unsigned int max_send_fragment;


        /* Engine to pass requests for client certs to
         */
        ENGINE *client_cert_engine;



        /* TLS extensions servername callback */
        int (*tlsext_servername_callback)(SSL*, int *, void *);
        void *tlsext_servername_arg;
        /* RFC 4507 session ticket keys */
        unsigned char tlsext_tick_key_name[16];
        unsigned char tlsext_tick_hmac_key[16];
        unsigned char tlsext_tick_aes_key[16];
        /* Callback to support customisation of ticket key setting */
        int (*tlsext_ticket_key_cb)(SSL *ssl,
                                        unsigned char *name, unsigned char *iv,
                                        EVP_CIPHER_CTX *ectx,
                                        HMAC_CTX *hctx, int enc);

        /* certificate status request info */
        /* Callback for status request */
        int (*tlsext_status_cb)(SSL *ssl, void *arg);
        void *tlsext_status_arg;

        /* draft-rescorla-tls-opaque-prf-input-00.txt information */
        int (*tlsext_opaque_prf_input_callback)(SSL *, void *peerinput, size_t len, void *arg);
        void *tlsext_opaque_prf_input_callback_arg;



        char *psk_identity_hint;
        unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
                unsigned int max_identity_len, unsigned char *psk,
                unsigned int max_psk_len);
        unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
                unsigned char *psk, unsigned int max_psk_len);




        unsigned int freelist_max_len;
        struct ssl3_buf_freelist_st *wbuf_freelist;
        struct ssl3_buf_freelist_st *rbuf_freelist;


        SRP_CTX srp_ctx; /* ctx for SRP authentication */





        /* Next protocol negotiation information */
        /* (for experimental NPN extension). */

        /* For a server, this contains a callback function by which the set of
         * advertised protocols can be provided. */
        int (*next_protos_advertised_cb)(SSL *s, const unsigned char **buf,
                                         unsigned int *len, void *arg);
        void *next_protos_advertised_cb_arg;
        /* For a client, this contains a callback function that selects the
         * next protocol from the list provided by the server. */
        int (*next_proto_select_cb)(SSL *s, unsigned char **out,
                                    unsigned char *outlen,
                                    const unsigned char *in,
                                    unsigned int inlen,
                                    void *arg);
        void *next_proto_select_cb_arg;

        /* SRTP profiles we are willing to do from RFC 5764 */
        struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;  

        };








/* enough comments already ... see SSL_CTX_set_session_cache_mode(3) */





struct lhash_st_SSL_SESSION *SSL_CTX_sessions(SSL_CTX *ctx);
# 1045 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess));
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx, void (*remove_session_cb)(struct ssl_ctx_st *ctx,SSL_SESSION *sess));
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx, SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,int len,int *copy));
SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *Data, int len, int *copy);
void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl,int type,int val);
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);

int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);

void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx, int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len));
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx, int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len));

void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s,
                                           int (*cb) (SSL *ssl,
                                                      const unsigned char **out,
                                                      unsigned int *outlen,
                                                      void *arg),
                                           void *arg);
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s,
                                      int (*cb) (SSL *ssl,
                                                 unsigned char **out,
                                                 unsigned char *outlen,
                                                 const unsigned char *in,
                                                 unsigned int inlen,
                                                 void *arg),
                                      void *arg);

int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
                          const unsigned char *in, unsigned int inlen,
                          const unsigned char *client, unsigned int client_len);
void SSL_get0_next_proto_negotiated(const SSL *s,
                                    const unsigned char **data, unsigned *len);







/* the maximum length of the buffer given to callbacks containing the
 * resulting identity/psk */


void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, 
        unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
                char *identity, unsigned int max_identity_len, unsigned char *psk,
                unsigned int max_psk_len));
void SSL_set_psk_client_callback(SSL *ssl, 
        unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
                char *identity, unsigned int max_identity_len, unsigned char *psk,
                unsigned int max_psk_len));
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, 
        unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
                unsigned char *psk, unsigned int max_psk_len));
void SSL_set_psk_server_callback(SSL *ssl,
        unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
                unsigned char *psk, unsigned int max_psk_len));
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint);
int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);
const char *SSL_get_psk_identity_hint(const SSL *s);
const char *SSL_get_psk_identity(const SSL *s);







/* These will only be used when doing non-blocking IO */










struct ssl_st
        {
        /* protocol version
         * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, DTLS1_VERSION)
         */
        int version;
        int type; /* SSL_ST_CONNECT or SSL_ST_ACCEPT */

        const SSL_METHOD *method; /* SSLv3 */

        /* There are 2 BIO's even though they are normally both the
         * same.  This is so data can be read and written to different
         * handlers */


        BIO *rbio; /* used by SSL_read */
        BIO *wbio; /* used by SSL_write */
        BIO *bbio; /* used during session-id reuse to concatenate
                    * messages */





        /* This holds a variable that indicates what we were doing
         * when a 0 or -1 is returned.  This is needed for
         * non-blocking IO so we know what request needs re-doing when
         * in SSL_accept or SSL_connect */
        int rwstate;

        /* true when we are actually in SSL_accept() or SSL_connect() */
        int in_handshake;
        int (*handshake_func)(SSL *);

        /* Imagine that here's a boolean member "init" that is
         * switched as soon as SSL_set_{accept/connect}_state
         * is called for the first time, so that "state" and
         * "handshake_func" are properly initialized.  But as
         * handshake_func is == 0 until then, we use this
         * test instead of an "init" member.
         */

        int server;     /* are we the server side? - mostly used by SSL_clear*/

        int new_session;/* Generate a new session or reuse an old one.
                         * NB: For servers, the 'new' session may actually be a previously
                         * cached session or even the previous session unless
                         * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
        int quiet_shutdown;/* don't send shutdown packets */
        int shutdown;   /* we have shut things down, 0x01 sent, 0x02
                         * for received */
        int state;      /* where we are */
        int rstate;     /* where we are when reading */

        BUF_MEM *init_buf;      /* buffer used during init */
        void *init_msg;         /* pointer to handshake message body, set by ssl3_get_message() */
        int init_num;           /* amount read/written */
        int init_off;           /* amount read/written */

        /* used internally to point at a raw packet */
        unsigned char *packet;
        unsigned int packet_length;

        struct ssl2_state_st *s2; /* SSLv2 variables */
        struct ssl3_state_st *s3; /* SSLv3 variables */
        struct dtls1_state_st *d1; /* DTLSv1 variables */

        int read_ahead;         /* Read as many input bytes as possible
                                 * (for non-blocking reads) */

        /* callback that allows applications to peek at protocol messages */
        void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
        void *msg_callback_arg;

        int hit;                /* reusing a previous session */

        X509_VERIFY_PARAM *param;






        /* crypto */
        struct stack_st_SSL_CIPHER *cipher_list;
        struct stack_st_SSL_CIPHER *cipher_list_by_id;

        /* These are the ones being used, the ones in SSL_SESSION are
         * the ones to be 'copied' into these ones */
        int mac_flags; 
        EVP_CIPHER_CTX *enc_read_ctx;           /* cryptographic state */
        EVP_MD_CTX *read_hash;          /* used for mac generation */

        COMP_CTX *expand;                       /* uncompress */




        EVP_CIPHER_CTX *enc_write_ctx;          /* cryptographic state */
        EVP_MD_CTX *write_hash;         /* used for mac generation */

        COMP_CTX *compress;                     /* compression */




        /* session info */

        /* client cert? */
        /* This is used to hold the server certificate used */
        struct cert_st /* CERT */ *cert;

        /* the session_id_context is used to ensure sessions are only reused
         * in the appropriate context */
        unsigned int sid_ctx_length;
        unsigned char sid_ctx[32];

        /* This can also be in the session once a session is established */
        SSL_SESSION *session;

        /* Default generate session ID callback. */
        GEN_SESSION_CB generate_session_id;

        /* Used in SSL2 and SSL3 */
        int verify_mode;        /* 0 don't care about verify failure.
                                 * 1 fail if verify fails */
        int (*verify_callback)(int ok,X509_STORE_CTX *ctx); /* fail if callback returns 0 */

        void (*info_callback)(const SSL *ssl,int type,int val); /* optional informational callback */

        int error;              /* error bytes to be written */
        int error_code;         /* actual code */






        unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
                unsigned int max_identity_len, unsigned char *psk,
                unsigned int max_psk_len);
        unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
                unsigned char *psk, unsigned int max_psk_len);


        SSL_CTX *ctx;
        /* set this flag to 1 and a sleep(1) is put into all SSL_read()
         * and SSL_write() calls, good for nbio debuging :-) */
        int debug;      

        /* extra application data */
        long verify_result;
        CRYPTO_EX_DATA ex_data;

        /* for server side, keep the list of CA_dn we can use */
        struct stack_st_X509_NAME *client_CA;

        int references;
        unsigned long options; /* protocol behaviour */
        unsigned long mode; /* API behaviour */
        long max_cert_list;
        int first_packet;
        int client_version;     /* what was passed, used for
                                 * SSLv3/TLS rollback check */
        unsigned int max_send_fragment;

        /* TLS extension debug callback */
        void (*tlsext_debug_cb)(SSL *s, int client_server, int type,
                                        unsigned char *data, int len,
                                        void *arg);
        void *tlsext_debug_arg;
        char *tlsext_hostname;
        int servername_done;   /* no further mod of servername 
                                  0 : call the servername extension callback.
                                  1 : prepare 2, allow last ack just after in server callback.
                                  2 : don't call servername callback, no ack in server hello
                               */
        /* certificate status request info */
        /* Status type or -1 if no status type */
        int tlsext_status_type;
        /* Expect OCSP CertificateStatus message */
        int tlsext_status_expected;
        /* OCSP status request only */
        struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
        X509_EXTENSIONS *tlsext_ocsp_exts;
        /* OCSP response received or to be sent */
        unsigned char *tlsext_ocsp_resp;
        int tlsext_ocsp_resplen;

        /* RFC4507 session ticket expected to be received or sent */
        int tlsext_ticket_expected;

        size_t tlsext_ecpointformatlist_length;
        unsigned char *tlsext_ecpointformatlist; /* our list */
        size_t tlsext_ellipticcurvelist_length;
        unsigned char *tlsext_ellipticcurvelist; /* our list */


        /* draft-rescorla-tls-opaque-prf-input-00.txt information to be used for handshakes */
        void *tlsext_opaque_prf_input;
        size_t tlsext_opaque_prf_input_len;

        /* TLS Session Ticket extension override */
        TLS_SESSION_TICKET_EXT *tlsext_session_ticket;

        /* TLS Session Ticket extension callback */
        tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;
        void *tls_session_ticket_ext_cb_arg;

        /* TLS pre-shared secret session resumption */
        tls_session_secret_cb_fn tls_session_secret_cb;
        void *tls_session_secret_cb_arg;

        SSL_CTX * initial_ctx; /* initial ctx, used to store sessions */


        /* Next protocol negotiation. For the client, this is the protocol that
         * we sent in NextProtocol and is set when handling ServerHello
         * extensions.
         *
         * For a server, this is the client's selected_protocol from
         * NextProtocol and is set when handling the NextProtocol message,
         * before the Finished message. */
        unsigned char *next_proto_negotiated;
        unsigned char next_proto_negotiated_len;




        struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;  /* What we'll do */
        SRTP_PROTECTION_PROFILE *srtp_profile;            /* What's been chosen */

        unsigned int tlsext_heartbeat;  /* Is use of the Heartbeat extension negotiated?
                                           0: disabled
                                           1: enabled
                                           2: enabled, but not allowed to send Requests
                                         */
        unsigned int tlsext_hb_pending; /* Indicates if a HeartbeatRequest is in flight */
        unsigned int tlsext_hb_seq;     /* HeartbeatRequest sequence number */




        int renegotiate;/* 1 if we are renegotiating.
                         * 2 if we are a server and are inside a handshake
                         * (i.e. not just sending a HelloRequest) */


        SRP_CTX srp_ctx; /* ctx for SRP authentication */

        };







# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h" 1
/* ssl/ssl2.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */








/* Protocol Version Codes */



/* #define SSL2_CLIENT_VERSION  0x0002 */
/* #define SSL2_SERVER_VERSION  0x0002 */

/* Protocol Message Codes */
# 83 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"

/* Error Message Codes */






/* Cipher Kind Values */
# 103 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"
 



# 119 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"



/* Flags for the SSL_CIPHER.algorithm2 field */



/* Certificate Type Codes */


/* Authentication Type Code */




/* Upper/Lower Bounds */
# 142 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"


/*#define SSL2_CHALLENGE_LENGTH 32 */
# 153 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"







typedef struct ssl2_state_st
        {
        int three_byte_header;
        int clear_text;         /* clear text */
        int escape;             /* not used in SSLv2 */
        int ssl2_rollback;      /* used if SSLv23 rolled back to SSLv2 */

        /* non-blocking io info, used to make sure the same
         * args were passwd */
        unsigned int wnum;      /* number of bytes sent so far */
        int wpend_tot;
        const unsigned char *wpend_buf;

        int wpend_off;  /* offset to data to write */
        int wpend_len;  /* number of bytes passwd to write */
        int wpend_ret;  /* number of bytes to return to caller */

        /* buffer raw data */
        int rbuf_left;
        int rbuf_offs;
        unsigned char *rbuf;
        unsigned char *wbuf;

        unsigned char *write_ptr;/* used to point to the start due to
                                  * 2/3 byte header. */

        unsigned int padding;
        unsigned int rlength; /* passed to ssl2_enc */
        int ract_data_length; /* Set when things are encrypted. */
        unsigned int wlength; /* passed to ssl2_enc */
        int wact_data_length; /* Set when things are decrypted. */
        unsigned char *ract_data;
        unsigned char *wact_data;
        unsigned char *mac_data;

        unsigned char *read_key;
        unsigned char *write_key;

                /* Stuff specifically to do with this SSL session */
        unsigned int challenge_length;
        unsigned char challenge[32];
        unsigned int conn_id_length;
        unsigned char conn_id[16];
        unsigned int key_material_length;
        unsigned char key_material[24*2];

        unsigned long read_sequence;
        unsigned long write_sequence;

        struct  {
                unsigned int conn_id_length;
                unsigned int cert_type; 
                unsigned int cert_length;
                unsigned int csl; 
                unsigned int clear;
                unsigned int enc; 
                unsigned char ccl[32];
                unsigned int cipher_spec_length;
                unsigned int session_id_length;
                unsigned int clen;
                unsigned int rlen;
                } tmp;
        } SSL2_STATE;



/* SSLv2 */
/* client */
# 246 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"
/* server */
# 267 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl2.h"






# 1388 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h" 1
/* ssl/ssl3.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 1
/* ssl/ssl.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

# 126 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h" 2





/* Signalling cipher suite value from RFC 5746
 * (TLS_EMPTY_RENEGOTIATION_INFO_SCSV) */


/* Signalling cipher suite value from draft-ietf-tls-downgrade-scsv-00
 * (TLS_FALLBACK_SCSV) */


# 149 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 156 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 163 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"







# 179 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

/*    VRS Additional Kerberos5 entries
 */
# 190 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 197 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 208 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 215 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 222 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"













# 243 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 250 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"










 /* Some will argue that this increases memory footprint, but it's
  * not actually true. Point is that malloc has to return at least
  * 64-bit aligned pointers, meaning that allocating 5 bytes wastes
  * 3 bytes in either case. Suggested pre-gaping simply moves these
  * wasted bytes from the end of allocated region to its front,
  * but makes data payload aligned, which improves performance:-) */
# 273 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

/* This is the maximum MAC (digest) size used by the SSL library.
 * Currently maximum of 20 is used by SHA1, but we reserve for
 * future extension for 512-bit hashes.
 */



/* Maximum block size used in all ciphersuites. Currently 16 for AES.
 */





/* Maximum plaintext length: defined by SSL/TLS standards */

/* Maximum compression overhead: defined by SSL/TLS standards */


/* The standards give a maximum encryption overhead of 1024 bytes.
 * In practice the value is lower than this. The overhead is the maximum
 * number of padding bytes (256) plus the mac size.
 */


/* OpenSSL currently only uses a padding length of at most one block so
 * the send overhead is smaller.
 */




/* If compression isn't used don't include the compression overhead */

# 318 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

















# 347 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"



        


typedef struct ssl3_record_st
        {
/*r */  int type;               /* type of record */
/*rw*/  unsigned int length;    /* How many bytes available */
/*r */  unsigned int off;       /* read/write offset into 'buf' */
/*rw*/  unsigned char *data;    /* pointer to the record data */
/*rw*/  unsigned char *input;   /* where the decode bytes are */
/*r */  unsigned char *comp;    /* only used with decompression - malloc()ed */
/*r */  unsigned long epoch;    /* epoch number, needed by DTLS1 */
/*r */  unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */
        } SSL3_RECORD;

typedef struct ssl3_buffer_st
        {
        unsigned char *buf;     /* at least SSL3_RT_MAX_PACKET_SIZE bytes,
                                 * see ssl3_setup_buffers() */
        size_t len;             /* buffer size */
        int offset;             /* where to 'copy from' */
        int left;               /* how many bytes left */
        } SSL3_BUFFER;



# 383 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/* SSL3_CT_NUMBER is used to size arrays and it must be large
 * enough to contain all of the cert types defined either for
 * SSLv3 and TLSv1.
 */



# 396 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/*
 * Set when the handshake is ready to process peer's ChangeCipherSpec message.
 * Cleared after the message has been processed.
 */


/* SSL3_FLAGS_SGC_RESTART_DONE is set when we
 * restart a handshake because of MS SGC and so prevents us
 * from restarting the handshake in a loop. It's reset on a
 * renegotiation, so effectively limits the client to one restart
 * per negotiation. This limits the possibility of a DDoS
 * attack where the client handshakes in a loop using SGC to
 * restart. Servers which permit renegotiation can still be
 * effected, but we can't prevent that.
 */




typedef struct ssl3_state_st
        {
        long flags;
        int delay_buf_pop_ret;

        unsigned char read_sequence[8];
        int read_mac_secret_size;
        unsigned char read_mac_secret[64];
        unsigned char write_sequence[8];
        int write_mac_secret_size;
        unsigned char write_mac_secret[64];

        unsigned char server_random[32];
        unsigned char client_random[32];

        /* flags for countermeasure against known-IV weakness */
        int need_empty_fragments;
        int empty_fragment_done;

        /* The value of 'extra' when the buffers were initialized */
        int init_extra;

        SSL3_BUFFER rbuf;       /* read IO goes into here */
        SSL3_BUFFER wbuf;       /* write IO goes into here */

        SSL3_RECORD rrec;       /* each decoded record goes in here */
        SSL3_RECORD wrec;       /* goes out from here */

        /* storage for Alert/Handshake protocol data received but not
         * yet processed by ssl3_read_bytes: */
        unsigned char alert_fragment[2];
        unsigned int alert_fragment_len;
        unsigned char handshake_fragment[4];
        unsigned int handshake_fragment_len;

        /* partial write - check the numbers match */
        unsigned int wnum;      /* number of bytes sent so far */
        int wpend_tot;          /* number bytes written */
        int wpend_type;
        int wpend_ret;          /* number of bytes submitted */
        const unsigned char *wpend_buf;

        /* used during startup, digest all incoming/outgoing packets */
        BIO *handshake_buffer;
        /* When set of handshake digests is determined, buffer is hashed
         * and freed and MD_CTX-es for all required digests are stored in
         * this array */
        EVP_MD_CTX **handshake_dgst;
        /*
         * Set whenever an expected ChangeCipherSpec message is processed.
         * Unset when the peer's Finished message is received.
         * Unexpected ChangeCipherSpec messages trigger a fatal alert.
         */
        int change_cipher_spec;

        int warn_alert;
        int fatal_alert;
        /* we allow one fatal and one warning alert to be outstanding,
         * send close alert via the warning alert */
        int alert_dispatch;
        unsigned char send_alert[2];

        /* This flag is set when we should renegotiate ASAP, basically when
         * there is no more data in the read or write buffers */
        int renegotiate;
        int total_renegotiations;
        int num_renegotiations;

        int in_read_app_data;

        /* Opaque PRF input as used for the current handshake.
         * These fields are used only if TLSEXT_TYPE_opaque_prf_input is defined
         * (otherwise, they are merely present to improve binary compatibility) */
        void *client_opaque_prf_input;
        size_t client_opaque_prf_input_len;
        void *server_opaque_prf_input;
        size_t server_opaque_prf_input_len;

        struct  {
                /* actually only needs to be 16+20 */
                unsigned char cert_verify_md[64*2];

                /* actually only need to be 16+20 for SSLv3 and 12 for TLS */
                unsigned char finish_md[64*2];
                int finish_md_len;
                unsigned char peer_finish_md[64*2];
                int peer_finish_md_len;

                unsigned long message_size;
                int message_type;

                /* used to hold the new cipher we are going to use */
                const SSL_CIPHER *new_cipher;

                DH *dh;



                EC_KEY *ecdh; /* holds short lived ECDH key */


                /* used when SSL_ST_FLUSH_DATA is entered */
                int next_state;                 

                int reuse_message;

                /* used for certificate requests */
                int cert_req;
                int ctype_num;
                char ctype[9];
                struct stack_st_X509_NAME *ca_names;

                int use_rsa_tmp;

                int key_block_length;
                unsigned char *key_block;

                const EVP_CIPHER *new_sym_enc;
                const EVP_MD *new_hash;
                int new_mac_pkey_type;
                int new_mac_secret_size;

                const SSL_COMP *new_compression;



                int cert_request;
                } tmp;

        /* Connection binding to prevent renegotiation attacks */
        unsigned char previous_client_finished[64];
        unsigned char previous_client_finished_len;
        unsigned char previous_server_finished[64];
        unsigned char previous_server_finished_len;
        int send_connection_binding; /* TODOEKR */


        /* Set if we saw the Next Protocol Negotiation extension from our peer. */
        int next_proto_neg_seen;




        /* This is set to true if we believe that this is a version of Safari
         * running on OS X 10.6 or newer. We wish to know this because Safari
         * on 10.8 .. 10.8.3 has broken ECDHE-ECDSA support. */
        char is_probably_safari;


        } SSL3_STATE;



/* SSLv3 */
/*client */
/* extra state */





/* write to server */


/* read from server */
# 592 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/* write to server */
# 609 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/* read from server */
# 618 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

/* server */
/* extra state */





/* read from client */
/* Do not change the number values, they do matter */



/* write to client */
# 647 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/* read from client */
# 662 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"
/* write to client */
# 671 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"

# 688 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"




/* These are used when changing over to a new cipher */
# 701 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl3.h"






# 1389 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h" 1
/* ssl/tls1.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * ECC cipher suite support in OpenSSL originally written by
 * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
































# 195 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"
/* codes 110-114 are from RFC3546 */
# 202 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ExtensionType values from RFC3546 / RFC4366 / RFC6066 */
# 210 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"
/* ExtensionType values from RFC4681 */


/* ExtensionType values from RFC5878 */



/* ExtensionType values from RFC6091 */


/* ExtensionType values from RFC4492 */



/* ExtensionType value from RFC5054 */


/* ExtensionType values from RFC5246 */


/* ExtensionType value from RFC5764 */


/* ExtensionType value from RFC5620 */


/* ExtensionType value for TLS padding extension.
 * http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
 * http://tools.ietf.org/html/draft-agl-tls-padding-03
 */


/* ExtensionType value from RFC4507 */


/* ExtensionType value from draft-rescorla-tls-opaque-prf-input-00.txt */






/* Temporary extension type */



/* This is not an IANA defined extension number */



/* NameType value from RFC 3546 */

/* status request value from RFC 3546 */


/* ECPointFormat values from draft-ietf-tls-ecc-12 */






/* Signature and hash algorithms from RFC 5246 */






# 286 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"





const char *SSL_get_servername(const SSL *s, const int type);
int SSL_get_servername_type(const SSL *s);
/* SSL_export_keying_material exports a value derived from the master secret,
 * as specified in RFC 5705. It writes |olen| bytes to |out| given a label and
 * optional context. (Since a zero length context is allowed, the |use_context|
 * flag controls whether a context is included.)
 *
 * It returns 1 on success and zero otherwise.
 */
int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
        const char *label, size_t llen, const unsigned char *p, size_t plen,
        int use_context);





















































# 362 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"









# 377 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* PSK ciphersuites from 4279 */





/* Additional TLS ciphersuites from expired Internet Draft
 * draft-ietf-tls-56-bit-ciphersuites-01.txt
 * (available if TLS1_ALLOW_EXPERIMENTAL_CIPHERSUITES is defined, see
 * s3_lib.c).  We actually treat them like SSL 3.0 ciphers, which we probably
 * shouldn't.  Note that the first two are actually not in the IDs. */
# 396 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* AES ciphersuites from RFC3268 */

# 405 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

# 412 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS v1.2 ciphersuites */
# 420 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* Camellia ciphersuites from RFC4132 */
# 428 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS v1.2 ciphersuites */
# 437 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* Camellia ciphersuites from RFC4132 */
# 445 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* SEED ciphersuites from RFC4162 */
# 453 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS v1.2 GCM ciphersuites from RFC5288 */
# 467 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECC ciphersuites from draft-ietf-tls-ecc-12.txt with changes soon to be in draft 13 */






























/* SRP ciphersuites from RFC 5054 */
# 509 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECDH HMAC based ciphersuites from RFC5289 */

# 520 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECDH GCM based ciphersuites from RFC5289 */
# 530 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* XXX
 * Inconsistency alert:
 * The OpenSSL names of ciphers with ephemeral DH here include the string
 * "DHE", while elsewhere it has always been "EDH".
 * (The alias for the list of all such ciphers also is "EDH".)
 * The specifications speak of "EDH"; maybe we should allow both forms
 * for everything. */
# 545 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* AES ciphersuites from RFC3268 */
# 553 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

# 560 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECC ciphersuites from draft-ietf-tls-ecc-01.txt (Mar 15, 2001) */






























/* PSK ciphersuites from RFC 4279 */





/* SRP ciphersuite from RFC 5054 */
# 608 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* Camellia ciphersuites from RFC4132 */
# 616 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

# 623 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* SEED ciphersuites from RFC4162 */
# 631 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS v1.2 ciphersuites */
# 646 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS v1.2 GCM ciphersuites from RFC5288 */
# 660 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECDH HMAC based ciphersuites from RFC5289 */

# 671 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* ECDH GCM based ciphersuites from RFC5289 */
# 681 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

# 691 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"
/* when correcting this number, correct also SSL3_CT_NUMBER in ssl3.h (see
 * comment there) */




# 714 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

# 733 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/tls1.h"

/* TLS Session Ticket extension struct */
struct tls_session_ticket_ext_st
        {
        unsigned short length;
        void *data;
        };

# 1390 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dtls1.h" 1
/* ssl/dtls1.h */
/* 
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.  
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/pqueue.h" 1
/* crypto/pqueue/pqueue.h */
/* 
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.  
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */











typedef struct _pqueue *pqueue;

typedef struct _pitem
        {
        unsigned char priority[8]; /* 64-bit value in big-endian encoding */
        void *data;
        struct _pitem *next;
        } pitem;

typedef struct _pitem *piterator;

pitem *pitem_new(unsigned char *prio64be, void *data);
void   pitem_free(pitem *item);

pqueue pqueue_new(void);
void   pqueue_free(pqueue pq);

pitem *pqueue_insert(pqueue pq, pitem *item);
pitem *pqueue_peek(pqueue pq);
pitem *pqueue_pop(pqueue pq);
pitem *pqueue_find(pqueue pq, unsigned char *prio64be);
pitem *pqueue_iterator(pqueue pq);
pitem *pqueue_next(piterator *iter);

void   pqueue_print(pqueue pq);
int    pqueue_size(pqueue pq);

# 65 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dtls1.h" 2
# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/time.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h" 1
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

# 37 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"

# 100 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/bits/time.h"

# 28 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/time.h" 2











# 50 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/time.h"



/* Structure crudely representing a timezone.
   This is obsolete and should never be used.  */
struct timezone
  {
    int tz_minuteswest;         /* Minutes west of GMT.  */
    int tz_dsttime;             /* Nonzero if DST is ever in effect.  */
  };

typedef struct timezone * __timezone_ptr_t;




/* Get the current time of day and timezone information,
   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
   Returns 0 on success, -1 on errors.
   NOTE: This form of timezone information is obsolete.
   Use the functions and variables declared in <time.h> instead.  */
extern int gettimeofday (struct timeval * __tv,
                         __timezone_ptr_t __tz)  ;


/* Set the current time of day and timezone information.
   This call is restricted to the super-user.  */
extern int settimeofday (const struct timeval *__tv,
                         const struct timezone *__tz)
     ;

/* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  */
extern int adjtime (const struct timeval *__delta,
                    struct timeval *__olddelta) ;



/* Values for the first argument to `getitimer' and `setitimer'.  */
enum __itimer_which
  {
    /* Timers run in real time.  */
    ITIMER_REAL = 0,

    /* Timers run only when the process is executing.  */
    ITIMER_VIRTUAL = 1,

    /* Timers run when the process is executing and when
       the system is executing on behalf of the process.  */
    ITIMER_PROF = 2

  };

/* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  */
struct itimerval
  {
    /* Value to put into `it_value' when the timer expires.  */
    struct timeval it_interval;
    /* Time to the next timer expiration.  */
    struct timeval it_value;
  };






typedef int __itimer_which_t;


/* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  */
extern int getitimer (__itimer_which_t __which,
                      struct itimerval *__value) ;

/* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  */
extern int setitimer (__itimer_which_t __which,
                      const struct itimerval * __new,
                      struct itimerval * __old) ;

/* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  */
extern int utimes (const char *__file, const struct timeval __tvp[2])
      ;


/* Same as `utimes', but does not follow symbolic links.  */
extern int lutimes (const char *__file, const struct timeval __tvp[2])
      ;

/* Same as `utimes', but takes an open file descriptor instead of a name.  */
extern int futimes (int __fd, const struct timeval __tvp[2]) ;


# 157 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/time.h"



/* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  */
# 188 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/sys/time.h"



# 79 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/dtls1.h" 2

















/* lengths of messages */























/* Max MTU overhead we know about so far is 40 for IPv6 + 8 for UDP */


typedef struct dtls1_bitmap_st
        {
        unsigned long map;              /* track 32 packets on 32-bit systems
                                           and 64 - on 64-bit systems */
        unsigned char max_seq_num[8];   /* max record number seen so far,
                                           64-bit value in big-endian
                                           encoding */
        } DTLS1_BITMAP;

struct dtls1_retransmit_state
        {
        EVP_CIPHER_CTX *enc_write_ctx;  /* cryptographic state */
        EVP_MD_CTX *write_hash;                 /* used for mac generation */

        COMP_CTX *compress;                             /* compression */



        SSL_SESSION *session;
        unsigned short epoch;
        };

struct hm_header_st
        {
        unsigned char type;
        unsigned long msg_len;
        unsigned short seq;
        unsigned long frag_off;
        unsigned long frag_len;
        unsigned int is_ccs;
        struct dtls1_retransmit_state saved_retransmit_state;
        };

struct ccs_header_st
        {
        unsigned char type;
        unsigned short seq;
        };

struct dtls1_timeout_st
        {
        /* Number of read timeouts so far */
        unsigned int read_timeouts;
        
        /* Number of write timeouts so far */
        unsigned int write_timeouts;
        
        /* Number of alerts received so far */
        unsigned int num_alerts;
        };

typedef struct record_pqueue_st
        {
        unsigned short epoch;
        pqueue q;
        } record_pqueue;

typedef struct hm_fragment_st
        {
        struct hm_header_st msg_header;
        unsigned char *fragment;
        unsigned char *reassembly;
        } hm_fragment;

typedef struct dtls1_state_st
        {
        unsigned int send_cookie;
        unsigned char cookie[256];
        unsigned char rcvd_cookie[256];
        unsigned int cookie_len;

        /* 
         * The current data and handshake epoch.  This is initially
         * undefined, and starts at zero once the initial handshake is
         * completed 
         */
        unsigned short r_epoch;
        unsigned short w_epoch;

        /* records being received in the current epoch */
        DTLS1_BITMAP bitmap;

        /* renegotiation starts a new set of sequence numbers */
        DTLS1_BITMAP next_bitmap;

        /* handshake message numbers */
        unsigned short handshake_write_seq;
        unsigned short next_handshake_write_seq;

        unsigned short handshake_read_seq;

        /* save last sequence number for retransmissions */
        unsigned char last_write_sequence[8];

        /* Received handshake records (processed and unprocessed) */
        record_pqueue unprocessed_rcds;
        record_pqueue processed_rcds;

        /* Buffered handshake messages */
        pqueue buffered_messages;

        /* Buffered (sent) handshake records */
        pqueue sent_messages;

        /* Buffered application records.
         * Only for records between CCS and Finished
         * to prevent either protocol violation or
         * unnecessary message loss.
         */
        record_pqueue buffered_app_data;

        /* Is set when listening for new connections with dtls1_listen() */
        unsigned int listen;

        unsigned int link_mtu; /* max on-the-wire DTLS packet size */
        unsigned int mtu; /* max DTLS packet size */

        struct hm_header_st w_msg_hdr;
        struct hm_header_st r_msg_hdr;

        struct dtls1_timeout_st timeout;

        /* Indicates when the last handshake msg or heartbeat sent will timeout */
        struct timeval next_timeout;

        /* Timeout duration */
        unsigned short timeout_duration;

        /* storage for Alert/Handshake protocol data received but not
         * yet processed by ssl3_read_bytes: */
        unsigned char alert_fragment[2];
        unsigned int alert_fragment_len;
        unsigned char handshake_fragment[12];
        unsigned int handshake_fragment_len;

        unsigned int retransmitting;
        /*
         * Set when the handshake is ready to process peer's ChangeCipherSpec message.
         * Cleared after the message has been processed.
         */
        unsigned int change_cipher_spec_ok;


        /* used when SSL_ST_XX_FLUSH is entered */
        int next_state;

        int shutdown_received;


        } DTLS1_STATE;

typedef struct dtls1_record_data_st
        {
        unsigned char *packet;
        unsigned int   packet_length;
        SSL3_BUFFER    rbuf;
        SSL3_RECORD    rrec;

        struct bio_dgram_sctp_rcvinfo recordinfo;

        } DTLS1_RECORD_DATA;



/* Timeout multipliers (timeout slice is defined in apps/timeouts.h */





# 1391 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl23.h" 1
/* ssl/ssl23.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */








/*client */
/* write to server */


/* read from server */



/* server */
/* read from client */








# 1392 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/srtp.h" 1
/* ssl/srtp.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */
/*
  DTLS code by Eric Rescorla <ekr@rtfm.com>

  Copyright (C) 2006, Network Resonance, Inc.
  Copyright (C) 2011, RTFM, Inc.
*/










     
# 134 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/srtp.h"



int SSL_CTX_set_tlsext_use_srtp(SSL_CTX *ctx, const char *profiles);
int SSL_set_tlsext_use_srtp(SSL *ctx, const char *profiles);
SRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *s);

struct stack_st_SRTP_PROTECTION_PROFILE *SSL_get_srtp_profiles(SSL *ssl);
SRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *s);









# 1393 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h" 2





/* compatibility */
# 1405 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* The following are the possible values for ssl->state are are
 * used to indicate where we are up to in the SSL connection establishment.
 * The macros that follow are about the only things you should need to use
 * and even then, only when using non-blocking IO.
 * It can also be useful to work out where you were when the connection
 * failed */

# 1420 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1434 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* Is the SSL_connection established? */
# 1442 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* The following 2 states are kept in ssl->rstate when reads fail,
 * you should not need these */




/* Obtain latest Finished message
 *   -- that we sent (SSL_get_finished)
 *   -- that we expected from peer (SSL_get_peer_finished).
 * Returns length (0 == no Finished so far), copies up to 'count' bytes. */
size_t SSL_get_finished(const SSL *s, void *buf, size_t count);
size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count);

/* use either SSL_VERIFY_NONE or SSL_VERIFY_PEER, the last 2 options
 * are 'ored' with SSL_VERIFY_PEER if they are desired */








/* this is for backward compatibility */
# 1474 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"
/* More backward compatibility */
# 1487 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"




SSL_SESSION *PEM_read_bio_SSL_SESSION(BIO *bp, SSL_SESSION * *x, pem_password_cb *cb, void *u); SSL_SESSION *PEM_read_SSL_SESSION(FILE *fp, SSL_SESSION * *x, pem_password_cb *cb, void *u); int PEM_write_bio_SSL_SESSION(BIO *bp, SSL_SESSION *x); int PEM_write_SSL_SESSION(FILE *fp, SSL_SESSION *x);



/* These alert types are for SSLv3 and TLSv1 */
# 1527 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1537 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1545 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1553 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"




/* only applies to datagram connections */

/* Stats */
# 1574 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1581 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"






/* see tls1.h for macros based on these */
# 1608 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"







# 1625 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"
















# 1647 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1656 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1665 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1674 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 1681 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"


BIO_METHOD *BIO_f_ssl(void);
BIO *BIO_new_ssl(SSL_CTX *ctx,int client);
BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
int BIO_ssl_copy_session_id(BIO *to,BIO *from);
void BIO_ssl_shutdown(BIO *ssl_bio);



int     SSL_CTX_set_cipher_list(SSL_CTX *,const char *str);
SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);
void    SSL_CTX_free(SSL_CTX *);
long SSL_CTX_set_timeout(SSL_CTX *ctx,long t);
long SSL_CTX_get_timeout(const SSL_CTX *ctx);
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
void SSL_CTX_set_cert_store(SSL_CTX *,X509_STORE *);
int SSL_want(const SSL *s);
int     SSL_clear(SSL *s);

void    SSL_CTX_flush_sessions(SSL_CTX *ctx,long tm);

const SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
int     SSL_CIPHER_get_bits(const SSL_CIPHER *c,int *alg_bits);
char *  SSL_CIPHER_get_version(const SSL_CIPHER *c);
const char *    SSL_CIPHER_get_name(const SSL_CIPHER *c);
unsigned long   SSL_CIPHER_get_id(const SSL_CIPHER *c);

int     SSL_get_fd(const SSL *s);
int     SSL_get_rfd(const SSL *s);
int     SSL_get_wfd(const SSL *s);
const char  * SSL_get_cipher_list(const SSL *s,int n);
char *  SSL_get_shared_ciphers(const SSL *s, char *buf, int len);
int     SSL_get_read_ahead(const SSL * s);
int     SSL_pending(const SSL *s);

int     SSL_set_fd(SSL *s, int fd);
int     SSL_set_rfd(SSL *s, int fd);
int     SSL_set_wfd(SSL *s, int fd);


void    SSL_set_bio(SSL *s, BIO *rbio,BIO *wbio);
BIO *   SSL_get_rbio(const SSL *s);
BIO *   SSL_get_wbio(const SSL *s);

int     SSL_set_cipher_list(SSL *s, const char *str);
void    SSL_set_read_ahead(SSL *s, int yes);
int     SSL_get_verify_mode(const SSL *s);
int     SSL_get_verify_depth(const SSL *s);
int     (*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *);
void    SSL_set_verify(SSL *s, int mode,
                       int (*callback)(int ok,X509_STORE_CTX *ctx));
void    SSL_set_verify_depth(SSL *s, int depth);

int     SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);

int     SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);
int     SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
int     SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, const unsigned char *d, long len);
int     SSL_use_certificate(SSL *ssl, X509 *x);
int     SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len);


int     SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
int     SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
int     SSL_use_certificate_file(SSL *ssl, const char *file, int type);
int     SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int     SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int     SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
int     SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file); /* PEM type */
struct stack_st_X509_NAME *SSL_load_client_CA_file(const char *file);
int     SSL_add_file_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs,
                                            const char *file);


int     SSL_add_dir_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs,
                                           const char *dir);





void    SSL_load_error_strings(void );
const char *SSL_state_string(const SSL *s);
const char *SSL_rstate_string(const SSL *s);
const char *SSL_state_string_long(const SSL *s);
const char *SSL_rstate_string_long(const SSL *s);
long    SSL_SESSION_get_time(const SSL_SESSION *s);
long    SSL_SESSION_set_time(SSL_SESSION *s, long t);
long    SSL_SESSION_get_timeout(const SSL_SESSION *s);
long    SSL_SESSION_set_timeout(SSL_SESSION *s, long t);
void    SSL_copy_session_id(SSL *to,const SSL *from);
X509 *SSL_SESSION_get0_peer(SSL_SESSION *s);
int SSL_SESSION_set1_id_context(SSL_SESSION *s,const unsigned char *sid_ctx,
                               unsigned int sid_ctx_len);

SSL_SESSION *SSL_SESSION_new(void);
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,
                                        unsigned int *len);
unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s);

int     SSL_SESSION_print_fp(FILE *fp,const SSL_SESSION *ses);


int     SSL_SESSION_print(BIO *fp,const SSL_SESSION *ses);

void    SSL_SESSION_free(SSL_SESSION *ses);
int     i2d_SSL_SESSION(SSL_SESSION *in,unsigned char **pp);
int     SSL_set_session(SSL *to, SSL_SESSION *session);
int     SSL_CTX_add_session(SSL_CTX *s, SSL_SESSION *c);
int     SSL_CTX_remove_session(SSL_CTX *,SSL_SESSION *c);
int     SSL_CTX_set_generate_session_id(SSL_CTX *, GEN_SESSION_CB);
int     SSL_set_generate_session_id(SSL *, GEN_SESSION_CB);
int     SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
                                        unsigned int id_len);
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,const unsigned char **pp,
                             long length);


X509 *  SSL_get_peer_certificate(const SSL *s);


struct stack_st_X509 *SSL_get_peer_cert_chain(const SSL *s);

int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);
int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *);
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,
                        int (*callback)(int, X509_STORE_CTX *));
void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg);

int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);

int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len);
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
int SSL_CTX_use_PrivateKey_ASN1(int pk,SSL_CTX *ctx,
        const unsigned char *d, long len);
int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d);

void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);

int SSL_CTX_check_private_key(const SSL_CTX *ctx);
int SSL_check_private_key(const SSL *ctx);

int     SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
                                       unsigned int sid_ctx_len);

SSL *   SSL_new(SSL_CTX *ctx);
int     SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
                                   unsigned int sid_ctx_len);

int SSL_CTX_set_purpose(SSL_CTX *s, int purpose);
int SSL_set_purpose(SSL *s, int purpose);
int SSL_CTX_set_trust(SSL_CTX *s, int trust);
int SSL_set_trust(SSL *s, int trust);

int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm);
int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm);


int SSL_CTX_set_srp_username(SSL_CTX *ctx,char *name);
int SSL_CTX_set_srp_password(SSL_CTX *ctx,char *password);
int SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,
                                        char *(*cb)(SSL *,void *));
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,
                                          int (*cb)(SSL *,void *));
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,
                                      int (*cb)(SSL *,int *,void *));
int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);

int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,
                             BIGNUM *sa, BIGNUM *v, char *info);
int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,
                                const char *grp);

BIGNUM *SSL_get_srp_g(SSL *s);
BIGNUM *SSL_get_srp_N(SSL *s);

char *SSL_get_srp_username(SSL *s);
char *SSL_get_srp_userinfo(SSL *s);


void    SSL_free(SSL *ssl);
int     SSL_accept(SSL *ssl);
int     SSL_connect(SSL *ssl);
int     SSL_read(SSL *ssl,void *buf,int num);
int     SSL_peek(SSL *ssl,void *buf,int num);
int     SSL_write(SSL *ssl,const void *buf,int num);
long    SSL_ctrl(SSL *ssl,int cmd, long larg, void *parg);
long    SSL_callback_ctrl(SSL *, int, void (*)(void));
long    SSL_CTX_ctrl(SSL_CTX *ctx,int cmd, long larg, void *parg);
long    SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));

int     SSL_get_error(const SSL *s,int ret_code);
const char *SSL_get_version(const SSL *s);

/* This sets the 'default' SSL version that SSL_new() will create */
int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);


const SSL_METHOD *SSLv2_method(void);           /* SSLv2 */
const SSL_METHOD *SSLv2_server_method(void);    /* SSLv2 */
const SSL_METHOD *SSLv2_client_method(void);    /* SSLv2 */



const SSL_METHOD *SSLv3_method(void);           /* SSLv3 */
const SSL_METHOD *SSLv3_server_method(void);    /* SSLv3 */
const SSL_METHOD *SSLv3_client_method(void);    /* SSLv3 */


const SSL_METHOD *SSLv23_method(void);  /* Negotiate highest available SSL/TLS version */
const SSL_METHOD *SSLv23_server_method(void);   /* Negotiate highest available SSL/TLS version */
const SSL_METHOD *SSLv23_client_method(void);   /* Negotiate highest available SSL/TLS version */

const SSL_METHOD *TLSv1_method(void);           /* TLSv1.0 */
const SSL_METHOD *TLSv1_server_method(void);    /* TLSv1.0 */
const SSL_METHOD *TLSv1_client_method(void);    /* TLSv1.0 */

const SSL_METHOD *TLSv1_1_method(void);         /* TLSv1.1 */
const SSL_METHOD *TLSv1_1_server_method(void);  /* TLSv1.1 */
const SSL_METHOD *TLSv1_1_client_method(void);  /* TLSv1.1 */

const SSL_METHOD *TLSv1_2_method(void);         /* TLSv1.2 */
const SSL_METHOD *TLSv1_2_server_method(void);  /* TLSv1.2 */
const SSL_METHOD *TLSv1_2_client_method(void);  /* TLSv1.2 */


const SSL_METHOD *DTLSv1_method(void);          /* DTLSv1.0 */
const SSL_METHOD *DTLSv1_server_method(void);   /* DTLSv1.0 */
const SSL_METHOD *DTLSv1_client_method(void);   /* DTLSv1.0 */

struct stack_st_SSL_CIPHER *SSL_get_ciphers(const SSL *s);

int SSL_do_handshake(SSL *s);
int SSL_renegotiate(SSL *s);
int SSL_renegotiate_abbreviated(SSL *s);
int SSL_renegotiate_pending(SSL *s);
int SSL_shutdown(SSL *s);

const SSL_METHOD *SSL_get_ssl_method(SSL *s);
int SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);
const char *SSL_alert_type_string_long(int value);
const char *SSL_alert_type_string(int value);
const char *SSL_alert_desc_string_long(int value);
const char *SSL_alert_desc_string(int value);

void SSL_set_client_CA_list(SSL *s, struct stack_st_X509_NAME *name_list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, struct stack_st_X509_NAME *name_list);
struct stack_st_X509_NAME *SSL_get_client_CA_list(const SSL *s);
struct stack_st_X509_NAME *SSL_CTX_get_client_CA_list(const SSL_CTX *s);
int SSL_add_client_CA(SSL *ssl,X509 *x);
int SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x);

void SSL_set_connect_state(SSL *s);
void SSL_set_accept_state(SSL *s);

long SSL_get_default_timeout(const SSL *s);

int SSL_library_init(void );

char *SSL_CIPHER_description(const SSL_CIPHER *,char *buf,int size);
struct stack_st_X509_NAME *SSL_dup_CA_list(struct stack_st_X509_NAME *sk);

SSL *SSL_dup(SSL *ssl);

X509 *SSL_get_certificate(const SSL *ssl);
/* EVP_PKEY */ struct evp_pkey_st *SSL_get_privatekey(SSL *ssl);

void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode);
int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);
void SSL_set_quiet_shutdown(SSL *ssl,int mode);
int SSL_get_quiet_shutdown(const SSL *ssl);
void SSL_set_shutdown(SSL *ssl,int mode);
int SSL_get_shutdown(const SSL *ssl);
int SSL_version(const SSL *ssl);
int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx);
int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
        const char *CApath);

SSL_SESSION *SSL_get_session(const SSL *ssl);
SSL_SESSION *SSL_get1_session(SSL *ssl); /* obtain a reference count */
SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx);
void SSL_set_info_callback(SSL *ssl,
                           void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl,int type,int val);
int SSL_state(const SSL *ssl);
void SSL_set_state(SSL *ssl, int state);

void SSL_set_verify_result(SSL *ssl,long v);
long SSL_get_verify_result(const SSL *ssl);

int SSL_set_ex_data(SSL *ssl,int idx,void *data);
void *SSL_get_ex_data(const SSL *ssl,int idx);
int SSL_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_SESSION_set_ex_data(SSL_SESSION *ss,int idx,void *data);
void *SSL_SESSION_get_ex_data(const SSL_SESSION *ss,int idx);
int SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_CTX_set_ex_data(SSL_CTX *ssl,int idx,void *data);
void *SSL_CTX_get_ex_data(const SSL_CTX *ssl,int idx);
int SSL_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_get_ex_data_X509_STORE_CTX_idx(void );

# 2004 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 2019 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"






     /* NB: the keylength is only applicable when is_export is true */

void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,
                                  RSA *(*cb)(SSL *ssl,int is_export,
                                             int keylength));

void SSL_set_tmp_rsa_callback(SSL *ssl,
                                  RSA *(*cb)(SSL *ssl,int is_export,
                                             int keylength));


void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,
                                 DH *(*dh)(SSL *ssl,int is_export,
                                           int keylength));
void SSL_set_tmp_dh_callback(SSL *ssl,
                                 DH *(*dh)(SSL *ssl,int is_export,
                                           int keylength));


void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,
                                 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
                                           int keylength));
void SSL_set_tmp_ecdh_callback(SSL *ssl,
                                 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
                                           int keylength));



const COMP_METHOD *SSL_get_current_compression(SSL *s);
const COMP_METHOD *SSL_get_current_expansion(SSL *s);
const char *SSL_COMP_get_name(const COMP_METHOD *comp);
struct stack_st_SSL_COMP *SSL_COMP_get_compression_methods(void);
int SSL_COMP_add_compression_method(int id,COMP_METHOD *cm);
# 2065 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* TLS extensions functions */
int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len);

int SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
                                  void *arg);

/* Pre-shared secret session resumption functions */
int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);

void SSL_set_debug(SSL *s, int debug);
int SSL_cache_hit(SSL *s);


const struct openssl_ssl_test_functions *SSL_test_functions(void);


/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_SSL_strings(void);

/* Error codes for the SSL functions. */

/* Function codes. */
# 2310 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

/* Reason codes. */
# 2615 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/ssl.h"

# 26 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h" 1
/* crypto/err/err.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */




# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/e_os2.h" 1
/* e_os2.h */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */



# 116 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h" 2






# 129 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"











# 1 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/errno.h" 1
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.5 Errors    <errno.h>
 */

# 61 "/opt/MATLAB/R2018a/polyspace/verifier/cxx/include/include-libc/errno.h"

/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */
# 141 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h" 2







typedef struct err_state_st
        {
        CRYPTO_THREADID tid;
        int err_flags[16];
        unsigned long err_buffer[16];
        char *err_data[16];
        int err_data_flags[16];
        const char *err_file[16];
        int err_line[16];
        int top,bottom;
        } ERR_STATE;

/* library */
# 172 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"
/* #define ERR_LIB_METH         12 */





/* #define ERR_LIB_SSL23        21 */
/* #define ERR_LIB_SSL2         22 */
/* #define ERR_LIB_SSL3         23 */
/* #define ERR_LIB_RSAREF       30 */
/* #define ERR_LIB_PROXY        31 */
# 201 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"



# 237 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"

/* Borland C seems too stupid to be able to shift and do longs in
 * the pre-processor :-( */
# 247 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"


/* OS functions */
# 261 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"


/* reasons */
# 293 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"

# 300 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"

/* fatal error */
# 308 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/err.h"

/* 99 is the maximum possible ERR_R_... code, higher values
 * are reserved for the individual libraries */


typedef struct ERR_string_data_st
        {
        unsigned long error;
        const char *string;
        } ERR_STRING_DATA;

void ERR_put_error(int lib, int func,int reason,const char *file,int line);
void ERR_set_error_data(char *data,int flags);

unsigned long ERR_get_error(void);
unsigned long ERR_get_error_line(const char **file,int *line);
unsigned long ERR_get_error_line_data(const char **file,int *line,
                                      const char **data, int *flags);
unsigned long ERR_peek_error(void);
unsigned long ERR_peek_error_line(const char **file,int *line);
unsigned long ERR_peek_error_line_data(const char **file,int *line,
                                       const char **data,int *flags);
unsigned long ERR_peek_last_error(void);
unsigned long ERR_peek_last_error_line(const char **file,int *line);
unsigned long ERR_peek_last_error_line_data(const char **file,int *line,
                                       const char **data,int *flags);
void ERR_clear_error(void );
char *ERR_error_string(unsigned long e,char *buf);
void ERR_error_string_n(unsigned long e, char *buf, size_t len);
const char *ERR_lib_error_string(unsigned long e);
const char *ERR_func_error_string(unsigned long e);
const char *ERR_reason_error_string(unsigned long e);
void ERR_print_errors_cb(int (*cb)(const char *str, size_t len, void *u),
                         void *u);

void ERR_print_errors_fp(FILE *fp);


void ERR_print_errors(BIO *bp);

void ERR_add_error_data(int num, ...);
void ERR_add_error_vdata(int num, va_list args);
void ERR_load_strings(int lib,ERR_STRING_DATA str[]);
void ERR_unload_strings(int lib,ERR_STRING_DATA str[]);
void ERR_load_ERR_strings(void);
void ERR_load_crypto_strings(void);
void ERR_free_strings(void);

void ERR_remove_thread_state(const CRYPTO_THREADID *tid);

void ERR_remove_state(unsigned long pid); /* if zero we look it up */

ERR_STATE *ERR_get_state(void);


struct lhash_st_ERR_STRING_DATA *ERR_get_string_table(void);
struct lhash_st_ERR_STATE *ERR_get_err_state_table(void);
void ERR_release_err_state_table(struct lhash_st_ERR_STATE **hash);


int ERR_get_next_error_library(void);

int ERR_set_mark(void);
int ERR_pop_to_mark(void);

/* Already defined in ossl_typ.h */
/* typedef struct st_ERR_FNS ERR_FNS; */
/* An application can use this function and provide the return value to loaded
 * modules that should use the application's ERR state/functionality */
const ERR_FNS *ERR_get_implementation(void);
/* A loaded module should call this function prior to any ERR operations using
 * the application's "ERR_FNS". */
int ERR_set_implementation(const ERR_FNS *fns);





# 27 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2
# 1 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h" 1
/* crypto/x509/x509_vfy.h */
/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */







# 567 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/include/openssl/x509_vfy.h"

# 30 "/matieres/4MMACSS/TP-PolySpace/Advanced-Secu/website_access/website_access.c" 2







static int hostname_to_ip(char * hostname , char* ip)
{
    struct hostent *he;
    struct in_addr **addr_list;
    int i;

    if ( (he = gethostbyname( hostname ) ) == ((void *)0)) 
    {
        printf("gethostbyname error!\n");
        return -1;
    }

    addr_list = (struct in_addr **) he->h_addr_list;

    for(i = 0; addr_list[i] != ((void *)0); i++) 
    {
        strncpy(ip , inet_ntoa(*addr_list[i]), strlen(inet_ntoa(*addr_list[i])) );
        return 0;
    }
    
    return -1;
}

static int DownloadURLFile(char *host, char *path, int port)
{
    FILE *file = ((void *)0);
    struct sockaddr_in server;
    int socket_desc;
    int header_len = 0;
    int total_len = 0;
    int received_len;
    int file_len;
    int header_end;
    char *p;
    char message[2048] = {0};
    char http_header[2048*2] = {0};
    char server_reply[10 * 1024] = {0};
    char ip[32];
    
    BIO *certbio = ((void *)0);
    BIO *outbio = ((void *)0);
    X509 *cert = ((void *)0);
    X509_NAME *certname = ((void *)0);
    const SSL_METHOD *method;
    SSL_CTX *ctx;
    SSL *ssl;

    OPENSSL_add_all_algorithms_noconf();
    ERR_load_BIO_strings();
    ERR_load_crypto_strings();
    SSL_load_error_strings();
    
    /* ---------------------------------------------------------- *
     * Create the Input/Output BIO's.                             *
     * ---------------------------------------------------------- */
    certbio = BIO_new(BIO_s_file());
    outbio = BIO_new_fp(stdout, 0x00);
    
    /* ---------------------------------------------------------- *
     * initialize SSL library and register algorithms             *
     * ---------------------------------------------------------- */
    if(SSL_library_init() < 0)
        BIO_printf(outbio, "Could not initialize the OpenSSL library !\n");
    
    /* ---------------------------------------------------------- *
     * Set SSLv2 client hello, also announce SSLv3 and TLSv1 *
     * ---------------------------------------------------------- */
    method = SSLv23_client_method();
    
    /* ---------------------------------------------------------- *
     * Try to create a new SSL context *
     * ---------------------------------------------------------- */
    if ( (ctx = SSL_CTX_new(method)) == ((void *)0))
        BIO_printf(outbio, "Unable to create a new SSL context structure.\n");
    
    /* ---------------------------------------------------------- *
     * Disabling SSLv2 will leave v3 and TSLv1 for negotiation    *
     * ---------------------------------------------------------- */
    SSL_CTX_ctrl((ctx),32,(0x01000000L),((void *)0));
    
    /* ---------------------------------------------------------- *
     * Create new SSL connection state object *
     * ---------------------------------------------------------- */
    ssl = SSL_new(ctx);
    
    // Create socket
    socket_desc = socket(2 , SOCK_STREAM , 0);
    if (socket_desc == -1) {
        printf("Could not create socket");
        return -1;
    }

    if(hostname_to_ip(host, ip)) return -1;
    server.sin_addr.s_addr = inet_addr(ip);
    server.sin_family = 2;
    server.sin_port = htons( port );
    
    // Connect to remote server
    printf(">>>>>>>>>> connect start\n");
    if (connect(socket_desc , (struct sockaddr *)&server , sizeof(server)) < 0) {
        printf("connect error");
        return -1;
    }
    printf(">>>>>>>>>> connect end\n");
    
    /* ---------------------------------------------------------- *
     * Attach the SSL session to the socket descriptor *
     * ---------------------------------------------------------- */
    SSL_set_fd(ssl, socket_desc);

    /* ---------------------------------------------------------- *
     * Try to SSL-connect here, returns 1 for success *
     * ---------------------------------------------------------- */
    if ( SSL_connect(ssl) != 1 )
        BIO_printf(outbio, "Error: Could not build a SSL session to: %s.\n", ip);
    else
        BIO_printf(outbio, "Successfully enabled SSL/TLS session to: %s.\n", ip);
    
    /* ---------------------------------------------------------- *
     * Get the remote certificate into the X509 structure *
     * ---------------------------------------------------------- */
    cert = SSL_get_peer_certificate(ssl);
    if (cert == ((void *)0))
        BIO_printf(outbio, "Error: Could not get a certificate from: %s.\n", ip);
    else
        BIO_printf(outbio, "Retrieved the server's certificate from: %s.\n", ip);
    
    /* ---------------------------------------------------------- *
     * extract various certificate information *
     * -----------------------------------------------------------*/
    certname = X509_NAME_new();
    certname = X509_get_subject_name(cert);
    
    /* ---------------------------------------------------------- *
     * display the cert subject here *
     * -----------------------------------------------------------*/
    BIO_printf(outbio, "Displaying the certificate subject data:\n");
    X509_NAME_print_ex(outbio, certname, 0, 0);
    BIO_printf(outbio, "\n");
    
    // Send request
    snprintf(message, 2048, "GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.1) Gecko/20100101 Firefox/10.0.1\r\nAccept: image/png,image/*;q=0.8,*/*;q=0.5\r\nAccept-Language: en-gb,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nConnection: keep-alive\r\n\r\n", path, host);
    printf("message=\n%s\n========================\n",message);
    if( SSL_write(ssl, message, strlen(message)) < 0) {
        printf("Send failed");
        return -1;
    }

    remove("/tmp/devicemiddleware.deb");
    file = fopen("/tmp/devicemiddleware.deb", "ab");
    if(file == ((void *)0)) {
        printf("File could not opened");
        return -1;
    }
    // Download header
    memset(message, 0, 2048);
    while(1)
    {
        received_len = SSL_read(ssl , message, 2048 - 1);
        
        if( received_len < 0 ){
            printf("recv failed");
            break;
        }
        
        if( header_len + received_len > 2048*2) {
            printf("header buffer overflow\n");
            return -1;
        }
        memcpy( &http_header[header_len], message, received_len);
        header_len += received_len;
        p = strstr(http_header, "\r\n\r\n");
        if( p != ((void *)0) ) {
            break;
        }
    }
    printf("header received complete.\n"
           "=====================================\n"
           "%s\n"
           "=====================================\n",
           http_header);

    if(strstr(http_header, "404 Not Found") != ((void *)0) ) {
        printf("Firmware File Not Found\n");
        return -1;
    }
    header_end = p - http_header + 4;
    p = strstr(http_header, "Content-Length");
    if( p == ((void *)0) ) {
        printf("ERROR : Empty Content-Length\n");
        return -1;
    }
    
    p = strtok(strstr(http_header, "Content-Length"), " :\r\n");
    p = strtok(((void *)0)," :\r\n");
    file_len = atoi(p);
    fwrite(&http_header[header_end], (header_len - header_end), 1, file);
    file_len -= (header_len - header_end);
    
    // Download Content
    while (1)
    {
        received_len = SSL_read(ssl, server_reply, sizeof(server_reply));
        if( received_len < 0 ){
            break;
        }
        if( total_len + received_len > file_len ) {
            received_len = file_len - total_len;
        }
        total_len += received_len;
        fwrite(server_reply, received_len, 1, file);
        if( total_len >= file_len ){
            break;
        } 
    }

    printf("filesize: <%d>\nreceived complete!!\n", total_len + (header_len - header_end));
    fclose(file);
    SSL_free(ssl);
    close(socket_desc);
    X509_free(cert);
    SSL_CTX_free(ctx);
    return 0;
}

static void url_to_host(char url_str[], char hostname[], int hostname_s, int *port)
{
    char proto[6] = "";
    /* ---------------------------------------------------------- *
     * Remove the final / from url_str, if there is one           *
     * ---------------------------------------------------------- */
    if(url_str[strlen(url_str)] == '/')
        url_str[strlen(url_str)] = '\0';

    /* ---------------------------------------------------------- *
     * the first : ends the protocol string, i.e. http            *
     * ---------------------------------------------------------- */
    strncpy(proto, url_str, (strchr(url_str, ':')-url_str));
    
    /* ---------------------------------------------------------- *
     * the hostname starts after the "://" part                   *
     * ---------------------------------------------------------- */
    const char *name_position = strstr(url_str, "://");
    if (name_position != ((void *)0))
    {
        name_position += 3;
        const char *port_position = strrchr(name_position, ':');
        if ((port_position != ((void *)0)) && (port_position > name_position))
        {
            int name_length = port_position - name_position;
            if (name_length < hostname_s)
                hostname_s = name_length;
            *port = atoi(port_position+1);
        }
        strncpy(hostname, name_position, hostname_s);
    }
}

/* ---------------------------------------------------------- *
 * First we need to make a standard TCP socket connection.    *
 * create_socket() creates a socket & TCP-connects to server. *
 * ---------------------------------------------------------- */

char dest_url[256] = "https://www.hp.com";

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        fprintf(stderr, "Usage %s <website>\n", argv[0]);
        fprintf(stderr, "<website> : https://www.hp.com for example\n");
        return 1;
    }
    else
    {
        int port = 443; /* default port */
        char hostname[256] = "";
        snprintf(dest_url, sizeof(dest_url), "%s", argv[1]);
        url_to_host(dest_url, hostname, sizeof(hostname), &port);
        DownloadURLFile(hostname, "", port);
    }
    return(0);
}
