frama.link/ensimagisi

nm kernel.bin | grep traitant_IT_32 : pour obtenir l'adresse du traitant

conventions du processeur Pentium :
registres scratch (on doit sauvegarder ces registres temporaires pour retrouver
leur valeur après l'appel de la fonction traitant_IT_32 dans le traitant) :
eax
acx
edx
registres non scratch (doivent retrouver leur valeur avant
et après l'exécution d'une fonction -> donc pas besoin de les sauvegarder
dans le traitant) :
ebx
esi
edi
ebp
esp

changer de processus :
1) sauvegarder l'état (le oontexte d'exécution) du processus 1
2) restaurer l'état du nouveau processus 2
3) sauvegarder l'état du processus 2
4) restaurer l'état du processus 1
-> mécanisme d'interruption qui va gérer cela en faisant des call

conventions du Pentium :
passage des arguments des fonctions par la pile (au lieu de registres comme dans le MIPS) à l'adresse %esp (pointeur de pile)
lorsqu'on fait un call, on sauvegarde dans la pile l'adresse de retour (la prochaine exécution sans compter la fonction dans son context) en stockant esp
dans la fonction appelée, la première chose à faire est de sauvegarder %ebp
function: push %ebp
	  mov %esp, %ebp
	  accès du premier argument de la fonction avec 8(%ebp)
	  si on ne fait pas le move, on peut aussi accéder au premier argument de la fonction avec 4(%esp)
	  dans le contexte de la fonction appelée, ebp est normalement toujours au même endroit relativement aux arguments (à 8 du premier)


ctxt_sw(ptrctxtP1, ptrctxtP2)
etx_sw :
esp -> @retour		(+0)
       ptrctxtP1	(+4)
       ptrctxtP2	(+8)
lorsqu'on change de processus avec ptrctxtP2, comme chaque processus a sa pile, on doit créer un nouvel espace mémoire pour la nouvelle pile associée à ce processus
pour allouer de la mémoire pour la pile, il faut l'adresse la plus faible ainsi que l'adresse la plus forte pour décaler esp pour ensuite empiler (adresses décroissantes)
