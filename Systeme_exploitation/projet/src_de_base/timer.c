#include <debug.h>
#include <string.h>
#include <cpu.h>
#include <segment.h>
#include <screen_manager.h>
#include <timer.h>

void incremente_temps(){
    nb_secs += 1;
    if (tps.sec == 59){
        tps.sec = 0;
        if (tps.min == 59){
            tps.min = 0;
            if (tps.heure == 23){
                tps.heure = 0;
            }
            else {tps.heure += 1;}
        }
        else {tps.min += 1;}
    }
    else {tps.sec += 1;}
}

uint32_t get_nb_secs(){
    return nb_secs;
}

void config_freq_horloge(){
    // réglage du timer à une fréquence de 50 Hz (on ne peut pas régler à 1)
    uint32_t freq = (uint32_t)QUARTZ / (uint32_t)CLOCKFREQ;
    uint8_t low_part_freq = 0xFF & freq;
    uint8_t high_part_freq = 0xFF & (freq >> 8);
    outb(TIMER_COMMAND, NUM_PORT_COMMAND_TIMER);
    outb(low_part_freq, NUM_PORT_DATA_TIMER);
    outb(high_part_freq, NUM_PORT_DATA_TIMER);
}

// entrée table d'interruption : une ligne est sur 8 octets (4 pour l'adresse)
// entrée numéro 32 : 0x1000 + 8*32 = 0x1100
// premier mot à l'adresse 0x1100 et le deuxième à l'adresse 0x1104
void init_traitant_IT(int32_t num_IT, void (*traitant)(void)){
    void * addr_first_word_entree = (void *)(ADDR_TABLE_IT + 8*num_IT);
    void * addr_second_word_entree = (void *)((uint32_t)addr_first_word_entree + 4);
    uint32_t kernelcs = KERNEL_CS << 16;
    uint32_t low_addr_traitant = 0xFFFF & (uint32_t)traitant;
    uint32_t first_word_entree = kernelcs | low_addr_traitant;
    uint32_t high_addr_traitant = 0xFFFF0000 & (uint32_t)traitant;
    uint32_t constant = 0x8E00;
    uint32_t second_word_entree = high_addr_traitant | constant;
    assert(memmove(addr_first_word_entree, (void *)(&first_word_entree),
                                              sizeof(uint32_t)) != NULL);  // ecriture en memoire de l'entrée (premier mot)
    assert(memmove(addr_second_word_entree, (void *)(&second_word_entree),
                                              sizeof(uint32_t)) != NULL);  // ecriture en memoire de l'entrée (deuxième mot)
}

void masque_IRQ(uint32_t num_IRQ, bool masque){
    uint8_t tab_masks = inb(NUM_PORT_MASK_DATA);
    uint8_t bit = (tab_masks << num_IRQ) % 2;
    if (bit != masque){ // si on doit configurer
        if (masque == false)
            tab_masks = tab_masks & ((1 << num_IRQ) ^ 0b11111111);  // inversion des bits du masque puis on force le bit num_IRQ à 0 sans changer les autres bits
        else {tab_masks = tab_masks | (1 << num_IRQ);}  // on force le bit num_IRQ à 1 sans changer les autres bits
        outb(tab_masks, NUM_PORT_MASK_DATA);
    }
}

void affichage_chaine(char * chaine){
    // sauvegarde de la position corante du curseur
    outb(LOW_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    uint8_t low_part_pos = inb(NUM_PORT_DATA_SCR);
    outb(HIGH_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    uint8_t high_part_pos = inb(NUM_PORT_DATA_SCR);
    uint32_t pos = (high_part_pos << 8) | low_part_pos;
    uint32_t lig = pos/NB_COL_SCREEN;
    uint32_t col = pos%NB_COL_SCREEN;
    // affichage du temps en haut à droite
    place_curseur(0, NB_COL_SCREEN - NB_CAR_TEMPS);
    printf("%s", chaine);
    // replace le curseur
    place_curseur(lig, col);
}

void affichage_temps(){
    char chaine[NB_CAR_TEMPS + 1];
    sprintf(chaine, "%02u:%02u:%02u", tps.heure, tps.min, tps.sec);
    affichage_chaine(chaine);
}

void tic_PIT(void){ // réalise le travail concret du traitant
    // on signale au contrôleur d'interruption qu'on va traiter une interruption
    outb(CTRL_IT_COMMAND, NUM_PORT_CTRL_IT);
    // on incrémente le temps de 1 sec tous les 50 tics
    cpt = (cpt + 1) % CLOCKFREQ;
    if (cpt == 0){
        incremente_temps();
        affichage_temps();
    }
    ordonnance();
}
