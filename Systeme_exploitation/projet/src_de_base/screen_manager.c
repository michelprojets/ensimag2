#include <debug.h>
#include <string.h>
#include <cpu.h>
#include <screen_manager.h>

uint16_t *ptr_mem(uint32_t lig, uint32_t col){
    return (uint16_t *)(DISPLAY_ADDR + (2 * (lig * NB_COL_SCREEN + col)));
}

void ecrit_car(uint32_t lig, uint32_t col, char c, uint8_t col_txt,
                uint8_t col_fond){
    void * addr = (void *)ptr_mem(lig, col);  // addresse a ecrire
    uint16_t ascii_c = (uint16_t)c; // recuperation code ascii
    uint16_t format_c = ((uint16_t)(col_fond << 4)) | ((uint16_t)col_txt);  // bit 7 a 0 par defaut (pas de clignottement)
    uint16_t case_c = (format_c << 8) | ascii_c;  // fusion en respectant l'endianness (little : inversion octets)
    assert(memmove(addr, (void *)(&case_c), sizeof(uint16_t)) != NULL);  // ecriture en memoire pour l'affichage
}

void efface_ecran(void){
    for (uint8_t i=0; i<NB_LIG_SCREEN; ++i){
        for (uint8_t j=0; j<NB_COL_SCREEN; ++j){
            ecrit_car(i, j, ' ', BLANC, NOIR);
        }
    }
}

void place_curseur(uint32_t lig, uint32_t col){
    uint32_t pos = lig * NB_COL_SCREEN + col;
    uint8_t low_part_pos = 0xFF & pos;
    uint8_t high_part_pos = 0xFF & (pos >> 8);
    outb(LOW_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    outb(low_part_pos, NUM_PORT_DATA_SCR);
    outb(HIGH_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    outb(high_part_pos, NUM_PORT_DATA_SCR);
}

void defilement(void){
    uint16_t nb_octets_ecran = 2 * NB_LIG_SCREEN * NB_COL_SCREEN;
    uint16_t offset = 2 * NB_COL_SCREEN;
    assert(memmove((void *)DISPLAY_ADDR, (void *)(DISPLAY_ADDR + offset),
                    nb_octets_ecran - offset) != NULL);
    // effacement de la dernière ligne
    for (uint8_t j=0; j<NB_COL_SCREEN; ++j){
        ecrit_car(NB_LIG_SCREEN-1, j, ' ', BLANC, NOIR);
    }
}

void traite_car(char c){
    // récupération de la position corante du curseur
    outb(LOW_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    uint8_t low_part_pos = inb(NUM_PORT_DATA_SCR);
    outb(HIGH_PART_SCR_COMMAND, NUM_PORT_COMMAND_SCR);
    uint8_t high_part_pos = inb(NUM_PORT_DATA_SCR);
    uint32_t pos = (high_part_pos << 8) | low_part_pos;
    uint32_t lig = pos/NB_COL_SCREEN;
    uint32_t col = pos%NB_COL_SCREEN;
    // traitements
    switch(c){
        case '\b' : if (col != 0) col -= 1;
                    break;
        case '\t' : if (col == NB_COL_SCREEN-1) {
                        col = 0;
                        if (lig == NB_LIG_SCREEN-1) {defilement();}
                        else {lig += 1;}
                    }
                    else {
                        uint8_t nb_cases = NB_COL_SCREEN / TAB + 1;
                        // initialisation du tableau contenant les colonnes de tabulation
                        uint8_t tabu[nb_cases];
                        for (uint8_t i=0; i<nb_cases-1; ++i) {tabu[i] = i * TAB;}
                        tabu[nb_cases-1] = (nb_cases - 1) * TAB - 1;
                        col = tabu[(col / 8) + 1];
                    }
                    break;
        case '\n' : col = 0;
                    if (lig == NB_LIG_SCREEN-1) {defilement();}
                    else {lig += 1;}
                    break;
        case '\f' : efface_ecran();
                    lig = 0; col = 0;
                    break;
        case '\r' : col = 0;
                    break;
        // à afficher à l'écran
        default : if ((uint8_t)c < 32 || (uint8_t)c > 126) {return;}
                  ecrit_car(lig, col, c, 0x7, 0x0); // écriture en gris par défaut
                  if (col == NB_COL_SCREEN-1){
                      col = 0;
                      if (lig == NB_LIG_SCREEN-1) {defilement();}
                      else {lig += 1;}
                  }
                  else {col += 1;}
    }
    place_curseur(lig, col);  // placement du nouveau curseur
}

void console_putbytes(char *chaine, int32_t taille){
    for(uint8_t i=0; i<taille; ++i){
        traite_car(chaine[i]);
    }
}
