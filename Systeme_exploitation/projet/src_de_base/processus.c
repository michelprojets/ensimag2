#include <debug.h>
#include <string.h>
#include <cpu.h>
#include <processus.h>

extern void ctx_sw(uint32_t * ptr_ctxt_p1, uint32_t * ptr_ctxt_p2);

char * mon_nom()
{
    return proc_elu->nom;
}

uint32_t mon_pid()
{
    return proc_elu->pid;
}

void ordonnance(void)
{
    Processus * curr_proc = proc_elu;
    curr_proc->etat = ELLIGIBLE;
    uint32_t next_index;
    Processus * next_proc;
    do {
      next_index = ((proc_elu->pid) + 1)%NB_PROCS;
      next_proc = &(processus_table[next_index]);
    }
    while (next_proc->etat != ELLIGIBLE);
    proc_elu = next_proc;
    next_proc->etat = ELU;
    ctx_sw(curr_proc->save_registers, next_proc->save_registers);
}

void idle(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc1(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void init_processus(void)
{
    char * noms[NB_PROCS] = {"idle", "proc1"};

    processus_table = (Processus *)(calloc(NB_PROCS, sizeof(Processus)));
    for (uint32_t pid=0; pid<NB_PROCS; ++pid){
      processus_table[pid].pid = pid;
      // processus_table[pid].nom = (char *)(malloc(sizeof(noms[pid])));
      processus_table[pid].nom = (char *)(calloc(strlen(noms[pid])+1, sizeof(char)));
      strcpy(processus_table[pid].nom, noms[pid]);
      processus_table[pid].save_registers = (uint32_t *)(calloc(NB_REGISTRES_TO_SAVE,
                                                              sizeof(uint32_t)));
      processus_table[pid].exec_stack = (uint32_t *)(calloc(EXEC_STACK_SIZE,
                                                          sizeof(uint32_t)));
    }
    processus_table[0].etat = ELU;
    processus_table[1].etat = ELLIGIBLE;

    processus_table[1].save_registers[1] =
                  (uint32_t)(&((processus_table[1].exec_stack)[EXEC_STACK_SIZE-1]));
    (processus_table[1].exec_stack)[EXEC_STACK_SIZE-1] = (uint32_t)(proc1);

    proc_elu = &(processus_table[0]);
}
