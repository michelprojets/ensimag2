#include <debug.h>
#include <string.h>
#include <cpu.h>
#include <processus.h>

extern void ctx_sw(uint32_t * ptr_ctxt_p1, uint32_t * ptr_ctxt_p2);

char * mon_nom()
{
    return proc_elu->nom;
}

uint32_t mon_pid()
{
    return proc_elu->pid;
}

void insertion_liste_queue_file_activables(Processus * liste_queue){
    if (liste_queue == NULL)
        return;
    liste_queue->etat = ELLIGIBLE;
    Processus * queue = liste_queue;
    while(queue->suivant != NULL){
        queue = queue->suivant;
        queue->etat = ELLIGIBLE;
    }
    if (file_activables->tete == NULL)  // file vide
        file_activables->tete = liste_queue;
    else  // file a un ou plusieurs processus
        file_activables->queue->suivant = liste_queue;
    file_activables->queue = queue;
}

Processus * extraction_tete_file_activables(){
    Processus * tete = file_activables->tete;
    if (tete == NULL)  // file vide
        return NULL;
    // ne pas changer l etat de tete en ELU, c est ordonnance() qui doit potentiellement le faire !
    if (tete == file_activables->queue){  // file a un seul processus
        file_activables->tete = NULL;
        file_activables->queue = NULL;
    }
    else  // liste a plusieurs processus
        file_activables->tete = tete->suivant;
    tete->suivant = NULL;
    return tete;
}

/*
void enlever_processus_file_activables(Processus * processus){
    if (processus == NULL)
        return;
    if (file_activables == NULL)  // file vide
        return;
    Processus * tete = file_activables->tete;
    if (tete == file_activables->queue){  // file a un seul processus
        if (tete == processus){
            file_activables->tete = NULL;
            file_activables->queue = NULL;
            processus->suivant = NULL;
        }
    }
    else{ // file a plusieurs processus
        if (tete == processus){ // supression de la tete de la file
            file_activables->tete = tete->suivant;
        }
        Processus * courant = tete;
        while (courant->suivant != NULL){
            if (courant->suivant == processus){
                courant->suivant = courant->suivant->suivant;
                processus->suivant = NULL;
                return;
            }
            courant = courant->suivant;
        }
    }
}
*/

void insertion_liste_endormis(Processus * processus){
    if (processus == NULL)
        return;
    processus->etat = ENDORMI;
    if (liste_endormis == NULL){  // liste vide
        processus->suivant = NULL;
        liste_endormis = processus;
    }
    else{ // liste a un ou plusieurs processus
        uint32_t nb_secs_reveil = processus->nb_secs_reveil;
        Processus * courant = liste_endormis;
        if (nb_secs_reveil <= courant->nb_secs_reveil){ // insertion en debut de liste
            processus->suivant = courant;
            liste_endormis = processus;
        }
        else{ // que ce soit une insertion en fin de liste ou en milieu de liste
            Processus * suivant = liste_endormis->suivant;
            while(suivant != NULL){
                if (nb_secs_reveil <= suivant->nb_secs_reveil)
                    break;
                courant = suivant;
                suivant = suivant->suivant;
            }
            processus->suivant = suivant;
            courant->suivant = processus;
        }
    }
}

Processus * extraction_liste_endormis_jusqua(uint32_t nb_secs_reveil){
    if (liste_endormis == NULL) // liste vide
        return NULL;
    Processus * courant = liste_endormis;
    if (nb_secs_reveil < courant->nb_secs_reveil)  // rien a extraire
        return NULL;
    // une liste de un ou plusieurs processus a extraire
    Processus * liste_extraits = liste_endormis;
    courant->etat = ELLIGIBLE;
    Processus * suivant = liste_endormis->suivant;
    while (suivant != NULL){
        courant->etat = ELLIGIBLE;
        if (nb_secs_reveil < suivant->nb_secs_reveil){
            courant->suivant = NULL;
            liste_endormis = suivant;
            break;
        }
        courant = suivant;
        suivant = suivant->suivant;
    }
    if (suivant == NULL)  // si on doit extraire toute la liste
        liste_endormis = NULL;
    return liste_extraits;
}

void insertion_tete_liste_mourrants(Processus * tete){
    if (tete == NULL)
        return;
    tete->etat = MOURANT;
    if (liste_mourrants == NULL)  // liste vide
        liste_mourrants = tete;
    else{ // liste a un ou plusieurs processus
        tete->suivant = liste_mourrants;
        liste_mourrants = tete;
    }
}

void tuer_processus_liste_mourrants(){
    if (liste_mourrants == NULL) // liste vide
        return;
    Processus * courant = liste_mourrants;
    Processus * suivant;
    do{
        suivant = courant->suivant; // sauvegarde du suivant avant de le free()
        table_processus[courant->pid] = NULL; // suppression de la table facile grace a l invariant
        free(courant->nom);
        free(courant->save_registers);
        free(courant->exec_stack);
        free(courant);
        courant = suivant;
    } while (suivant != NULL);
    liste_mourrants = NULL;
}

void changer_processus(){
    Processus * curr_proc = proc_elu;
    Processus * next_proc = extraction_tete_file_activables();

    if (next_proc == NULL)  // s'il n y a plus de processus ELLIGIBLE
        return;

    // ici next_proc a pour etat ELLIGIBLE
    next_proc->etat = ELU;
    proc_elu = next_proc;
    // si on doit endormir le processus elu, on ne le remet pas dans la liste des activables
    if (curr_proc->etat != ENDORMI && curr_proc->etat != MOURANT)
        insertion_liste_queue_file_activables(curr_proc);

    ctx_sw(curr_proc->save_registers, next_proc->save_registers);

    // // terminaison de tous les eventuels processus mourrants
    // tuer_processus_liste_mourrants();

    /*
    logiquement, comme il y a seulement 1 seul processus qui peut se termine a la fois,
    on peut liberer la memoire de ce processus ici, juste apres ctx_sw() (car il revient necessairement apres)
    */
    /*
    la deuxieme solution etait de faire comme on a fait ici, faire une liste des mourrants,
    mais la liste est cense contenir seulement 1 seul processus a la fois (pas dans notre cas, on peut en avoir plusieurs)
    */
}

/*
Comme on masque IMPLICITEMENT les interruptions externes lorsqu'on execute le traitant d'interruption traitant_IT_32(),
alors traitant_IT_32() est une operation atomique car il ne peut pas etre interrompu,
donc tic_PIT() est aussi une operation atomique a fortiori,
et donc ordonnance() est aussi une operation attomique a fortiori
*/
void ordonnance(void)
{
    // reveil de tous les eventuels processus endormis
    Processus * endormis = extraction_liste_endormis_jusqua(get_nb_secs());
    if (endormis != NULL)
        insertion_liste_queue_file_activables(endormis);

    // on tue tous les processus mourrants
    tuer_processus_liste_mourrants();

    // changement du processus en cours d execution (le processus ELU)
    changer_processus();
}

void dors(uint32_t dors_nb_secs){
    Processus * processus = proc_elu;
    processus->nb_secs_reveil = get_nb_secs() + dors_nb_secs;
    insertion_liste_endormis(processus);
    changer_processus(); // pour donner la main au suivant, sinon boucle sur le processus endormi
}

void fin_processus(){
    Processus * processus = proc_elu;
    insertion_tete_liste_mourrants(processus);
    changer_processus(); // pour donner la main au suivant avant la suppression du processus
}

void affichage_etat()
{
    char chaine[(NB_PROCS_MAX * NB_CAR_PROC) + 1];
    char chaine_processus[NB_CAR_PROC + 1];
    char chaine_pid[NB_CAR_PID + 1];
    char chaine_etat[NB_CAR_ETAT + 1];
    for (uint32_t pid=0; pid<pid_suivant; ++pid){
        if (table_processus[pid] == NULL){  // si pas de processus a la case donnee
            strcpy(chaine_processus, "");
            strcat(chaine_processus, "[NULL        ]");
        }
        else{
            sprintf(chaine_pid, "%02u", table_processus[pid]->pid);
            switch(table_processus[pid]->etat){
                case ELU:
                    strcpy(chaine_etat, "ELU      ");
                    break;
                case ELLIGIBLE:
                    strcpy(chaine_etat, "ELLIGIBLE");
                    break;
                case ENDORMI:
                    strcpy(chaine_etat, "ENDORMI  ");
                    break;
                case MOURANT:
                    strcpy(chaine_etat, "MOURANT  ");
                    break;
                default: break;
            }
            strcpy(chaine_processus, "");
            strcat(chaine_processus, "[");
            strcat(chaine_processus, chaine_pid);
            strcat(chaine_processus, ",");
            strcat(chaine_processus, chaine_etat);
            strcat(chaine_processus, "]");
        }
        if (pid == 0)
            strcpy(chaine, chaine_processus);
        else
            strcat(chaine, chaine_processus);
    }
    for (uint32_t pid=pid_suivant; pid<NB_PROCS_MAX; ++pid){  // le reste (les cases de la table qui n ont pas encore ete alloc)
        strcpy(chaine_processus, "");
        strcat(chaine_processus, "[NULL        ]");
        strcat(chaine, chaine_processus);
    }
    affichage_chaine(chaine, 1, (NB_COL_SCREEN - (NB_PROCS_MAX * NB_CAR_PROC)));
}

uint32_t pid_dispo(){
    uint32_t pid;
    for (pid=NB_PROCS_MAX-1; pid>0; --pid)
        if (table_processus[pid] == NULL)
            break;
    if (pid == 0)
        return (table_processus[pid] == NULL)?pid:NB_PROCS_MAX; // pour retourner une valeur incoherente mais qui soit positive
    while (table_processus[pid] == NULL){
        if (pid == 0)
            return pid;
        pid -= 1;
    }
    pid += 1;
    return pid;
}

int32_t creer_processus(void (*code_proc)(void), char * nom){
    uint32_t pid;

    if (pid_suivant == NB_PROCS_MAX){
        pid = pid_dispo();
        if (pid == NB_PROCS_MAX)
            return -1;
    }
    else{ // tant que le pid max courant n a pas ete atteint, on doit alloc
        if (pid_suivant == 0){ // premier processus cree
            table_processus = (Processus **)(malloc(sizeof(Processus *)));
            file_activables = (File *)(malloc(sizeof(File)));
        }
        else{
            table_processus = (Processus **)(realloc(table_processus,
                                      sizeof(Processus *)*(pid_suivant+1)));
        }
        pid = pid_suivant;
        pid_suivant += 1;
    }

    table_processus[pid] = (Processus *)(malloc(sizeof(Processus)));
    table_processus[pid]->pid = pid;
    table_processus[pid]->nom = (char *)(calloc(strlen(nom)+1, sizeof(char)));
    strcpy(table_processus[pid]->nom, nom);
    table_processus[pid]->save_registers =
                    (uint32_t *)(calloc(NB_REGISTRES_TO_SAVE, sizeof(uint32_t)));
    table_processus[pid]->exec_stack =
                    (uint32_t *)(calloc(EXEC_STACK_SIZE, sizeof(uint32_t)));
    table_processus[pid]->suivant = NULL; // pour effacer potentiellement l ancien suivant

    if (pid != 0){
        table_processus[pid]->save_registers[1] =
          (uint32_t)(&((((table_processus[pid])->exec_stack)[EXEC_STACK_SIZE-2])));
        // on initialise le code de la fonction associee
        (table_processus[pid]->exec_stack)[EXEC_STACK_SIZE-2] = (uint32_t)(code_proc);
        insertion_liste_queue_file_activables(table_processus[pid]);
        // on initialise le code de la fonction de terminaison de processus (on a decale le somme de pile de 4 octets, donc EXEC_STACK_SIZE-2)
        (table_processus[pid]->exec_stack)[EXEC_STACK_SIZE-1] = (uint32_t)(fin_processus);
    }

    return pid;
}

void idle(void)
{
    for(;;){
        sti();  // démasquage (permet) des interruptions externes
        hlt();  // endort le processeur (pour economiser de l energie) jusqu a l arrivee d une interruption
        cli();  // masquage (desactive) des interruptions externes (pas tres utile en vrai)
    }
}

void proc1(void)
{
    for(uint32_t i=0; i<3; i++){
        printf("[temps = %u] processus %s pid = %i\n", get_nb_secs(), mon_nom(), mon_pid());
        dors(3);
    }
}

void proc2(void)
{
    for(uint32_t i=0; i<3; i++){
        printf("[temps = %u] processus %s pid = %i\n", get_nb_secs(), mon_nom(), mon_pid());
        dors(3);
    }
}

void proc4(void)
{
    printf("[temps = %u] processus %s pid = %i\n", get_nb_secs(), mon_nom(), mon_pid());
    dors(15);
}

void proc3(void)
{
    for(uint32_t i=0; i<3; i++){
        printf("[temps = %u] processus %s pid = %i\n", get_nb_secs(), mon_nom(), mon_pid());
        dors(5);
    }
    char nom[8];
    char num[2];
    uint32_t i;
    for(i=1; i<4; i++){ // proc4.1 a le pid 4, proc4.2 a le pid 1, et proc4.3 a le pid 2
        strcpy(nom, "proc4.");
        sprintf(num, "%i", i);
        strcat(nom, num);
        if (creer_processus(proc4, nom) == -1)
            printf("Nombre maximum de processus crees atteint\n");
    }
    dors(10);
    strcpy(nom, "proc4.");
    sprintf(num, "%i", i);
    strcat(nom, num);
    if (creer_processus(proc4, nom) == -1)  // proc 4.4 ne doit pas pouvoir se creer
        printf("Nombre maximum de processus crees atteint\n");
    dors(10);
}

void init_processus(void)
{
    pid_suivant = 0;
    // creation de tous les processus de base
    void * codes[NB_PROCS_MAX] = {idle, proc1, proc2, proc3};
    char * noms[NB_PROCS_MAX] = {"idle", "proc1", "proc2", "proc3"};
    for(uint32_t i=0; i<4; ++i)
        if (creer_processus(codes[i], noms[i]) == -1)
            printf("Nombre maximum de processus crees atteint\n");

    // on elu le premier processus (idle) au depart
    table_processus[0]->etat = ELU;
    proc_elu = table_processus[0];
}
