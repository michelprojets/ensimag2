#include <debug.h>
#include <string.h>
#include <cpu.h>
#include <processus.h>

extern void ctx_sw(uint32_t * ptr_ctxt_p1, uint32_t * ptr_ctxt_p2);

char * mon_nom()
{
    return proc_elu->nom;
}

uint32_t mon_pid()
{
    return proc_elu->pid;
}

void ordonnance(void)
{
    Processus * curr_proc = proc_elu;
    curr_proc->etat = ELLIGIBLE;
    uint32_t next_index;
    Processus * next_proc;
    do {
      next_index = ((proc_elu->pid) + 1)%NB_PROCS;
      next_proc = processus_table[next_index];
    }
    while (next_proc->etat != ELLIGIBLE);
    proc_elu = next_proc;
    next_proc->etat = ELU;
    ctx_sw(curr_proc->save_registers, next_proc->save_registers);
}

void idle(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc1(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc2(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc3(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc4(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc5(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc6(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

void proc7(void)
{
    for(;;){
        printf("[%s] pid = %i\n", mon_nom(), mon_pid());
        ordonnance();
    }
}

int32_t creer_processus(void (*code_proc)(void), char * nom){
  if (nb_procs_crees == NB_PROCS)
    return -1;

  uint32_t pid = nb_procs_crees;

  if (pid == 0)
    processus_table = (Processus **)(malloc(sizeof(Processus *)));
  else
    processus_table = (Processus **)(realloc(processus_table,
                                             sizeof(Processus *)*(pid+1)));

  processus_table[pid] = (Processus *)(malloc(sizeof(Processus)));
  processus_table[pid]->pid = pid;
  processus_table[pid]->nom = (char *)(calloc(strlen(nom)+1, sizeof(char)));
  strcpy(processus_table[nb_procs_crees]->nom, nom);
  processus_table[pid]->etat = ELLIGIBLE;
  processus_table[pid]->save_registers =
                  (uint32_t *)(calloc(NB_REGISTRES_TO_SAVE, sizeof(uint32_t)));
  processus_table[pid]->exec_stack =
                  (uint32_t *)(calloc(EXEC_STACK_SIZE, sizeof(uint32_t)));

  if (nb_procs_crees != 0){
    processus_table[pid]->save_registers[1] =
      (uint32_t)(&((((processus_table[pid])->exec_stack)[EXEC_STACK_SIZE-1])));
    (processus_table[pid]->exec_stack)[EXEC_STACK_SIZE-1] = (uint32_t)(code_proc);
  }

  ++nb_procs_crees;

  return pid;
}

void init_processus(void)
{
    nb_procs_crees = 0;
    // creation de tous les processus
    void * codes[NB_PROCS] = {idle, proc1, proc2, proc3, proc4, proc5, proc6, proc7};
    char * noms[NB_PROCS] = {"idle", "proc1", "proc2", "proc3", "proc4",
                             "proc5", "proc6", "proc7"};
    int32_t pid;
    for(uint32_t i=0; i<NB_PROCS; ++i){
      pid = creer_processus(codes[i], noms[i]);
      if (pid == -1)
        printf("Nombre maximum de processus crees atteint\n");
    }

    // on elu le premier processus (idle) au depart
    processus_table[0]->etat = ELU;
    proc_elu = processus_table[0];
}
